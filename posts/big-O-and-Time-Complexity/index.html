<!doctype html><html lang="ko" data-mode="light"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" ><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="Big-O notation and complexity(big-O 표기법과 복잡도)" /><meta name="author" content="KanghoonYi(pour)" /><meta property="og:locale" content="ko" /><meta name="description" content="디스크에 있는 파일을 다른 지역의 친구에게 보낸다고 해보자. 대부분의 사람이, 이메일이나 FTP와 같은 network방식을 떠올리게됩니다. 하지만 파일의 크기가 1TB라면? 이럴때는 자동차를 타고 직접 전달하는게 빠르지 않을까? 이렇게 어떤 행위(컴퓨터에선 알고리즘을 의미)에 대한 비용을 어떻게 비교할까요? 여기선 컴퓨터에서 효율성을 비교하는 방법을 알아보겠습니다." /><meta property="og:description" content="디스크에 있는 파일을 다른 지역의 친구에게 보낸다고 해보자. 대부분의 사람이, 이메일이나 FTP와 같은 network방식을 떠올리게됩니다. 하지만 파일의 크기가 1TB라면? 이럴때는 자동차를 타고 직접 전달하는게 빠르지 않을까? 이렇게 어떤 행위(컴퓨터에선 알고리즘을 의미)에 대한 비용을 어떻게 비교할까요? 여기선 컴퓨터에서 효율성을 비교하는 방법을 알아보겠습니다." /><link rel="canonical" href="https://blog.devpour.net/posts/big-O-and-Time-Complexity/" /><meta property="og:url" content="https://blog.devpour.net/posts/big-O-and-Time-Complexity/" /><meta property="og:site_name" content="KanghoonYi(Pour)" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2024-08-29T19:00:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Big-O notation and complexity(big-O 표기법과 복잡도)" /><meta name="google-site-verification" content="rsx_-5MJzSR_3NNCqHNe9IxnKJxlD8Eid8_wN8e9c1I" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"KanghoonYi(pour)","url":"https://www.linkedin.com/in/pour/"},"dateModified":"2025-06-25T00:39:46+09:00","datePublished":"2024-08-29T19:00:00+09:00","description":"디스크에 있는 파일을 다른 지역의 친구에게 보낸다고 해보자. 대부분의 사람이, 이메일이나 FTP와 같은 network방식을 떠올리게됩니다. 하지만 파일의 크기가 1TB라면? 이럴때는 자동차를 타고 직접 전달하는게 빠르지 않을까? 이렇게 어떤 행위(컴퓨터에선 알고리즘을 의미)에 대한 비용을 어떻게 비교할까요? 여기선 컴퓨터에서 효율성을 비교하는 방법을 알아보겠습니다.","headline":"Big-O notation and complexity(big-O 표기법과 복잡도)","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.devpour.net/posts/big-O-and-Time-Complexity/"},"url":"https://blog.devpour.net/posts/big-O-and-Time-Complexity/"}</script><title>Big-O notation and complexity(big-O 표기법과 복잡도) | KanghoonYi(Pour)</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="KanghoonYi(Pour)"><meta name="application-name" content="KanghoonYi(Pour)"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="/assets/css/jekyll-theme-chirpy.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.6.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.29.0/dist/tocbot.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/glightbox@3.3.0/dist/css/glightbox.min.css"><body><aside aria-label="Sidebar" id="sidebar" class="d-flex flex-column align-items-end"><header class="profile-wrapper"> <a href="/" id="avatar" class="rounded-circle"><img src="/assets/img/pour_profile_img.png" width="112" height="112" alt="avatar" onerror="this.style.display='none'"></a><h1 class="site-title"> <a href="/">KanghoonYi(Pour)</a></h1><p class="site-subtitle fst-italic mb-0">안녕하세요~ Software Engineer pour입니다 This is Pour.</p></header><nav class="flex-column flex-grow-1 w-100 ps-0"><ul class="nav"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle"></i> <span>ABOUT</span> </a></ul></nav><div class="sidebar-bottom d-flex flex-wrap align-items-center w-100"> <a href="https://github.com/KanghoonYi" aria-label="github" target="_blank" rel="noopener noreferrer" > <i class="fab fa-github"></i> </a> <a href="https://twitter.com/" aria-label="twitter" target="_blank" rel="noopener noreferrer" > <i class="fa-brands fa-x-twitter"></i> </a> <a href="javascript:location.href = 'mailto:' + ['rkdgnsdls','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></aside><div id="main-wrapper" class="d-flex justify-content-center"><div class="container d-flex flex-column px-xxl-5"><header id="topbar-wrapper" aria-label="Top Bar"><div id="topbar" class="d-flex align-items-center justify-content-between px-lg-3 h-100" ><nav id="breadcrumb" aria-label="Breadcrumb"> <span> <a href="/">Home</a> </span> <span>Big-O notation and complexity(big-O 표기법과 복잡도)</span></nav><button type="button" id="sidebar-trigger" class="btn btn-link"> <i class="fas fa-bars fa-fw"></i> </button><div id="topbar-title"> Post</div><button type="button" id="search-trigger" class="btn btn-link"> <i class="fas fa-search fa-fw"></i> </button> <search id="search" class="align-items-center ms-3 ms-lg-0"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..." > </search> <button type="button" class="btn btn-link text-decoration-none" id="search-cancel">Cancel</button></div></header><div class="row flex-grow-1"><main aria-label="Main Content" class="col-12 col-lg-11 col-xl-9 px-md-4"><article class="px-1"><header><h1 data-toc-skip>Big-O notation and complexity(big-O 표기법과 복잡도)</h1><div class="post-meta text-muted"> <span> Posted <time data-ts="1724925600" data-df="ll" data-bs-toggle="tooltip" data-bs-placement="bottom" > Aug 29, 2024 </time> </span> <span> Updated <time data-ts="1750779586" data-df="ll" data-bs-toggle="tooltip" data-bs-placement="bottom" > Jun 25, 2025 </time> </span><div class="d-flex justify-content-between"> <span> By <em> <a href="https://www.linkedin.com/in/pour/">KanghoonYi(pour)</a> </em> </span><div> <span class="readtime" data-bs-toggle="tooltip" data-bs-placement="bottom" title="3219 words" > <em>17 min</em> read</span></div></div></div></header><div class="content"><p>디스크에 있는 파일을 다른 지역의 친구에게 보낸다고 해보자. 대부분의 사람이, 이메일이나 FTP와 같은 network방식을 떠올리게됩니다.<br /> 하지만 파일의 크기가 1TB라면? 이럴때는 자동차를 타고 직접 전달하는게 빠르지 않을까?<br /> 이렇게 어떤 행위(컴퓨터에선 알고리즘을 의미)에 대한 비용을 어떻게 비교할까요?<br /> 여기선 컴퓨터에서 효율성을 비교하는 방법을 알아보겠습니다.</p><h2 id="big-o의-의미"><span class="me-2">big-O의 의미</span><a href="#big-o의-의미" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>big-O 시간은 알고리즘의 효율성을 나타내는 지표(metric) 혹은 언어입니다. 이를 통해 알고리즘이 이전보다 빨라졌는지 느려졌는지 판단합니다.</p><h2 id="시간복잡도time-complexity"><span class="me-2">시간복잡도(time complexity)</span><a href="#시간복잡도time-complexity" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><a href="/assets/img/for-post/big-O and Time Complexity/image.png" class="popup img-link shimmer"><img src="/assets/img/for-post/big-O and Time Complexity/image.png" alt="big-O표기법에 따른 그래프" loading="lazy"></a> <em>big-O표기법에 따른 그래프</em></p><p>위의 그래프처럼 다양한 big-O표기가 있습니다.<br /> O(1)(상수의 시간복잡도)가 얼마냐에 따라, 특정 input범위에선, O(1)의 시간복잡도가 더 클 수 있습니다.</p><h3 id="big-o-big-θ-big-ω"><span class="me-2">big-O, big-θ, big-Ω</span><a href="#big-o-big-θ-big-ω" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><p>big-O(big-O)(최악의 경우) 엄밀히 말하면(그리고 학계에선) big-O는 시간의 상한을 나타냅니다. 또 다른 말로, ‘최악의 경우’를 나타냅니다.<br /> 예를 들면, array의 모든 값을 std console(표준 출력, console창)에 출력한다면, O(N)으로 표현할 수 있지만, 이 외에 $O(N^2), O(N^3), O(2^N)$도 옳은 표현입니다.</p><blockquote class="prompt-info"><p>하지만, 업계에선 ‘big-O’를 ‘big-θ’의 의미를 추가하여 사용하고 있습니다. 이 부분이 ‘학계에선’이라고 표현한 이유입니다.</p></blockquote><li><p>big-Ω(big-Omega)(최선의 경우) 학계에선 big-Ω는 최선(best)의 상황에 대한 표기입니다.<br /> 예를 들어, array의 모든 값을 출력하는 상황은 Ω(N) 뿐만 아니라 $\Omega{(\log{N})}$ 혹은 $\Omega{(1)}$로 표현할 수 있습니다.</p><blockquote class="prompt-tip"><p>Q: 위의 array예시(모든 값을 출력하는)에서, $\Omega(\log{N})$, $\Omega{(1)}$이 가능할까?</p><blockquote><p>A: 불가능합니다. 모든 array의 element(구성요소)들을 최소 1회 읽어야 합니다.</p></blockquote></blockquote><li><p>big-θ(big-theta)(딱 맞게 표현하고 싶은 경우)<br /> big-O와 big-Ω 모두를 의미합니다.<br /> 예를 들어, 어떤 알고리즘이 O(N)이면서 Ω(N)이라면, 이 알고리즘을 θ(N)으로 표기할 수 있습니다.</p><blockquote class="prompt-info"><p>최선의 경우(big-Ω)는 별로 쓸만한 개념이 아닌 탓에 논의 대상이 되지 않는다. 아무 알고리즘에 대해서 최선에 해당되는 특수한 input을 넣는다면, O(1)에 동작하도록 만들 수 있다. 대부분의 경우 최악의 경우(big-O)에 관심이 있기 때문에, big-O로 표기하곤 한다.</p></blockquote></ul><h2 id="공간복잡도space-complexity"><span class="me-2">공간복잡도(space complexity)</span><a href="#공간복잡도space-complexity" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>알고리즘의 공간 측면에서의 복잡도 입니다.<br /> 시간복잡도와는 완전히 구분되며, 크기가 n인 배열을 만든다면 O(n)으로, n x n 배열을 만든다면, $O(n^2)$으로 공간복잡도를 표기합니다.</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="c1">// 예제 1</span>
<span class="kt">int</span> <span class="nf">sum</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
	<span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="o">){</span>
		<span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
	<span class="o">}</span>
	<span class="k">return</span> <span class="n">n</span> <span class="o">+</span> <span class="n">sum</span><span class="o">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>
<span class="o">}</span>

<span class="c1">// 예제 2</span>
<span class="kt">int</span> <span class="nf">pairSumSequence</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
	<span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
	<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
		<span class="n">sum</span> <span class="o">+=</span> <span class="n">pairSum</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
	<span class="o">}</span>
	<span class="k">return</span> <span class="n">sum</span><span class="o">;</span>
<span class="o">}</span>

<span class="kt">int</span> <span class="nf">pairSum</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span>
	<span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">;</span>
<span class="o">}</span>

</pre></table></code></div></div><dl><dt>예제 1의 경우<dd>O(n)의 시간복잡도와 O(n)의 공간복잡도를 갖습니다.<dd>공간복잡도가 O(n)인 이유는, function call이 call stack에 n개 쌓이기 때문입니다. 이 function call또한 memory의 공간을 차지합니다.<dd>단순히 function call을 n번했다고, O(n)의 공간을 사용하지는 않습니다.<dt>예제 2의 경우를 보면,<dd>예제 1과 같이 총 n번 호출하지만, 각 function이 모두 종료(이 과정에서 memory free가 발생하기 때문)된 후 실행되므로, O(1)의 공간을 사용한다.</dl><blockquote class="prompt-info"><p>n번 iteration을 수행하기 때문에 O(n)의 공간복잡도를 갖는다고 생각할 수 있지만, n의 증가와 상관없이 상수(constant number)의 공간복잡도(O(1))을 갖기 때문에, O(1)이 맞습니다. <strong>big-O는 단순히 증가하는 비율을 표현합니다</strong></p></blockquote><h2 id="big-o-표기법의-기본적인-규칙들"><span class="me-2">big-O 표기법의 기본적인 규칙들</span><a href="#big-o-표기법의-기본적인-규칙들" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="상수항constant-value는-무시한다"><span class="me-2">상수항(constant value)는 무시한다.</span><a href="#상수항constant-value는-무시한다" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>big-O는 단순히 증가하는 비율을 나타냅니다. 특정 input데이터 안에서 $O(N)$이 $O(1)$보다 작은경우가 있지만(<a href="https://www.notion.so/big-O-af1e9f2ce83b43e0af7b0b8240721d00?pvs=21">참고</a>), ‘증가하는 비율’을 비교하고자 함으로, 상수는 생략하게 됩니다.<br /> 이에 따라, 2개의 연속된 iteration(반복)구문(for, while등) 같은 경우$O(2N)$이 아닌 $O(N)$으로 표기합니다.</p><blockquote class="prompt-info"><p>$O(N)$이 항상 $O(2N)$보다 낫지는 않습니다. 이런일이 발생하는 이유는, 실제로 CPU에 전달되는 명령어(assembly어)가 내부 연산(+,* 등)에 따라 차이가 있기 때문입니다.</p></blockquote><h3 id="지배적이지-않은-항은-무시하라가장-영향력이-큰것만-표시한다"><span class="me-2">지배적이지 않은 항은 무시하라(가장 영향력이 큰것만 표시한다)</span><a href="#지배적이지-않은-항은-무시하라가장-영향력이-큰것만-표시한다" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>$O(N^2+N)$은 $O(N^2)$으로<li>$O(N+\log{N})$은 $O(N)$으로<li>$O(5*2^{N}+1000N^{100})$은 $O(2^N)$으로</ul><p>표기합니다.</p><blockquote class="prompt-info"><p>N의 모수(parameter)가 아예 다른경우($O(B^2+A)$와 같은 경우)는 줄일 수 없습니다.</p></blockquote><p><a href="/assets/img/for-post/big-O and Time Complexity/image%201.png" class="popup img-link shimmer"><img src="/assets/img/for-post/big-O and Time Complexity/image%201.png" alt="big-O의 N크기에 따른 연산차이를 표현한 graph. 그 성능에 따라 horrible~excellent까지 추가로 표기되어 있습니다. 출처: [https://www.bigocheatsheet.com/](https://www.bigocheatsheet.com/)" loading="lazy"></a> <em>big-O의 N크기에 따른 연산차이를 표현한 graph. 그 성능에 따라 horrible~excellent까지 추가로 표기되어 있습니다. 출처: <a href="https://www.bigocheatsheet.com/">https://www.bigocheatsheet.com/</a></em></p><h3 id="여러-단계로-이루어진-알고리즘은-어떻게-표현할까"><span class="me-2">여러 단계로 이루어진 알고리즘은 어떻게 표현할까?</span><a href="#여러-단계로-이루어진-알고리즘은-어떻게-표현할까" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>실제로, 알고리즘은 여러 단계의 연산을 거치게 됩니다. 이럴때 시간 복잡도를 어떻게 표현해야 할까요?</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="c1">// O(A + B)</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="nl">a:</span> <span class="n">arrA</span><span class="o">)</span> <span class="o">{</span>
	<span class="n">print</span><span class="o">(</span><span class="n">a</span><span class="o">);</span>
<span class="o">}</span>

<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="nl">b:</span> <span class="n">arrB</span><span class="o">)</span> <span class="o">{</span>
	<span class="n">print</span><span class="o">(</span><span class="n">b</span><span class="o">)</span>
<span class="o">}</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="c1">// O(A * B)</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">a</span> <span class="o">:</span> <span class="n">arrA</span><span class="o">)</span> <span class="o">{</span>
	<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">b</span> <span class="o">:</span> <span class="n">arrB</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">print</span><span class="o">(</span><span class="n">a</span> <span class="o">+</span> <span class="s">" "</span> <span class="o">+</span> <span class="n">b</span><span class="o">)</span>
	<span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="amortized-timeamortized-analysis-분할-상환-분석"><span class="me-2">Amortized Time(Amortized Analysis, 분할 상환 분석)</span><a href="#amortized-timeamortized-analysis-분할-상환-분석" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>알고리즘이, 상황에 따라 아주 나쁜 시간복잡도를 갖지만, 보통의 경우는 또 다른 시간복잡도를 갖는경우 표현하는 방법에 대해서 알아봅니다.</p><p><strong>Java의 ‘ArrayList’예시</strong></p><p>Java의 ‘ArrayList’는 ‘dynamic size array(동적으로 array크기가 바뀌는)’입니다. 즉, array이지만, 배열의 크기가 자유롭게 조절됩니다.</p><p>‘ArrayList’는 배열의 크기가 가득찼을때,</p><ol><li>기존보다 2배 더 큰 array를 만든뒤<li>이전 array의 모든 요소(element)를 새 array로 copy합니다.</ol><p>이런 spec을 기준으로, <strong>‘ArrayList’의 삽입(insert)연산의 시간복잡도(Time Complexity)는 어떻게 될까?</strong></p><p>2가지 상황으로 나누어서 생각할 수 있습니다</p><dl><dt>array가 꽉찬 경우(배열 요소가 N개인 경우):<dd>새로운 element를 만들기 위해, 2N크기의 array를 생성하고, 기존 array에서 N개의 element를 copy해야 하므로, 이 경우<dd>$O(N)$이 됩니다.<dt>array가 비어있는 경우:<dd>배열에 이미 공간이 있기 때문에,<dd>$O(1)$이 됩니다.</dl><p>이에 따라 최악의 경우인 $O(N)$으로 표기하는게 맞을까요?<br /> 그러나, 최악의 경우(array가 꽉찬경우)에 마주하는 경우는 극히 드물기 때문에, 실제의 시간복잡도를 온전히 반영하고 있지 않습니다.<br /> 이에 따라, <strong>이 최악의 경우($O(N)$인 경우)를 분할해서, 다른 상황에 할당하는 방식으로 계산합니다.</strong></p><p>계속해서 ArrayList의 예시를 이어가면,<br /> ArrayList는 1, 2, 4, 8, 16, …, X처럼 $2^n$크기 일때, 최악의 경우(<strong>$O(N)$</strong>)가 발생한다.<br /> 이때, X개의 element를 삽입한다면, 총 시간복잡도는 $1+2+4+8+16+\dots+X$이 됩니다.<br /> 이를 거꾸로 뒤집어서 생각하면, X부터 $\frac{1}{2}$씩 줄어든다고 볼 수 있습니다. 이를 적용하면,</p>\[X +\frac{X}{2}+\frac{X}{4}+\frac{X}{8}+\dots+1\approx2X\]<p>로, 2X(근사값으로서)가 됩니다.<br /> 이에 따라, X개의 원소를 모두 삽입(insert)할때 필요한 시간은 $O(2X)$이고,<br /> 이를 분할하여, 1회 삽입(insert)에 드는 시간은 $O(1)$입니다.</p><h3 id="logn-runtime"><span class="me-2">$\log{N}$ runtime</span><a href="#logn-runtime" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>많은 알고리즘에서, $\log{N}$의 시간복잡도(time complexity)를 갖고 있습니다. 이 $\log{N}$은 어떻게 구해진걸까요?</p><p><strong>Binary Search Tree(BST, 이진 탐색 트리)</strong></p><p><a href="/assets/img/for-post/big-O and Time Complexity/image%202.png" class="popup img-link shimmer"><img src="/assets/img/for-post/big-O and Time Complexity/image%202.png" alt="binary search tree 예시 출처: [https://en.wikipedia.org/wiki/Binary_search](https://en.wikipedia.org/wiki/Binary_search)" loading="lazy"></a> <em>binary search tree 예시 출처: <a href="https://en.wikipedia.org/wiki/Binary_search">https://en.wikipedia.org/wiki/Binary_search</a></em></p><p>‘Binary Search Tree(BST)’는 특정 element를 찾을때, 그 탐색 대상을 절반($\frac{1}{2}$)씩 줄여나갑니다.<br /> 예를 들어, 탐색 대상(N)이 총 16개인 경우($N = 16$),</p><p>$N=16$(첫번째 탐색대상)</p><p>$N=8$(두번째 탐색대상)</p><p>$N=4$(세번째 탐색대상)</p><p>$N=2$(네번째 탐색대상)</p><p>$N=1$(다섯번째 탐색대상, 찾음)</p><p>로 탐색 대상이 각 단계 마다 $\frac{1}{2}$씩 줄어듭니다. 이를 거꾸로 뒤집으면, 마지막으로 부터 2배씩 증가한다고 볼 수 있습니다.<br /> 이때, ‘탐색 횟수’가 시간복잡도에 해당되며, 이는 $2^{k} = N \text(k는 실행횟수)$를 만족하는 k를 찾는것과 같습니다.</p>\[2^k=N\rightarrow\log_2{N}=k\]<p>이렇게 실행횟수 k는 $\log_2{N}$이 됩니다.</p><blockquote class="prompt-info"><p>이 BST와 같이 알고리즘의 대상이 $\frac{1}{2}$씩 줄어든다면, 해당 알고리즘의 시간복잡도는 $\log{N}$일 가능성이 높습니다.</p></blockquote><blockquote class="prompt-info"><p>big-O표기에서는 상수항은 무시하기 때문에, $\log_2$의 밑에 해당하는 ‘2’는 생략하고 표시합니다. 즉, $\log(N)$으로 표기합니다.</p></blockquote><h3 id="recursive-runtime재귀호출-수행시간"><span class="me-2">Recursive runtime(재귀호출 수행시간)</span><a href="#recursive-runtime재귀호출-수행시간" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Recursive 알고리즘 같은경우, 시간복잡도(time complexity)를 구하기 까다롭습니다.</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">f</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
	<span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
	<span class="o">}</span>
	<span class="k">return</span> <span class="nf">f</span><span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">+</span> <span class="n">f</span><span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
<span class="o">}</span>
</pre></table></code></div></div><p>위와 같은 함수가 있을때, 성급하게 $O(N^2)$라고 할 수 있지만(f가 2회 호출되기 때문에), 이는 잘못된 답입니다.<br /> 이 function을 수행하는 과정을 그려보면, 아래와 같이 tree형식으로 표현할 수 있습니다.<br /> <a href="/assets/img/for-post/big-O and Time Complexity/image%203.png" class="popup img-link shimmer"><img src="/assets/img/for-post/big-O and Time Complexity/image%203.png" alt="image.png" loading="lazy"></a><br /> 이때, function call에 해당하는 ‘Node의 갯수’와 ‘tree의 깊이(depth)’의 관계는 아래와 같이 표현됩니다.</p><div class="table-wrapper"><table><thead><tr><th>깊이(depth)<th>노드의 갯수(function call 횟수)<th>다르게 표현하면<th>또 다른 표현<tbody><tr><td>0<td>1<td> <td>2^0<tr><td>1<td>2<td>2 * 이전 깊이<td>2^1<tr><td>2<td>4<td>2 * 이전 깊이<td>2^2<tr><td>3<td>8<td>2 * 이전 깊이<td>2^3<tr><td>4<td>16<td>2 * 이전 깊이<td>2^4</table></div><p>이렇게 각 layer마다 node의 갯수는 $2^{depth}$가 됩니다.<br /> 시간복잡도(Time complexity)는 이 node갯수의 총 합에 해당하므로,</p>\[2^0+2^1+2^2+2^3+2^4+\dots+2^N(=2^{N+1}-1)\]<p>즉 시간복잡도(Time complexity)는</p>\[O(2^{N})\]<p>이 된다.</p><blockquote class="prompt-info"><p>recursive함수에서, 시간복잡도는 보통 $O(\text{분기 갯수}^{깊이})$로 표현됩니다.</p></blockquote><p>공간복잡도는 $O(N)$인데,<br /> 이는 특정 시각에 사용하고 있는 공간의 크기가 $O(N)$이기 때문입니다.</p><h4 id="recursive-algorithm의-최적화"><span class="me-2">Recursive Algorithm의 최적화</span><a href="#recursive-algorithm의-최적화" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Recursive Algorithm의 경우, 단순히 ‘recursion’만 적용하면, $O(2^{n})$의 Time complexity(시간복잡도)를 갖게 됩니다.</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="k">fn</span> <span class="nf">fibonacci</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">u32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u32</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">n</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nf">fibonacci</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="nf">fibonacci</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
<span class="p">}</span>

</pre></table></code></div></div><p>하지만, fibonacci 처럼, 같은 계산을 중복으로 실행해야하는 경우가 많은 Algorithm은, 이 결과 값을 저장(cache)함으로서 성능을 개선할 수 있습니다.<br /> 이 경우, Time Complexity(시간복잡도)를 $O(n)$으로 줄일 수 있습니다.</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre>
<span class="c1">// 메모이제이션을 적용한 피보나치 함수</span>
<span class="k">fn</span> <span class="nf">fibonacci_memo</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span> <span class="n">memo</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="nb">u32</span><span class="p">,</span> <span class="nb">u32</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u32</span> <span class="p">{</span>
    <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="n">result</span><span class="p">)</span> <span class="o">=</span> <span class="n">memo</span><span class="nf">.get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="p">{</span>
        <span class="n">n</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nf">fibonacci_memo</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">memo</span><span class="p">)</span> <span class="o">+</span> <span class="nf">fibonacci_memo</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">memo</span><span class="p">)</span>
    <span class="p">};</span>

    <span class="n">memo</span><span class="nf">.insert</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
    <span class="n">result</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">memo</span> <span class="o">=</span> <span class="nn">HashMap</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span> <span class="c1">// 계산할 n 값</span>
    <span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="nf">fibonacci_memo</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">memo</span><span class="p">);</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Fibonacci({}) = {}"</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="reference"><span class="me-2">Reference</span><a href="#reference" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><dl><dt><strong>Book</strong><dd><a href="https://www.crackingthecodinginterview.com/">CRACKING the CODING INTERVIEW</a><dt><strong>이미지 출처</strong><dd><a href="https://www.bigocheatsheet.com/">Big-O Algorithm Complexity Cheat Sheet (Know Thy Complexities!) @ericdrowell</a></dl></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw me-1"></i> <a href="/categories/books/">Books</a>, <a href="/categories/cracking-the-coding-interview/">Cracking The Coding Interview</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw me-1"></i> <a href="/tags/computer-science/" class="post-tag no-text-decoration" >Computer Science</a> <a href="/tags/algorithm/" class="post-tag no-text-decoration" >algorithm</a> <a href="/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/" class="post-tag no-text-decoration" >알고리즘</a> <a href="/tags/time-complexity/" class="post-tag no-text-decoration" >Time Complexity</a></div><div class=" post-tail-bottom d-flex justify-content-between align-items-center mt-5 pb-2 " ><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper d-flex align-items-center"> <span class="share-label text-muted">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Big-O%20notation%20and%20complexity(big-O%20%ED%91%9C%EA%B8%B0%EB%B2%95%EA%B3%BC%20%EB%B3%B5%EC%9E%A1%EB%8F%84)%20-%20KanghoonYi(Pour)&url=https%3A%2F%2Fblog.devpour.net%2Fposts%2Fbig-O-and-Time-Complexity%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Twitter" aria-label="Twitter"> <i class="fa-fw fa-brands fa-square-x-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Big-O%20notation%20and%20complexity(big-O%20%ED%91%9C%EA%B8%B0%EB%B2%95%EA%B3%BC%20%EB%B3%B5%EC%9E%A1%EB%8F%84)%20-%20KanghoonYi(Pour)&u=https%3A%2F%2Fblog.devpour.net%2Fposts%2Fbig-O-and-Time-Complexity%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Facebook" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https%3A%2F%2Fblog.devpour.net%2Fposts%2Fbig-O-and-Time-Complexity%2F&text=Big-O%20notation%20and%20complexity(big-O%20%ED%91%9C%EA%B8%B0%EB%B2%95%EA%B3%BC%20%EB%B3%B5%EC%9E%A1%EB%8F%84)%20-%20KanghoonYi(Pour)" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Telegram" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <button id="copy-link" aria-label="Copy link" class="btn small" data-bs-toggle="tooltip" data-bs-placement="top" title="Copy link" data-title-succeed="Link copied successfully!" > <i class="fa-fw fas fa-link pe-none fs-6"></i> </button> </span></div></div></div></article></main><aside aria-label="Panel" id="panel-wrapper" class="col-xl-3 ps-2 mb-5 text-muted"><div class="access"><section id="access-lastmod"><h2 class="panel-heading">Recently Updated</h2><ul class="content list-unstyled ps-0 pb-1 ms-1 mt-2"><li class="text-truncate lh-lg"> <a href="/posts/Redis/">Redis | Key Technologies - System Design Interview</a><li class="text-truncate lh-lg"> <a href="/posts/Consistent-Hashing/">Consistent Hashing | Core Concepts - System Design Interview</a><li class="text-truncate lh-lg"> <a href="/posts/k8s-introduction/">Kubernetes(Orchestration) 개론</a><li class="text-truncate lh-lg"> <a href="/posts/CAP-Theorem/">CAP Theorem(정리) | Core Concepts - System Design Interview</a><li class="text-truncate lh-lg"> <a href="/posts/What-is-CloudNativePG/">What is CloudNativePG? | CloudNative</a></ul></section><section><h2 class="panel-heading">Trending Tags</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/programming/">programming</a> <a class="post-tag btn btn-outline-primary" href="/tags/aws/">aws</a> <a class="post-tag btn btn-outline-primary" href="/tags/leetcode/">leetcode</a> <a class="post-tag btn btn-outline-primary" href="/tags/rust/">rust</a> <a class="post-tag btn btn-outline-primary" href="/tags/computer-science/">Computer Science</a> <a class="post-tag btn btn-outline-primary" href="/tags/cncf/">cncf</a> <a class="post-tag btn btn-outline-primary" href="/tags/k8s/">k8s</a> <a class="post-tag btn btn-outline-primary" href="/tags/kubernetes/">kubernetes</a> <a class="post-tag btn btn-outline-primary" href="/tags/algorithm/">algorithm</a> <a class="post-tag btn btn-outline-primary" href="/tags/architecture/">Architecture</a></div></section></div><section id="toc-wrapper" class="d-none ps-0 pe-4"><h2 class="panel-heading ps-3 mb-2">Contents</h2><nav id="toc"></nav></section></aside></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 px-md-4"><aside id="related-posts" aria-labelledby="related-label"><h3 class="mb-4" id="related-label">Further Reading</h3><nav class="row row-cols-1 row-cols-md-2 row-cols-xl-3 g-4 mb-4"><article class="col"> <a href="/posts/big-O-and-Time-Complexity(Examples)/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1725883276" data-df="ll" > Sep 9, 2024 </time><h4 class="pt-0 my-2">Big-O notation and complexity(big-O 표기법과 복잡도) Examples</h4><div class="text-muted"><p>Overview 몇가지 예시를 통해 big-O표기법에 대해서 이해합니다. 예시 여러개의 문자열을 각각 정렬하고 전체 list에 대해서도 정렬하는 경우 총 N개의 문자열이 있다고 하자, 이때, 각각의 문자열을 알파벳 순으로 정렬하고, 전체 문자열 목록을 사전(Dictionary)순에 따라 정리하는 예시입니다. 이 경우, 문자열 1개를 ...</p></div></div></a></article><article class="col"> <a href="/posts/HashTable-HashMap-HashSet/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1729149180" data-df="ll" > Oct 17, 2024 </time><h4 class="pt-0 my-2">Hash Table, Hash Map, Hash Set</h4><div class="text-muted"><p>Overview Hash를 이용한 자료구조는 Time Complexity를 줄이는데 아주 중요한 역할을 합니다. 여기서는, Hash를 이용한 Data Structure를 소개합니다. 또한, Hash의 Time Complexity는 $O(1)$(insert, delete, search)로 알려져 있는데, 어떻게 이게 가능한지 알아보려 합니다. ...</p></div></div></a></article><article class="col"> <a href="/posts/Consistent-Hashing/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1753809540" data-df="ll" > Jul 30, 2025 </time><h4 class="pt-0 my-2">Consistent Hashing | Core Concepts - System Design Interview</h4><div class="text-muted"><p>‘Consistent Hashing’은 분산 시스템(Distributed System)의 Cluster에서, 데이터를 분산 저장할때 사용하는 기초적인 알고리즘 입니다. 예시로 보는 Consistent Hashing의 필요성 ‘Ticketing System을 구성한다고 해봅시다. Simple System과 Sharding이 적용된 System...</p></div></div></a></article></nav></aside><nav class="post-navigation d-flex justify-content-between" aria-label="Post Navigation"> <a href="/posts/Vector-Similarity-Explained/" class="btn btn-outline-primary" aria-label="Older" ><p>Vector Similarity Explained(Vector의 유사도를 측정하는 방법에 관하여)</p></a> <a href="/posts/Bubble-sort-implementation-with-rust/" class="btn btn-outline-primary" aria-label="Newer" ><p>Bubble sort implementation with rust(rust로 버블정렬 구현)</p></a></nav><script src="https://utteranc.es/client.js" repo="KanghoonYi/kanghoonyi.github.io" issue-term="pathname" crossorigin="anonymous" async ></script> <script type="text/javascript"> (function () { const origin = 'https://utteranc.es'; const lightTheme = 'github-light'; const darkTheme = 'github-dark'; let initTheme = lightTheme; const html = document.documentElement; if ( (html.hasAttribute('data-mode') && html.getAttribute('data-mode') === 'dark') || (!html.hasAttribute('data-mode') && window.matchMedia('(prefers-color-scheme: dark)').matches) ) { initTheme = darkTheme; } addEventListener('message', (event) => { let theme;if (event.origin === origin) {theme = initTheme; } else if (event.source === window && event.data && event.data.direction === ModeToggle.ID) {const mode = event.data.message; theme = mode === ModeToggle.DARK_MODE ? darkTheme : lightTheme; } else { return; } const message = { type: 'set-theme', theme: theme }; const utterances = document.getElementsByClassName('utterances-frame')[0].contentWindow; utterances.postMessage(message, origin); }); })(); </script><footer aria-label="Site Info" class=" d-flex flex-column justify-content-center text-muted flex-lg-row justify-content-lg-between align-items-lg-center pb-lg-3 " ><p>© <time>2025</time> <a href="https://github.com/KanghoonYi">KanghoonYi</a>. <span data-bs-toggle="tooltip" data-bs-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author." >Some rights reserved.</span></p><p>Using the <a data-bs-toggle="tooltip" data-bs-placement="top" title="v7.1.1" href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener" >Chirpy</a> theme for <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a>.</p></footer></div></div><div id="search-result-wrapper" class="d-flex justify-content-center d-none"><div class="col-11 content"><div id="search-hints"><section><h2 class="panel-heading">Trending Tags</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/programming/">programming</a> <a class="post-tag btn btn-outline-primary" href="/tags/aws/">aws</a> <a class="post-tag btn btn-outline-primary" href="/tags/leetcode/">leetcode</a> <a class="post-tag btn btn-outline-primary" href="/tags/rust/">rust</a> <a class="post-tag btn btn-outline-primary" href="/tags/computer-science/">Computer Science</a> <a class="post-tag btn btn-outline-primary" href="/tags/cncf/">cncf</a> <a class="post-tag btn btn-outline-primary" href="/tags/k8s/">k8s</a> <a class="post-tag btn btn-outline-primary" href="/tags/kubernetes/">kubernetes</a> <a class="post-tag btn btn-outline-primary" href="/tags/algorithm/">algorithm</a> <a class="post-tag btn btn-outline-primary" href="/tags/architecture/">Architecture</a></div></section></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><aside aria-label="Scroll to Top"> <button id="back-to-top" type="button" class="btn btn-lg btn-box-shadow"> <i class="fas fa-angle-up"></i> </button></aside></div><div id="mask"></div><script src="https://cdn.jsdelivr.net/combine/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js,npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.umd.min.js,npm/glightbox@3.3.0/dist/js/glightbox.min.js,npm/clipboard@2.0.11/dist/clipboard.min.js,npm/dayjs@1.11.13/dayjs.min.js,npm/dayjs@1.11.13/locale/en.js,npm/dayjs@1.11.13/plugin/relativeTime.js,npm/dayjs@1.11.13/plugin/localizedFormat.js,npm/tocbot@4.29.0/dist/tocbot.min.js"></script> <script src="/assets/js/dist/post.min.js"></script> <script src="/assets/js/data/mathjax.js"></script> <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script> <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-chtml.js"></script> <script>SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<article class="px-1 px-sm-2 px-lg-4 px-xl-0"><header><h2><a href="{url}">{title}</a></h2><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div></header><p>{snippet}</p></article>', noResultsText: '<p class="mt-5">Oops! No results found.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="me-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
