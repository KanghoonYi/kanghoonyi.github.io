<!doctype html><html lang="ko" data-mode="light"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" ><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="Chapter 1- Reliable, Scalable, and Maintainable Applications" /><meta name="author" content="KanghoonYi(pour)" /><meta property="og:locale" content="ko" /><meta name="description" content="이 1장에서는 책 전반에서 사용하는 전문 용어(terminology)와 접근 방식(approach)을 소개합니다. 신뢰성(reliability), 확장성(scalability), 유지보수성(maintainability) 같은 단어의 실제 의미와 목표를 당설하기 위해 어떻게 해야하는지 알아봅니다." /><meta property="og:description" content="이 1장에서는 책 전반에서 사용하는 전문 용어(terminology)와 접근 방식(approach)을 소개합니다. 신뢰성(reliability), 확장성(scalability), 유지보수성(maintainability) 같은 단어의 실제 의미와 목표를 당설하기 위해 어떻게 해야하는지 알아봅니다." /><link rel="canonical" href="https://blog.devpour.net/posts/Reliable,-Scalable-and-Maintainable-Applications/" /><meta property="og:url" content="https://blog.devpour.net/posts/Reliable,-Scalable-and-Maintainable-Applications/" /><meta property="og:site_name" content="KanghoonYi(Pour)" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2024-09-16T23:51:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Chapter 1- Reliable, Scalable, and Maintainable Applications" /><meta name="google-site-verification" content="rsx_-5MJzSR_3NNCqHNe9IxnKJxlD8Eid8_wN8e9c1I" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"KanghoonYi(pour)","url":"https://www.linkedin.com/in/pour/"},"dateModified":"2025-06-25T00:39:46+09:00","datePublished":"2024-09-16T23:51:00+09:00","description":"이 1장에서는 책 전반에서 사용하는 전문 용어(terminology)와 접근 방식(approach)을 소개합니다. 신뢰성(reliability), 확장성(scalability), 유지보수성(maintainability) 같은 단어의 실제 의미와 목표를 당설하기 위해 어떻게 해야하는지 알아봅니다.","headline":"Chapter 1- Reliable, Scalable, and Maintainable Applications","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.devpour.net/posts/Reliable,-Scalable-and-Maintainable-Applications/"},"url":"https://blog.devpour.net/posts/Reliable,-Scalable-and-Maintainable-Applications/"}</script><title>Chapter 1- Reliable, Scalable, and Maintainable Applications | KanghoonYi(Pour)</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="KanghoonYi(Pour)"><meta name="application-name" content="KanghoonYi(Pour)"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="/assets/css/jekyll-theme-chirpy.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.6.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.29.0/dist/tocbot.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/glightbox@3.3.0/dist/css/glightbox.min.css"><body><aside aria-label="Sidebar" id="sidebar" class="d-flex flex-column align-items-end"><header class="profile-wrapper"> <a href="/" id="avatar" class="rounded-circle"><img src="/assets/img/pour_profile_img.png" width="112" height="112" alt="avatar" onerror="this.style.display='none'"></a><h1 class="site-title"> <a href="/">KanghoonYi(Pour)</a></h1><p class="site-subtitle fst-italic mb-0">안녕하세요~ Software Engineer pour입니다 This is Pour.</p></header><nav class="flex-column flex-grow-1 w-100 ps-0"><ul class="nav"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle"></i> <span>ABOUT</span> </a></ul></nav><div class="sidebar-bottom d-flex flex-wrap align-items-center w-100"> <a href="https://github.com/KanghoonYi" aria-label="github" target="_blank" rel="noopener noreferrer" > <i class="fab fa-github"></i> </a> <a href="https://twitter.com/" aria-label="twitter" target="_blank" rel="noopener noreferrer" > <i class="fa-brands fa-x-twitter"></i> </a> <a href="javascript:location.href = 'mailto:' + ['rkdgnsdls','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></aside><div id="main-wrapper" class="d-flex justify-content-center"><div class="container d-flex flex-column px-xxl-5"><header id="topbar-wrapper" aria-label="Top Bar"><div id="topbar" class="d-flex align-items-center justify-content-between px-lg-3 h-100" ><nav id="breadcrumb" aria-label="Breadcrumb"> <span> <a href="/">Home</a> </span> <span>Chapter 1- Reliable, Scalable, and Maintainable Applications</span></nav><button type="button" id="sidebar-trigger" class="btn btn-link"> <i class="fas fa-bars fa-fw"></i> </button><div id="topbar-title"> Post</div><button type="button" id="search-trigger" class="btn btn-link"> <i class="fas fa-search fa-fw"></i> </button> <search id="search" class="align-items-center ms-3 ms-lg-0"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..." > </search> <button type="button" class="btn btn-link text-decoration-none" id="search-cancel">Cancel</button></div></header><div class="row flex-grow-1"><main aria-label="Main Content" class="col-12 col-lg-11 col-xl-9 px-md-4"><article class="px-1"><header><h1 data-toc-skip>Chapter 1- Reliable, Scalable, and Maintainable Applications</h1><div class="post-meta text-muted"> <span> Posted <time data-ts="1726498260" data-df="ll" data-bs-toggle="tooltip" data-bs-placement="bottom" > Sep 16, 2024 </time> </span> <span> Updated <time data-ts="1750779586" data-df="ll" data-bs-toggle="tooltip" data-bs-placement="bottom" > Jun 25, 2025 </time> </span><div class="d-flex justify-content-between"> <span> By <em> <a href="https://www.linkedin.com/in/pour/">KanghoonYi(pour)</a> </em> </span><div> <span class="readtime" data-bs-toggle="tooltip" data-bs-placement="bottom" title="4732 words" > <em>26 min</em> read</span></div></div></div></header><div class="content"><p>이 1장에서는 책 전반에서 사용하는 전문 용어(terminology)와 접근 방식(approach)을 소개합니다.<br /> 신뢰성(reliability), 확장성(scalability), 유지보수성(maintainability) 같은 단어의 실제 의미와 목표를 당설하기 위해 어떻게 해야하는지 알아봅니다.</p><h2 id="reliability신뢰성"><span class="me-2">Reliability(신뢰성)</span><a href="#reliability신뢰성" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>소프트웨어에 대한 Reliability에 대한 기대치는 다음과 같습니다.</p><ul><li><p>The application performs the function that the user expected.<br /> 어플리케이션은 사용자가 기대한 기능을 수행한다.</p><li><p>It can tolerate the user making mistakes or using the software in unexpected ways.<br /> 시스템은 사용자가 범한 실수나 예상치 못한 소프트웨어 사용법을 허용할 수 있다.</p><li><p>Its performance is good enough for the required use case, under the expected load and data volume.<br /> 시스템 성능은 예상된 부하와 데이터 양에서 필수적인 사용 사례를 충분히 만족한다.</p><li><p>The system prevents any unauthorized access and abuse.<br /> 시스템은 허가되지 않은 접근과 오남용을 방지한다.</p></ul><h3 id="fault-tolerant내결함성-or-resilient탄력성"><span class="me-2">Fault-tolerant(내결함성) or Resilient(탄력성)</span><a href="#fault-tolerant내결함성-or-resilient탄력성" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Fault(결함)은 ‘잘못 될 수 있는 일’을 말합니다. 이 fault를 대처할 수 있는 시스템을 <strong>‘Fault-tolerant(내결함성)’ 또는 ‘Resilient(탄력성)’을 지녔다고 말합니다</strong>.<br /> ‘Fault-tolerant’가 모든 결함을 견딜 수 있는 시스템을 의미하긴 하지만 실현가능하진 않습니다.(자연재해 같은 통제 불가능한 경우가 있습니다) 그래서 ‘특정 유형’에 대해서만 내성이 있는것으로 여깁니다.</p><h4 id="fault와-failure"><span class="me-2">Fault와 Failure</span><a href="#fault와-failure" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>‘Fault’와 ‘Failure’는 동일하지 않습니다. ‘Fault’는 시스템의 한 구성요소(Composite)으로 여겨지지만, ‘Failure’는 사용자에게 서비스를 제공하지 못하고 시스템이 멈춘것을 의미합니다.</p><h3 id="fault-tolerant를-증가시키는-방법"><span class="me-2">Fault-tolerant를 증가시키는 방법</span><a href="#fault-tolerant를-증가시키는-방법" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>고의적으로 결함을 유도함으로써 Fault-tolerant(내결함성) 시스템을 지속적으로 훈련합니다.<br /> Netflix의 <a href="https://github.com/netflix/chaosmonkey">Chaos Monkey</a>가 이런 접근 방식을 사용하고 있습니다.</p><blockquote class="prompt-tip"><p>Netfilx의 <a href="https://github.com/netflix/chaosmonkey">Chaos Monkey</a>는 (<a href="https://netflixtechblog.com/the-netflix-simian-army-16e57fbab116">Blog글</a>에 따르면), AWS의 Production환경의 instance를 무작위로 마비시킨다고 합니다. 이를 통해 엔지니어들은 더 나은 ‘자동 복구’를 구축하도록 노력한다고 합니다.</p></blockquote><p>보통은 결함을 예방하는것을 넘어서서 Fault-tolerant(내결함성)을 원하지만, 해결책이 없는경우와 같이 예방하는것이 더 나은 경우가 있습니다. 대표적으로 ‘Security(보안)’ 문제 입니다.</p><h3 id="hardware-faults"><span class="me-2">Hardware Faults</span><a href="#hardware-faults" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>하드웨어 장치로부터 기인한 ‘fault’ 유형입니다. 무작의적이고 서로 독립적인 특징이 있습니다.<br /> 최근까지 ‘single machine’(1개의 장비로 운영되는 시스템)의 전체 장애는 매우 드물었기 때문에, 하드웨어를 중복으로 준비하는걸로 충분히 대응할 수 있었습니다.<br /> 하지만, 데이터의 양과 어플리케이션에 대한 의존성이 늘어나면서 더 많은 수의 장비를 사용하게 되었고, 하드웨어 결함율도 비례하여 증가하였습니다. 또한 AWS와 같은 Public Cloud에서 instance가 별도의 경고없이 사용중지되는 경우도 있습니다.<br /> 따라서, 소프트웨어도 ‘fault-tolerant’를 사용하는 시스템으로 옮겨가고 있습니다.</p><h3 id="software-errors"><span class="me-2">Software Errors</span><a href="#software-errors" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Software에서 기이한 ‘fault’ 유형입니다. 예상하기 어렵고, 노드간에 상관간계가 있어, ‘hardware faults’보다 더 자주 system error를 발생시킵니다.<br /> Software Errors의 예시는 다음과 같습니다.</p><ul><li><p>A software bug that causes every instance of an application server to crash when given a particular bad input. For example, consider the leap second on June 30, 2012, that caused many applications to hang simultaneously due to a bug in the Linux kernel.<br /> <a href="https://www.cnet.com/tech/computing/its-time-to-ditch-the-leap-second-the-devastating-effect-of-adding-just-one-second/">It’s Time to Ditch the Leap Second: The Devastating Effect of Adding Just 1 Second</a><br /> <a href="https://www.theguardian.com/technology/2012/jul/02/leap-second-amadeus-qantas-reddit">Leap second hits Qantas air bookings, while Reddit and Mozilla stutter</a></p><li>A runaway process that uses up some shared resource—CPU time, memory, disk space, or network bandwidth.<li>A service that the system depends on that slows down, becomes unresponsive, or starts returning corrupted responses.<li>Cascading failures, where a small fault in one component triggers a fault in another component, which in turn triggers further faults [10].</ul><p>이런 bug는 특정 상황에 마주하기 전까지 오랫동안 나타나지 않을 수 있습니다.<br /> ‘Software Errors’에는 신속한 해결책이 없으며, 아래의 것들이 해결에 도움을 줍니다.</p><ul><li>carefully thinking about assumptions and interactions in the system<li>thorough testing<li>process isolation<li>allowing processes to crash and restart<li>measuring, monitoring, and analyzing system behavior in production</ul><h3 id="human-errors"><span class="me-2">Human Errors</span><a href="#human-errors" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>사람에 기인한 ‘fault’유형입니다. 사람이 최선의 의도를 갖고 있다해도, 미덥지 않다고 알려져 있습니다. <a href="https://www.usenix.org/conference/usits-03/why-do-internet-services-fail-and-what-can-be-done-about-it">대규모 인터넷 서비스에 대한 연구</a>에 따르면, 운영자의 설정 오류가 중단의 주요 원인이라고 합니다.<br /> 그럼에도 시스템의 ‘Reliability’를 어떻게 챙길까요?</p><ul><li><p>Design systems in a way that minimizes opportunities for error. For example, well-designed abstractions, APIs, and admin interfaces make it easy to do “the right thing” and discourage “the wrong thing.” However, if the interfaces are too restrictive people will work around them, negating their benefit, so this is a tricky balance to get right.<br /> 잘 디자인된 ‘abstraction(추상화)’는 ‘정상적인 일’은 쉽게하고, ‘잘못된 일’은 어렵게 합니다.</p><li><p>Decouple the places where people make the most mistakes from the places where they can cause failures. In particular, provide fully featured non-production <em>sandbox</em> environments where people can explore and experiment safely, using real data, without affecting real users.<br /> 사람이 실수할 수 있는 부분을 decouple(분리)시킵니다. 실제 데이터를 활용한 ‘sandbox’환경을 제공해야 합니다.</p><li>Test thoroughly at all levels, from unit tests to whole-system integration tests and manual tests. Automated testing is widely used, well understood, and espe‐ cially valuable for covering corner cases that rarely arise in normal operation.<li>Allow quick and easy recovery from human errors, to minimize the impact in the case of a failure. For example, make it fast to roll back configuration changes, roll out new code gradually (so that any unexpected bugs affect only a small subset of users), and provide tools to recompute data (in case it turns out that the old com‐ putation was incorrect).<li>Set up detailed and clear monitoring, such as performance metrics and error rates. In other engineering disciplines this is referred to as <em>telemetry</em>. (Once a rocket has left the ground, telemetry is essential for tracking what is happening, and for understanding failures [14].) Monitoring can show us early warning sig‐ nals and allow us to check whether any assumptions or constraints are being vio‐ lated. When a problem occurs, metrics can be invaluable in diagnosing the issue.<li>Implement good management practices and training—a complex and important aspect, and beyond the scope of this book.</ul><h2 id="scalability확장성"><span class="me-2">Scalability(확장성)</span><a href="#scalability확장성" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>‘Scalability’는 증가한 부하에 대처하는 ‘시스템 능력’을 설명하는데 사용됩니다.</p><h3 id="describing-load부하-기술하기"><span class="me-2"><strong>Describing Load(부하 기술하기)</strong></span><a href="#describing-load부하-기술하기" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>시스템의 현재 ‘Load(부하)’를 간결한게 기술해야합니다. 이는 부하 성장 질문(”부하가 두 배로 되면 어떻게 될까?”)을 논의할 수 있게 합니다.<br /> ‘Load’를 설명하는 ‘Load parameter’는 시스템 구조에 따라 달라집니다. 이 구조에 따라,<br /> requests per second to a web server, the ratio of reads to writes in a database, the number of simultaneously active users in a chat room, the hit rate on a cache, or something else<br /> 과 같은 값이 parameter가 될 수 있습니다.</p><h4 id="twitter트위터-예시from-timelines-at-scale"><span class="me-2">Twitter(트위터) 예시(from <a href="https://www.infoq.com/presentations/Twitter-Timeline-Scalability/">Timelines at Scale</a>)</span><a href="#twitter트위터-예시from-timelines-at-scale" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>트위터의 주요 동작은 다음과 같습니다.</p><ul><li><p>Tweet(트윗) 작성<br /> 사용자는 새로운 메세지를 개시할 수 있습니다.(평균 초당 4.6k요청, 피크(peak)일 때 초당 12k 요청 이상)</p><li><p>Timeline(홈 화면의 타임라인)<br /> 사용자는 팔로우한 사람의 tweet을 볼 수 있습니다.(초당 300k요청)</p></ul><p>write 작업에 해당하는 ‘tweet작성’이 12k인건 다루기가 상당히 쉽습니다.<br /> 하지만, 트위터의 확장성 문제는 ‘fan-out’에 있습니다. 이 ‘fan-out’은 1개의 tweet을 여러 팔로어들에게 노출해야하는 요구사항 때문에 생깁니다.</p><blockquote class="prompt-tip"><p>‘fan-out’은 입력(input)을 여러개의 출력(output)으로 확장하는것을 말합니다. 즉 1개의 신호를 여러 machine에서 처리할 수 있게 확장하는것을 말합니다. fan-out의 output(출력)은 다른 기능의 input(입력)이 됩니다.</p></blockquote><p><a href="/assets/img/for-post/DDIA-part1-chapter1/image.png" class="popup img-link shimmer"><img src="/assets/img/for-post/DDIA-part1-chapter1/image.png" alt="image.png" loading="lazy"></a> <em>Twitter의 Timeline기능 예시</em></p><p>이를 해결하기 위해서,</p><dl><dt>관계형 데이터베이스를 이용하고, query를 통해 구현하는 방법이 있습니다.<dd>tweet이 등록되면, 전역 tweet collection에 등록하고, 필요에 따라 다음 query예시와 같이 팔로우중인 유저의 tweet을 불러옵니다.</dl><div class="language-sql highlighter-rouge"><div class="code-header"> <span data-label-text="Sql"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="k">SELECT</span> <span class="n">tweets</span><span class="p">.</span><span class="o">*</span><span class="p">,</span> <span class="n">users</span><span class="p">.</span><span class="o">*</span>
<span class="k">FROM</span> <span class="n">tweets</span> <span class="k">JOIN</span> <span class="n">users</span> <span class="k">ON</span> <span class="n">tweets</span><span class="p">.</span><span class="n">sender_id</span> <span class="o">=</span> <span class="n">users</span><span class="p">.</span><span class="n">id</span> <span class="k">JOIN</span> <span class="n">follows</span> <span class="k">ON</span> <span class="n">follows</span><span class="p">.</span><span class="n">followee_id</span> <span class="o">=</span> <span class="n">users</span><span class="p">.</span><span class="n">id</span>
<span class="k">WHERE</span> <span class="n">follows</span><span class="p">.</span><span class="n">follower_id</span> <span class="o">=</span> <span class="k">current_user</span>
</pre></table></code></div></div><dl><dt>혹은, 각 사용자들의 Timeline의 cache를 만들고 유지하며, 이 cache에 새로운 tweet을 추가하는식으로 구현합니다.<dd>이렇게하면, 각 유저의 Timeline에 대한 read요청은 이미 결과값이 계산되어(cache되어) 있기 때문에, 그 비용이 매우 저렴합니다.<br /> <a href="/assets/img/for-post/DDIA-part1-chapter1/image%201.png" class="popup img-link shimmer"><img src="/assets/img/for-post/DDIA-part1-chapter1/image%201.png" alt="Tweeter Timeline 구조 from ‘[Timelines at Scale](https://www.infoq.com/presentations/Twitter-Timeline-Scalability/)’" loading="lazy"></a> <em>Tweeter Timeline 구조 from ‘<a href="https://www.infoq.com/presentations/Twitter-Timeline-Scalability/">Timelines at Scale</a>’</em> <a href="/assets/img/for-post/DDIA-part1-chapter1/image%202.png" class="popup img-link shimmer"><img src="/assets/img/for-post/DDIA-part1-chapter1/image%202.png" alt="*Twitter’s data pipeline for delivering tweets to followers, with load parameters as of November 2012*" loading="lazy"></a> <em>*Twitter’s data pipeline for delivering tweets to followers, with load parameters as of November 2012*</em></dl><p>위의 접근방식중 두번째(cache를 이용한 방법)의 불리한점은 ‘트윗 작성’이 많은 부가 작업(여러 cache에 write해야하는것)을 필요로하게 된다는점 입니다. 이는 follow숫자가 많은 경우 치명적이게 되는데, 그래서 이 ‘follower 숫자’가 핵심적인 ‘Load parameter’가 됩니다.</p><blockquote class="prompt-info"><p>트위터는 5초 이내에 팔로워들에게 tweet을 전송하기위해 노력한다고 합니다.</p></blockquote><p>트위터에서는 최종적으로, 두번째 구현방식을 기반으로, 팔로워가 매우 많은 소수 유저의 경우 이 방식에서 제외시키고, 첫번째 접근방식과 유사하게 작동한다고 합니다.</p><h3 id="describing-performance성능-기술하기"><span class="me-2"><strong>Describing Performance(성능 기술하기)</strong></span><a href="#describing-performance성능-기술하기" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>일단 ‘System load’를 묘사하고나면, Load가 증가할 때, 어떤일이 일어나는지 다음 2가지 방법으로 살펴볼 수 있습니다.</p><ul><li><p>When you increase a load parameter and keep the system resources (CPU, mem‐ ory, network bandwidth, etc.) unchanged, how is the performance of your system affected?<br /> Load parameter가 증가했을때, scale-up(cpu, 메모리, 네트워크 대여폭을 증가)하지 않고 유지하면 시스템 성능이 어떻게 변화할까?</p><li><p>When you increase a load parameter, how much do you need to increase the resources if you want to keep performance unchanged?<br /> Load paramter가 증가했을때, 성능이 유지되길 원한다면, 자원을 얼마나 늘려야 할까?</p></ul><p>이 질문들이 가능해지려면, ‘Performance number(성능 수치)’가 필요합니다.<br /> Hadoop 같은 ‘batch processing system(일괄 처리 시스템)’은 thoughput(처리량)을 중요하게 생각하는 반면, 온라인 시스템은 ‘resposne time(응답시간)’을 중요하게 생각합니다.</p><blockquote class="prompt-tip"><p>‘latency(지연시간)’와 ‘response time(응답시간)’의 차이<br /> ’response time’은 Client의 관점에서 본 시간으로, 요청을 처리하는 실제 시간외에도 네트워크 지연, 큐 지연도 함하고 있습니다. 반면, ‘latency’는 요청이 처리되길 기다리는 시간입니다.</p></blockquote><p>‘Response time(응답시간)’의 경우, 같은 요청이라도 매 요청마다 달라집니다. 이는 여려가지 요인이 있지만, 이 ‘Response time’을 사용할때는 그 값의 ‘<strong>distribution(분포)</strong>’로 봐야합니다.</p><p>이 ‘distribution(분포)’를 볼때, ‘arithmetic mean(산술 평균)’본다 ‘percentile(백분위)’을 사용하는게 좋습니다. ‘percentile’의 종류는 다음과 같습니다.</p><dl><dt>p50<dd>특정 범위안에서 값을 정렬하고, 50%에 위치하는 값을 가리킵니다.<dd>사용자가 보통 얼마나 오래 기다리는지 확인할때 사용합니다.<dt>p95, p99, p999<dd>‘higher percentiles(상위 백분위)’ 혹은 ‘tail latency(꼬리 지연 시간)’으로 불립니다.<dd>특이값(outliers)이 얼마나 안 좋은지 볼때 사용합니다.</dl><p>이러한 ‘Percentile(백분위)’은 ‘Service level objective(SLO, 서비스 수준 목표)’와 ‘Service level agreement(SLA, 서비스 수준 협약서)’에서 자주 사용합니다.<br /> 예를 들어,</p><blockquote><p>the service is considered to be up if it has a median response time of less than 200 ms and a 99th percentile under 1 s (if the response time is longer, it might as well be down), and the service may be required to be up at least 99.9% of the time.</p></blockquote><p>이런식으로 사용되곤 합니다.</p><p><strong>Tail latency amplification(꼬리 지연 증폭)</strong></p><p>end-user(최종 사용자)에게 요청 일부가 여러 백엔드 요청으로 이루어져 있다면, ‘p95, p99’와 같은 ‘higher percentiles’가 중요합니다. 각 요청을 병렬처리하고 있다고 하더라도, 모든 작업이 완료되는건 가장 느린 요청이 완료되어야 합니다. 이 때문에, 최종 ‘response time(응답 시간)’이 느려지는데, 이를 ‘tail latency amplification(꼬리 지연 증폭)’이라고 합니다.</p><p><a href="/assets/img/for-post/DDIA-part1-chapter1/image%203.png" class="popup img-link shimmer"><img src="/assets/img/for-post/DDIA-part1-chapter1/image%203.png" alt="image.png" loading="lazy"></a></p><h3 id="approaches-for-coping-with-load부하-대응-접근-방식"><span class="me-2"><strong>Approaches for Coping with Load(부하 대응 접근 방식)</strong></span><a href="#approaches-for-coping-with-load부하-대응-접근-방식" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>시스템의 성능을 측정하기 위한 ‘Load(부하)’와 ‘Metric(지표)’를 정했으니, 확장성을 논의할 수 있습니다.<br /> ‘Load parameter(부하 변수)’가 어느정도 증가하더라도 성능을 좋게 유지하려면 어떻게 해야 할까요?</p><dl><dt>Scaling up(용량 확장, 수직확장)<dd>더 고사양의 장비로 이동합니다<dt>Scaling out(규모 확장, 수평확장)<dd>다수의 낮은 사양의 장비로 확장하여 Load(부하)를 분산시킵니다. 이런 Architecture를 ‘shared-nothing’ 이라고 합니다.</dl><p>Stateless(상태를 저장하지 않음, 각 장비가 독립적으로 기능을 수행) 서비스를 ‘scale out’하는건 간단하지만, ‘stateful’ 데이터 시스템을 분산 설치하는건 아주 많은 복잡도가 발생되는 일입니다.<br /> 그래서, ‘High-availability(고가용성)’에 대한 요구사항이 생기기 전까지는 단일 노드에 데이터베이스를 유지하는것이 최근까지의 통념입니다.</p><p class="prompt-info">저자는 최근에는 분산 시스템을 위한 도구와 추상화가 좋아지면서, ‘Distributed data systems(분산 데이터 시스템)’이 기본으로 자리잡을 수 있다고 설명하고 있습니다.</p><p>모든 상황에 맞는 확장 아키텍쳐(magic scaling source라 불리는)는 없습니다.<br /> 특정 Application의 주요 동작과 잘 하는 동작이 무엇인지 대한 가정을 기반으로, 확장성을 갖춘 architecture를 설계합니다.</p><h2 id="maintainability유지보수성"><span class="me-2">Maintainability(유지보수성)</span><a href="#maintainability유지보수성" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>소프트웨어의 비용은 대부분 초기 개발이 아니라, 이어지는 유지보수가 큰 부분을 차지한다고 합니다.<br /> 많은 엔지니어들이 소위 ‘legacy’ 시스템을 유지보수하는것을 선호하지 않습니다. 이는 유지보수 과정의 많은 ‘고통’이 동반되기 때문입니다.<br /> 다행이도, 소프트웨어 설계과정에서 이 ‘고통’을 고려하여 설계함으로서 최소화 할 수 있습니다.</p><dl><dt>Operability(운용성)<dd>Make it easy for operations teams to keep the system running smoothly.<dd>운영하기 쉽게 만들어라<dt>Simplicity(단순성)<dd>Make it easy for new engineers to understand the system, by removing as much complexity as possible from the system. (Note this is not the same as simplicity of the user interface.)<dd>복잡도를 최대한 제거하여 새로운 엔지니어가 이해하기 쉽게 만들어라.<dt>Evolvability(발전성)<dd>Make it easy for engineers to make changes to the system in the future, adapting it for unanticipated use cases as requirements change. Also known as <em>extensibility</em>, <em>modifiability</em>, or <em>plasticity</em>.<dd>엔지니어가 시스템을 쉽게 변경할 수 있게 해야한다.</dl><h3 id="operability운용성"><span class="me-2">Operability(운용성)</span><a href="#operability운용성" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>‘좋은 운용성’이란 동일하게 반복되는 task를 쉽게 수행하게끔 만들어, 운영팀이 고부가가치 활동에 노력을 집중하게 한다는 의미입니다. 이를 위해, 아래와 같은 일을 할 수 있습니다.</p><ul><li>Providing visibility into the runtime behavior and internals of the system, with good monitoring<li>Providing good support for automation and integration with standard tools<li>Avoiding dependency on individual machines (allowing machines to be taken down for maintenance while the system as a whole continues running uninter‐ rupted)<li>Providing good documentation and an easy-to-understand operational model (“If I do X, Y will happen”)<li>Providing good default behavior, but also giving administrators the freedom to override defaults when needed<li>Self-healing where appropriate, but also giving administrators manual control over the system state when needed<li>Exhibiting predictable behavior, minimizing surprises</ul><h3 id="simplicity단순성"><span class="me-2">Simplicity(단순성)</span><a href="#simplicity단순성" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>프로젝트가 커짐에 따라서, 시스템은 매우 복잡하고 이해하기 어려워집니다. Complexity(복잡도)는 같은 시스템에서 작업하는 사람들의 진행을 느리게하고, 유지보수 비용을 증가시키는 원인이 됩니다.<br /> 이 Complexity(복잡도)는 다양한 증상으로 나타납니다.<br /> ‘explosion of the state space’, ‘tight coupling of modules’, ‘tangled dependencies’, ‘inconsistent naming and terminology’, ‘hacks aimed at solving performance problems’, ‘special-casing to work around issues elsewhere’등이 있습니다.<br /> 때문에, Simplicity(단순성)이 시스템의 핵심 목표여야 합니다. 또한 Simplicity(단순성)이 기능을 줄인다는 의미는 아닙니다.<br /> Moseley와 Marks는 ‘<a href="https://curtclifton.net/papers/MoseleyMarks06a.pdf">Out of the Tar pit</a>’에서 ‘accidental complexity(우발적 복잡도)’를 설명하며, 이를 end-user에게 보이는 문제에 있는게 아니라, ‘구현’단에서만 발생하는것으로 정의하고 있습니다.</p><h3 id="evolvability발전성"><span class="me-2">Evolvability(발전성)</span><a href="#evolvability발전성" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>시스템의 요구사항이 바뀌지 않을 가능성은 매우 적습니다.<br /> 이 책에서는 Agile기법이 적용되는 소프트웨어 보다는, 다양한 application이나 다른 특성을 가진 서비스로 구성된 ‘larger data system(대규모 데이터 시스템)’수준에서 민첩성을 높이는 방법을 찾습니다.<br /> 이를 위해선, 시스템의 ‘Simplicity(단순성)’과 ‘Abstraction(추상화)’가 매우 중요합니다.</p><h2 id="references"><span class="me-2">References</span><a href="#references" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><dl><dt>Netfilx의 Chaos Monkey와 관련된 Blog글<dd><a href="https://netflixtechblog.com/the-netflix-simian-army-16e57fbab116">The Netflix Simian Army</a><dt>Why Do Internet Services Fail, and What Can Be Done About It?<dd><div class="table-wrapper"><table><tbody><tr><td>[Why Do Internet Services Fail, and What Can Be Done About It?<td>USENIX](https://www.usenix.org/conference/usits-03/why-do-internet-services-fail-and-what-can-be-done-about-it)</table></div><dt>Tweeter의 ‘Timelines at scale’<dd><a href="https://www.infoq.com/presentations/Twitter-Timeline-Scalability/">Timelines at Scale</a></dl></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw me-1"></i> <a href="/categories/books/">Books</a>, <a href="/categories/designing-data-intensive-applications/">Designing Data-Intensive Applications</a>, <a href="/categories/part-1-foundation-of-data-systems/">PART 1- Foundation of Data Systems</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw me-1"></i> <a href="/tags/computer-science/" class="post-tag no-text-decoration" >Computer Science</a> <a href="/tags/architecture/" class="post-tag no-text-decoration" >Architecture</a></div><div class=" post-tail-bottom d-flex justify-content-between align-items-center mt-5 pb-2 " ><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper d-flex align-items-center"> <span class="share-label text-muted">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Chapter%201-%20Reliable,%20Scalable,%20and%20Maintainable%20Applications%20-%20KanghoonYi(Pour)&url=https%3A%2F%2Fblog.devpour.net%2Fposts%2FReliable%2C-Scalable-and-Maintainable-Applications%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Twitter" aria-label="Twitter"> <i class="fa-fw fa-brands fa-square-x-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Chapter%201-%20Reliable,%20Scalable,%20and%20Maintainable%20Applications%20-%20KanghoonYi(Pour)&u=https%3A%2F%2Fblog.devpour.net%2Fposts%2FReliable%2C-Scalable-and-Maintainable-Applications%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Facebook" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https%3A%2F%2Fblog.devpour.net%2Fposts%2FReliable%2C-Scalable-and-Maintainable-Applications%2F&text=Chapter%201-%20Reliable,%20Scalable,%20and%20Maintainable%20Applications%20-%20KanghoonYi(Pour)" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Telegram" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <button id="copy-link" aria-label="Copy link" class="btn small" data-bs-toggle="tooltip" data-bs-placement="top" title="Copy link" data-title-succeed="Link copied successfully!" > <i class="fa-fw fas fa-link pe-none fs-6"></i> </button> </span></div></div></div></article></main><aside aria-label="Panel" id="panel-wrapper" class="col-xl-3 ps-2 mb-5 text-muted"><div class="access"><section id="access-lastmod"><h2 class="panel-heading">Recently Updated</h2><ul class="content list-unstyled ps-0 pb-1 ms-1 mt-2"><li class="text-truncate lh-lg"> <a href="/posts/Redis/">Redis | Key Technologies - System Design Interview</a><li class="text-truncate lh-lg"> <a href="/posts/Consistent-Hashing/">Consistent Hashing | Core Concepts - System Design Interview</a><li class="text-truncate lh-lg"> <a href="/posts/k8s-introduction/">Kubernetes(Orchestration) 개론</a><li class="text-truncate lh-lg"> <a href="/posts/CAP-Theorem/">CAP Theorem(정리) | Core Concepts - System Design Interview</a><li class="text-truncate lh-lg"> <a href="/posts/What-is-CloudNativePG/">What is CloudNativePG? | CloudNative</a></ul></section><section><h2 class="panel-heading">Trending Tags</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/programming/">programming</a> <a class="post-tag btn btn-outline-primary" href="/tags/aws/">aws</a> <a class="post-tag btn btn-outline-primary" href="/tags/leetcode/">leetcode</a> <a class="post-tag btn btn-outline-primary" href="/tags/rust/">rust</a> <a class="post-tag btn btn-outline-primary" href="/tags/computer-science/">Computer Science</a> <a class="post-tag btn btn-outline-primary" href="/tags/cncf/">cncf</a> <a class="post-tag btn btn-outline-primary" href="/tags/k8s/">k8s</a> <a class="post-tag btn btn-outline-primary" href="/tags/kubernetes/">kubernetes</a> <a class="post-tag btn btn-outline-primary" href="/tags/algorithm/">algorithm</a> <a class="post-tag btn btn-outline-primary" href="/tags/architecture/">Architecture</a></div></section></div><section id="toc-wrapper" class="d-none ps-0 pe-4"><h2 class="panel-heading ps-3 mb-2">Contents</h2><nav id="toc"></nav></section></aside></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 px-md-4"><aside id="related-posts" aria-labelledby="related-label"><h3 class="mb-4" id="related-label">Further Reading</h3><nav class="row row-cols-1 row-cols-md-2 row-cols-xl-3 g-4 mb-4"><article class="col"> <a href="/posts/How-does-work-update-on-MongoDB-internally/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1728149340" data-df="ll" > Oct 6, 2024 </time><h4 class="pt-0 my-2">How does work 'update' on MongoDB internally?</h4><div class="text-muted"><p>책 ‘Designing Data-Intensive Applications’을 보면서, 궁금한것들이 많아집니다. 이 책이 2017년 초판이 인쇄 되었는데, 제가 쓰는 기술들에 실제로 적용 되는지 궁금해집니다. 이 글은 그중 하나인, ‘Mongodb(Document db)에서 update는 disk의 rewrite를 발생시키는가?’에 대한 글 입니다. ...</p></div></div></a></article><article class="col"> <a href="/posts/Consistent-Hashing/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1753809540" data-df="ll" > Jul 30, 2025 </time><h4 class="pt-0 my-2">Consistent Hashing | Core Concepts - System Design Interview</h4><div class="text-muted"><p>‘Consistent Hashing’은 분산 시스템(Distributed System)의 Cluster에서, 데이터를 분산 저장할때 사용하는 기초적인 알고리즘 입니다. 예시로 보는 Consistent Hashing의 필요성 ‘Ticketing System을 구성한다고 해봅시다. Simple System과 Sharding이 적용된 System...</p></div></div></a></article><article class="col"> <a href="/posts/CAP-Theorem/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1753369440" data-df="ll" > Jul 25, 2025 </time><h4 class="pt-0 my-2">CAP Theorem(정리) | Core Concepts - System Design Interview</h4><div class="text-muted"><p>CAP Theorem 소개 CAP는 각각 Consistency, Availability, Partition Tolerance를 의미합니다. 이 ‘CAP Theorem’은 ‘Distributed System(분산처리 시스템)’의 3가지 핵심 속성에서, 이중 딱 2개만 취할 수 있다는 theorem(정리, 일정한 조건하에 참이라는 것이 증명됨...</p></div></div></a></article></nav></aside><nav class="post-navigation d-flex justify-content-between" aria-label="Post Navigation"> <a href="/posts/Byte-and-bit/" class="btn btn-outline-primary" aria-label="Older" ><p>1 Byte and The number of bits(1Byte와 bit수)</p></a> <a href="/posts/String-Compression/" class="btn btn-outline-primary" aria-label="Newer" ><p>LeetCode 75-9 String Compression</p></a></nav><script src="https://utteranc.es/client.js" repo="KanghoonYi/kanghoonyi.github.io" issue-term="pathname" crossorigin="anonymous" async ></script> <script type="text/javascript"> (function () { const origin = 'https://utteranc.es'; const lightTheme = 'github-light'; const darkTheme = 'github-dark'; let initTheme = lightTheme; const html = document.documentElement; if ( (html.hasAttribute('data-mode') && html.getAttribute('data-mode') === 'dark') || (!html.hasAttribute('data-mode') && window.matchMedia('(prefers-color-scheme: dark)').matches) ) { initTheme = darkTheme; } addEventListener('message', (event) => { let theme;if (event.origin === origin) {theme = initTheme; } else if (event.source === window && event.data && event.data.direction === ModeToggle.ID) {const mode = event.data.message; theme = mode === ModeToggle.DARK_MODE ? darkTheme : lightTheme; } else { return; } const message = { type: 'set-theme', theme: theme }; const utterances = document.getElementsByClassName('utterances-frame')[0].contentWindow; utterances.postMessage(message, origin); }); })(); </script><footer aria-label="Site Info" class=" d-flex flex-column justify-content-center text-muted flex-lg-row justify-content-lg-between align-items-lg-center pb-lg-3 " ><p>© <time>2025</time> <a href="https://github.com/KanghoonYi">KanghoonYi</a>. <span data-bs-toggle="tooltip" data-bs-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author." >Some rights reserved.</span></p><p>Using the <a data-bs-toggle="tooltip" data-bs-placement="top" title="v7.1.1" href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener" >Chirpy</a> theme for <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a>.</p></footer></div></div><div id="search-result-wrapper" class="d-flex justify-content-center d-none"><div class="col-11 content"><div id="search-hints"><section><h2 class="panel-heading">Trending Tags</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/programming/">programming</a> <a class="post-tag btn btn-outline-primary" href="/tags/aws/">aws</a> <a class="post-tag btn btn-outline-primary" href="/tags/leetcode/">leetcode</a> <a class="post-tag btn btn-outline-primary" href="/tags/rust/">rust</a> <a class="post-tag btn btn-outline-primary" href="/tags/computer-science/">Computer Science</a> <a class="post-tag btn btn-outline-primary" href="/tags/cncf/">cncf</a> <a class="post-tag btn btn-outline-primary" href="/tags/k8s/">k8s</a> <a class="post-tag btn btn-outline-primary" href="/tags/kubernetes/">kubernetes</a> <a class="post-tag btn btn-outline-primary" href="/tags/algorithm/">algorithm</a> <a class="post-tag btn btn-outline-primary" href="/tags/architecture/">Architecture</a></div></section></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><aside aria-label="Scroll to Top"> <button id="back-to-top" type="button" class="btn btn-lg btn-box-shadow"> <i class="fas fa-angle-up"></i> </button></aside></div><div id="mask"></div><script src="https://cdn.jsdelivr.net/combine/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js,npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.umd.min.js,npm/glightbox@3.3.0/dist/js/glightbox.min.js,npm/clipboard@2.0.11/dist/clipboard.min.js,npm/dayjs@1.11.13/dayjs.min.js,npm/dayjs@1.11.13/locale/en.js,npm/dayjs@1.11.13/plugin/relativeTime.js,npm/dayjs@1.11.13/plugin/localizedFormat.js,npm/tocbot@4.29.0/dist/tocbot.min.js"></script> <script src="/assets/js/dist/post.min.js"></script> <script>SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<article class="px-1 px-sm-2 px-lg-4 px-xl-0"><header><h2><a href="{url}">{title}</a></h2><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div></header><p>{snippet}</p></article>', noResultsText: '<p class="mt-5">Oops! No results found.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="me-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
