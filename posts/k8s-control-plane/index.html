<!doctype html><html lang="ko" data-mode="light"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" ><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="Components - Control Plane Kubernetes Deep Dive - 2" /><meta name="author" content="KanghoonYi(pour)" /><meta property="og:locale" content="ko" /><meta name="description" content="Kubernetes에서 ‘Control Plane’은 Cluster를 운영하는 Core혹은 ‘뇌’의 역할을 합니다. Cluster를 다루기 위한 API요청을 검증하고, 상태를 저장하고, 요청을 실행시키고, Cluster를 유지하는 역할을 합니다. 여기서는 ‘Control Plane’이 어떤 Component를 통해 이런 역할을 수행하는지 알아봅니다." /><meta property="og:description" content="Kubernetes에서 ‘Control Plane’은 Cluster를 운영하는 Core혹은 ‘뇌’의 역할을 합니다. Cluster를 다루기 위한 API요청을 검증하고, 상태를 저장하고, 요청을 실행시키고, Cluster를 유지하는 역할을 합니다. 여기서는 ‘Control Plane’이 어떤 Component를 통해 이런 역할을 수행하는지 알아봅니다." /><link rel="canonical" href="https://blog.devpour.net/posts/k8s-control-plane/" /><meta property="og:url" content="https://blog.devpour.net/posts/k8s-control-plane/" /><meta property="og:site_name" content="KanghoonYi(Pour)" /><meta property="og:image" content="https://blog.devpour.net/assets/img/for-post/k8s%20control%20plane/k8s-control-plane-cover.jpg" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2025-06-30T20:14:00+09:00" /><meta name="twitter:card" content="summary_large_image" /><meta property="twitter:image" content="https://blog.devpour.net/assets/img/for-post/k8s%20control%20plane/k8s-control-plane-cover.jpg" /><meta property="twitter:title" content="Components - Control Plane Kubernetes Deep Dive - 2" /><meta name="google-site-verification" content="rsx_-5MJzSR_3NNCqHNe9IxnKJxlD8Eid8_wN8e9c1I" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"KanghoonYi(pour)","url":"https://www.linkedin.com/in/pour/"},"dateModified":"2025-07-10T18:06:59+09:00","datePublished":"2025-06-30T20:14:00+09:00","description":"Kubernetes에서 ‘Control Plane’은 Cluster를 운영하는 Core혹은 ‘뇌’의 역할을 합니다. Cluster를 다루기 위한 API요청을 검증하고, 상태를 저장하고, 요청을 실행시키고, Cluster를 유지하는 역할을 합니다. 여기서는 ‘Control Plane’이 어떤 Component를 통해 이런 역할을 수행하는지 알아봅니다.","headline":"Components - Control Plane Kubernetes Deep Dive - 2","image":"https://blog.devpour.net/assets/img/for-post/k8s%20control%20plane/k8s-control-plane-cover.jpg","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.devpour.net/posts/k8s-control-plane/"},"url":"https://blog.devpour.net/posts/k8s-control-plane/"}</script><title>Components - Control Plane | Kubernetes Deep Dive - 2 | KanghoonYi(Pour)</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="KanghoonYi(Pour)"><meta name="application-name" content="KanghoonYi(Pour)"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="/assets/css/jekyll-theme-chirpy.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.6.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.29.0/dist/tocbot.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/glightbox@3.3.0/dist/css/glightbox.min.css"><body><aside aria-label="Sidebar" id="sidebar" class="d-flex flex-column align-items-end"><header class="profile-wrapper"> <a href="/" id="avatar" class="rounded-circle"><img src="/assets/img/pour_profile_img.png" width="112" height="112" alt="avatar" onerror="this.style.display='none'"></a><h1 class="site-title"> <a href="/">KanghoonYi(Pour)</a></h1><p class="site-subtitle fst-italic mb-0">안녕하세요~ Software Engineer pour입니다 This is Pour.</p></header><nav class="flex-column flex-grow-1 w-100 ps-0"><ul class="nav"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle"></i> <span>ABOUT</span> </a></ul></nav><div class="sidebar-bottom d-flex flex-wrap align-items-center w-100"> <a href="https://github.com/KanghoonYi" aria-label="github" target="_blank" rel="noopener noreferrer" > <i class="fab fa-github"></i> </a> <a href="https://twitter.com/" aria-label="twitter" target="_blank" rel="noopener noreferrer" > <i class="fa-brands fa-x-twitter"></i> </a> <a href="javascript:location.href = 'mailto:' + ['rkdgnsdls','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></aside><div id="main-wrapper" class="d-flex justify-content-center"><div class="container d-flex flex-column px-xxl-5"><header id="topbar-wrapper" aria-label="Top Bar"><div id="topbar" class="d-flex align-items-center justify-content-between px-lg-3 h-100" ><nav id="breadcrumb" aria-label="Breadcrumb"> <span> <a href="/">Home</a> </span> <span>Components - Control Plane | Kubernetes Deep Dive - 2</span></nav><button type="button" id="sidebar-trigger" class="btn btn-link"> <i class="fas fa-bars fa-fw"></i> </button><div id="topbar-title"> Post</div><button type="button" id="search-trigger" class="btn btn-link"> <i class="fas fa-search fa-fw"></i> </button> <search id="search" class="align-items-center ms-3 ms-lg-0"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..." > </search> <button type="button" class="btn btn-link text-decoration-none" id="search-cancel">Cancel</button></div></header><div class="row flex-grow-1"><main aria-label="Main Content" class="col-12 col-lg-11 col-xl-9 px-md-4"><article class="px-1"><header><h1 data-toc-skip>Components - Control Plane | Kubernetes Deep Dive - 2</h1><div class="post-meta text-muted"> <span> Posted <time data-ts="1751282040" data-df="ll" data-bs-toggle="tooltip" data-bs-placement="bottom" > Jun 30, 2025 </time> </span> <span> Updated <time data-ts="1752138419" data-df="ll" data-bs-toggle="tooltip" data-bs-placement="bottom" > Jul 10, 2025 </time> </span><div class="mt-3 mb-3"> <a href="/assets/img/for-post/k8s%20control%20plane/k8s-control-plane-cover.jpg" class="popup img-link preview-img shimmer"><img src="/assets/img/for-post/k8s%20control%20plane/k8s-control-plane-cover.jpg" alt="Preview Image" width="1200" height="630" loading="lazy"></a></div><div class="d-flex justify-content-between"> <span> By <em> <a href="https://www.linkedin.com/in/pour/">KanghoonYi(pour)</a> </em> </span><div> <span class="readtime" data-bs-toggle="tooltip" data-bs-placement="bottom" title="3856 words" > <em>21 min</em> read</span></div></div></div></header><div class="content"><p>Kubernetes에서 ‘Control Plane’은 Cluster를 운영하는 Core혹은 ‘뇌’의 역할을 합니다.<br /> Cluster를 다루기 위한 API요청을 검증하고, 상태를 저장하고, 요청을 실행시키고, Cluster를 유지하는 역할을 합니다.<br /> 여기서는 ‘Control Plane’이 어떤 Component를 통해 이런 역할을 수행하는지 알아봅니다.</p><p><a href="/assets/img/for-post/k8s%20control%20plane/image.png" class="popup img-link shimmer"><img src="/assets/img/for-post/k8s%20control%20plane/image.png" alt="Kubernetes의 Cluster Architecture | [https://kubernetes.io/docs/concepts/architecture/](https://kubernetes.io/docs/concepts/architecture/)" loading="lazy"></a> <em>Kubernetes의 Cluster Architecture | <a href="https://kubernetes.io/docs/concepts/architecture/">https://kubernetes.io/docs/concepts/architecture/</a></em></p><h2 id="kube-apiserver"><span class="me-2">kube-apiserver</span><a href="#kube-apiserver" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Kubernetes를 조작(control)하기 위한 API를 외부에 노출하는 서비스입니다. Kubernetes 입장에서 보면(backend로 두고 보면), ‘kube-apiserver’는 frontend에 해당합니다.</p><dl><dt>‘kube-apiserver’는<dd>수평확장(scale horizontally, scale-out)이 가능합니다. 이는 Node가 늘어남에 따라, apiserver도 확장되는것을 의미합니다.<dd>인증(Authentication), 인가(Authorization), Admission Control(승인 제어)를 수행합니다.<dd>요청 Schema에 대해 검증 하고 변환합니다.<dd>etcd에 대한 CRUD Interface라고 말하기도 합니다.</dl><h3 id="admission-control"><span class="me-2">Admission Control</span><a href="#admission-control" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><blockquote><p>Admission control mechanisms may be validating, mutating, or both.<br /> - from <a href="https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/">Admission Control in Kubernetes</a></p></blockquote><p>‘Admission Control’은 요청의 ‘승인(Admission)’을 ‘제어(Control)’하는 기능을 말합니다.<br /> ‘kube-apiserver’로 들어온 요청을 가로채서(intercept), ‘변경, 검증’에 대한 별도의 과정을 수행하는 기능입니다.</p><blockquote class="prompt-info"><p>이 ‘Admission Control’은 요청에 대한 인증(authentication)과 인가(authorization)이 완료된 요청에 대해서 반영됩니다.</p></blockquote><p><br /></p><dl><dt>이는 크게 2가지 과정으로 이루어집니다.<dd>요청 변경(mutating). Mutating controller를 통해 요청 내용을 수정할 수 있습니다.<dd>요청 검증(validation). Validating controllers를 통해 요청을 검증하여, 더 이상 진행되지 못한게 할 수 있습니다.</dl><p>위 기능중 하나만 작동하게 할 수도 있고, 모두 작동하게 할 수도 있습니다.</p><blockquote class="prompt-info"><p>단 ‘Read(get, watch or list)’는 막을(block) 수 없습니다. CREATE, UPDATE, DELETE와 같은 ‘변경(mutating)’ 요청에 대해서만 적용됩니다. 혹은, 연결(connect) 같은 커스텀 동작에 대해서 적용됩니다.(ex: kubectl exec)</p></blockquote><p><br /></p><h4 id="admission-control-flow"><span class="me-2">Admission Control Flow</span><a href="#admission-control-flow" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p><a href="/assets/img/for-post/k8s%20control%20plane/admission-control-phases.png" class="popup img-link shimmer"><img src="/assets/img/for-post/k8s%20control%20plane/admission-control-phases.png" alt="Admission Control Flow" loading="lazy"></a> <em>Admission Control Flow</em></p><ol><li><p>Request가 kube-apiserver에 도착합니다</p><li><p>인증(authentication)과 인가(authorization)을 수행합니다.</p><li><p>변경(mutating)에 대해 등록된 모든 Webhook을 실행합니다.<br /> ‘Mutating Admission controllers’가 수행합니다.</p><li><p>검증(validation)에 대한 정책(policy)에 대해서 validation을 수행합니다.<br /> ‘Mutating’단계가지 마치고, 만들어진 최종 객체에 대해서, <strong>Cluster 내부</strong>에서 정의된 정책(policy)를 기반으로 평가하는 단계 입니다.</p><li>검증(validation)에 대해 등록된 모든 Webhook을 실행합니다.<blockquote class="prompt-info"><p>이전 단계인 정책(policy) validation과는 다르게, 외부의 HTTP endpoint에 요청을 보냅니다.</p></blockquote><li>etcd에 저장합니다. <br /></ol><h4 id="mutatingadmissionwebhook-controller"><span class="me-2">MutatingAdmissionWebhook Controller</span><a href="#mutatingadmissionwebhook-controller" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>요청(request) 객체를 변경(patch)합니다.<br /> 이때, 기본값을 주입하거나, <strong>사이드카(sidecar)</strong>가 삽입됩니다.</p><blockquote class="prompt-info"><p>여기서 ‘사이드카(sidecar)’는 패턴으로 자리잡아, Kubernetes에서 핵심적인 역할을 하게 됩니다.</p></blockquote><h4 id="validatingadmissionwebhook-controller"><span class="me-2">ValidatingAdmissionWebhook Controller</span><a href="#validatingadmissionwebhook-controller" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>요청(request) 객체가 정책에 부합하는지 검사하고, 허용하거나 거부합니다.<br /> 모든 Mutating이 끝나고 나서 실행됩니다.</p><h3 id="성능-혹은-스케일링-시에-튜닝할-수-있는-부분"><span class="me-2">성능 혹은 스케일링 시에 튜닝할 수 있는 부분</span><a href="#성능-혹은-스케일링-시에-튜닝할-수-있는-부분" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>API Server의 QPS(Queries Per Second)나 Burst를 조정할 수 있습니다<div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre>  <span class="c"># QPS 조정</span>
  <span class="c"># default값이 20</span>
  <span class="nv">$ </span>kube-controller-manager <span class="nt">--kube-api-qps</span> 20
    
  <span class="c"># Burst 조정</span>
  <span class="c"># default값이 30</span>
  <span class="nv">$ </span>kube-controller-manager <span class="nt">--kube-api-burst</span> 30
</pre></table></code></div></div></ul><h3 id="source-code"><span class="me-2">Source code</span><a href="#source-code" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><a href="https://github.com/kubernetes/apiserver">https://github.com/kubernetes/apiserver</a></p><p><br /></p><h2 id="etcd"><span class="me-2">etcd</span><a href="#etcd" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><blockquote><p><strong>etcd</strong> is a strongly consistent, distributed key-value store that provides a reliable way to store data that needs to be accessed by a distributed system or cluster of machines.<br /> - from <a href="https://etcd.io/">etcd homepage</a></p></blockquote><p>‘etcd’는 key-value 데이터 저장소입니다. 강한 일관성(strongly consistent), 분산형(distributed) 특징을 통해 매우 안정적인 저장소 역할을 합니다.</p><dl><dt>Kubernetes에서 etcd는<dd>클러스터에 대한 상태 저장소 역할을합니다. 모든 k8s객체(Deployment, Service, ConfigMap등등)의 Desired State를 저장합니다.<dd>컨트롤 loop와 연동되어, 컨트롤러 매니저와 스케줄러 같은 제어 컴포턴트가 변경을 감지하여, 행동을 시작하도록 합니다.<dd>TLS를 통한 암호화 통신, 클라이언트 인증(Cert-based), Role-Based Access Control(RBAC) 설정으로 데이터를 보호합니다.</dl><p>etcd는 다음과 같은 기능을 제공합니다.</p><h3 id="강한-일관성strongly-consistent"><span class="me-2">강한 일관성(strongly consistent)</span><a href="#강한-일관성strongly-consistent" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>모든 읽기(read)/쓰기(write) 요청에 대해 <strong>최신상태를 보장</strong>하며, ‘읽기 후 쓰기(Write after read, WAR)’ 시점에 stale 데이터(구버젼 데이터)가 반환될 위험이 없습니다.</p><blockquote class="prompt-info"><p><a href="https://www.baeldung.com/cs/structural-vs-data-hazards">‘읽기 후 쓰기(Write After Read, WAR)’</a>: CPU레벨에서 명령어를 병렬처리 할때, 처리 순서에 따라 반환값이 달라질 수 있는 문제를 말합니다.<br /> 즉, 여기서는 ‘데이터를 읽을때 마다 값이 다를 가능성’에 대한 얘기를 하고 있습니다.</p></blockquote><h3 id="분산형distributed-시스템의-리더-팔로워-구조"><span class="me-2">분산형(distributed) 시스템의 리더, 팔로워 구조</span><a href="#분산형distributed-시스템의-리더-팔로워-구조" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><dl><dt>etcd는<dd>리더(Leader)와 다수의 팔로워(Follower) 노드로 분산처리 시스템을 구성합니다.<dd>쓰기(write) 요청은 리더가 처리한 후에, 팔로워에 복제합니다.<dd>커밋이 완료되면, 해당 데이터를 클라이언트에게 노출합니다.(강력한 일관성 보장)</dl><p>etcd의 분산 시스템은, Raft 알고리즘을 사용합니다.</p><h4 id="raft-합의-알고리즘"><span class="me-2"><a href="https://en.wikipedia.org/wiki/Raft_(algorithm)">Raft 합의 알고리즘</a></span><a href="#raft-합의-알고리즘" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>분산 환경에서 데이터의 일관성과 가용성을 보장하기 위해 사용하는 알고리즘입니다.<br /> ‘리더 선출’, ‘로그 복제(Log Replication)’, ‘안정성 보장’이 특징입니다.</p><dl><dt>리더 선출<dd>팔로워가 리더의 신호를 못 받으면, 팔로워들이 후보상태로 전환되어 새로운 리더를 선출합니다.</dl><blockquote class="prompt-info"><p>이런 이유로, etcd의 인스턴스는 홀수개로 이루어져야 합니다. 짝수개인 경우, 리더가 실패시 후보로 나온 인스턴스를 빼면, 다시 짝수개가되어 선출과정에서 동수가 나올 수 있습니다.</p></blockquote><dl><dt>로그 복제<dd>클라이언트의 key-value 변경 요청을 받으면, 이를 리더에게 보냅니다. 리더는 이를 받아서 Log에 추가하며, 이를 팔로워들에게 전파시킵니다. 과반의 팔로워가 저장했다고 하면, 이를 commit합니다.<dt>안정성 보장<dd>commit된 로그는 반드시 과반의 노드에 복제되어 있습니다.</dl><h3 id="데이터-모델"><span class="me-2">데이터 모델</span><a href="#데이터-모델" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>etcd는 key-value 쌍(pair)를 <a href="https://en.wikipedia.org/wiki/B%2B_tree">B+ tree</a> (BoltDB)형태로 저장합니다.</p><p><a href="/assets/img/for-post/k8s%20control%20plane/image%201.png" class="popup img-link shimmer"><img src="/assets/img/for-post/k8s%20control%20plane/image%201.png" alt="etcd의 데이터 모델" loading="lazy"></a> <em>etcd의 데이터 모델</em></p><dl><dt>etcd는<dd>별도의 In-memory btree도 함께 운영하는데, 이는 key에 대한 query속도를 높여주는 역할을 합니다.<dd>in-memory btree를 통해 revision정보를 얻고, 이를 기반으로(b+ tree의 key로 사용해서) b+ tree에서 value값을 가져옵니다.</dl><h3 id="tuning"><span class="me-2">Tuning</span><a href="#tuning" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><a href="https://etcd.io/docs/v3.6/tuning/">Tuning</a></p><p><br /></p><h2 id="kube-scheduler"><span class="me-2">kube-scheduler</span><a href="#kube-scheduler" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>‘kube-scheduler’는 Pod을 Node에 배치(binding)하는 역할을 합니다.<br /> Cluster의 리소스 요청, 정책(affinity/taint, toleration 등), 사용자 정의를 모두 종합하여 최적의 Node를 선택합니다. 이 과정에서 Pod이 스케쥴링 될 수 있는 Node를 ‘feasible Node’라고 합니다.</p><p>만약, 적합한 Node가 없다면, Pod은 스케쥴 되지 못한 채로 있습니다. 이는 조건에 부합한 Node가 나타날때가지 계속됩니다.</p><h3 id="pod이-스케쥴링-되는-과정"><span class="me-2">Pod이 스케쥴링 되는 과정</span><a href="#pod이-스케쥴링-되는-과정" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>‘kube-scheduler’를 통해서 Pod이 배치되는 과정은 2개의 step으로 이루어져 있습니다.</p><ol><li><p>Filtering<br /> 특정 조건에 따라 ‘feasible Node’를 찾습니다. 이 과정이 완료되면, 적합한 Node List가 반환됩니다.</p><li><p>Scoring<br /> ‘Filtering’에서 만들어진 Node List를 기반으로, 순위를 매깁니다(rank). 이를 기반으로 가장 적합한 Node를 선택하여 Pod을 배치합니다.<br /> 만약 동점인 Node가 있다면, 이 Node들 사이에서 random하게 배치됩니다.<br /> ‘kube-scheduler’는 이 결과를 API서버에 알려줍니다(notify).</p></ol><p><a href="/assets/img/for-post/k8s%20control%20plane/image%202.png" class="popup img-link shimmer"><img src="/assets/img/for-post/k8s%20control%20plane/image%202.png" alt="Pod이 스케쥴링 되는 과정" loading="lazy"></a> <em>Pod이 스케쥴링 되는 과정</em></p><p><br /></p><p><a href="/assets/img/for-post/k8s%20control%20plane/image%203.png" class="popup img-link shimmer"><img src="/assets/img/for-post/k8s%20control%20plane/image%203.png" alt="Scheduler와 다른 Component의 상호작용" loading="lazy"></a> <em>Scheduler와 다른 Component의 상호작용</em></p><p><a href="https://kubernetes.io/docs/reference/scheduling/policies/">스케쥴링 정책(Scheduling Policies)</a>를 통해 스케쥴링을 조정할 수 있습니다. (v1.23이전 한정)</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="nv">$ </span>kube-scheduler <span class="nt">--policy-config-file</span> &lt;filename&gt;

<span class="c"># or</span>

<span class="nv">$ </span>kube-scheduler <span class="nt">--policy-configmap</span> &lt;ConfigMap&gt;
</pre></table></code></div></div><p><a href="https://kubernetes.io/docs/reference/scheduling/config/">스케쥴러 설정(Scheduler Configuration)</a>을 통해 위와 동일한 설정을 할 수 있습니다.(v1.23 이상)</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nv">$ </span>kube-scheduler <span class="nt">--config</span> &lt;filename&gt;
</pre></table></code></div></div><div class="language-yaml highlighter-rouge"><div class="code-header"> <span data-label-text="YAML"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="c1"># configuration 파일 예시</span>
<span class="na">apiVersion</span><span class="pi">:</span> <span class="s">kubescheduler.config.k8s.io/v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">KubeSchedulerConfiguration</span>
<span class="na">clientConnection</span><span class="pi">:</span>
  <span class="na">kubeconfig</span><span class="pi">:</span> <span class="s">/etc/srv/kubernetes/kube-scheduler/kubeconfig</span>
</pre></table></code></div></div><h3 id="source-code-1"><span class="me-2">Source Code</span><a href="#source-code-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><a href="https://github.com/kubernetes/kube-scheduler">https://github.com/kubernetes/kube-scheduler</a></p><p><br /></p><h2 id="kube-controller-manager"><span class="me-2">kube-controller-manager</span><a href="#kube-controller-manager" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>‘kube-controller-manager’는 ‘control loops’를 운영하는 컴포넌트입니다.<br /> 여기서 ‘loop’는 ‘종료되지 않음’을 의미합니다.<br /> ‘kube-controller-manager’는 계속해서 시스템의 현재 상태(the state of system)를 관찰하고, 현재상태와 목표 상태(Desired State)가 다르다면, 이에 도달하기 위해 변화(changes)를 시도합니다.</p><h3 id="control-loop-flow"><span class="me-2">Control Loop Flow</span><a href="#control-loop-flow" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><a href="/assets/img/for-post/k8s%20control%20plane/image%204.png" class="popup img-link w-50 shimmer"><img src="/assets/img/for-post/k8s%20control%20plane/image%204.png" alt="Control loop의 flow" loading="lazy"></a> <em>Control loop의 flow</em></p><p>‘kube-controller-manager’는 ‘Control Loop’를 통해 Cluster의 현재상태와 목표 상태(Desired State)를 계속 비교하며, 동일하게 맞춥니다.<br /> 이 Loop안에서, 각각의 Kubernetes Object에 맞는 ‘Controller’를 사용합니다.</p><h3 id="controller-종류"><span class="me-2">controller 종류</span><a href="#controller-종류" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><p>Node Controller<br /> 노드의 상태 변화를 감시(Ready/NotReady), 노드 삭제 감지 시 인그레스/서비스 정리</p><li><p>Replication controller / Replicaset controller<br /> replicas 수를 보장하기 위해 Pod을 증감을 관장</p><li><p>Endpoints controller<br /> Service와 Pod IP 매핑 정보 유지</p><li><p>Namespace controller<br /> Namespace 리소스 생성·삭제 후, 네임스페이스 내부 리소스 정리</p><li><p>Service controller<br /> 클라우드 로드밸런서 생성·삭제, EndpointSlice 동기화</p><li><p>Deployment Controller<br /> 롤링 업데이트, 롤백, 배포전략(Blue/Green, Canary) 관리</p><li>Horizontal Pod Autoscaler(HPA)<li>…등</ul><h3 id="horizontal-pod-autoscalerhpa"><span class="me-2">Horizontal Pod Autoscaler(HPA)</span><a href="#horizontal-pod-autoscalerhpa" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Kubernetes에서 워크로드의 부하(CPU 사용률, 메모리 사용량, 커스텀 메트릭 등)에 따라 자동으로 Pod 개수를 수평(horizontal) 으로 늘리거나 줄여 주는 컨트롤러입니다.</p><h4 id="작동-flow"><span class="me-2">작동 Flow</span><a href="#작동-flow" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ol><li>특정 주기(기본 15초)마다 Metrics API(보통 metrics-server 또는 Prometheus Adapter 등)를 호출해 대상 리소스의 현재 메트릭을 가져옵니다.<li><p>현재 값과 목표(target)값을 비교합니다.<br /> 이때, 아래 <a href="https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/#algorithm-details">알고리즘</a>을 사용하여, 필요한 Pod의 개수를 계산합니다.</p>\[\text{desiredReplicas} = \left\lceil \frac{\text{currentMetricValue}}{\text{targetMetricValue}} \times \text{currentReplicas} \right\rceil\]<li><p>스케일 결정<br /> 2에서 산출된 ‘desiredReplicas’를 minReplicas ~ maxReplicase 범위의 값으로 클램프(clamp)하여 최종 스케일 개수를 확정합니다.</p><li>Scale API를 호출합니다.<br /> Deployment/ReplicaSet/StatefulSet 등 대상 리소스에 대한 scale 서브리소스를 업데이트하여, 실제 Pod 수를 조정합니다.</ol><h4 id="config파일-예시"><span class="me-2">Config파일 예시</span><a href="#config파일-예시" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><div class="language-yaml highlighter-rouge"><div class="code-header"> <span data-label-text="YAML"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre><td class="rouge-code"><pre><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">autoscaling/v2</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">HorizontalPodAutoscaler</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">myapp-hpa</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">scaleTargetRef</span><span class="pi">:</span>
    <span class="na">apiVersion</span><span class="pi">:</span> <span class="s">apps/v1</span>
    <span class="na">kind</span><span class="pi">:</span> <span class="s">Deployment</span>
    <span class="na">name</span><span class="pi">:</span> <span class="s">myapp</span>
  <span class="na">minReplicas</span><span class="pi">:</span> <span class="m">2</span>
  <span class="na">maxReplicas</span><span class="pi">:</span> <span class="m">10</span>
  <span class="na">metrics</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">type</span><span class="pi">:</span> <span class="s">Resource</span>
    <span class="na">resource</span><span class="pi">:</span>
      <span class="na">name</span><span class="pi">:</span> <span class="s">cpu</span>
      <span class="na">target</span><span class="pi">:</span>
        <span class="na">type</span><span class="pi">:</span> <span class="s">Utilization</span>      <span class="c1"># 평균(cpu) 사용률 비율 (%)</span>
        <span class="na">averageUtilization</span><span class="pi">:</span> <span class="m">50</span>
  <span class="pi">-</span> <span class="na">type</span><span class="pi">:</span> <span class="s">Resource</span>
    <span class="na">resource</span><span class="pi">:</span>
      <span class="na">name</span><span class="pi">:</span> <span class="s">memory</span>
      <span class="na">target</span><span class="pi">:</span>
        <span class="na">type</span><span class="pi">:</span> <span class="s">Value</span>            <span class="c1"># 절대 메모리 사용량(bytes)</span>
        <span class="na">averageValue</span><span class="pi">:</span> <span class="s">200Mi</span>
  <span class="pi">-</span> <span class="na">type</span><span class="pi">:</span> <span class="s">Pods</span>                <span class="c1"># Pod당 커스텀 메트릭</span>
    <span class="na">pods</span><span class="pi">:</span>
      <span class="na">metric</span><span class="pi">:</span>
        <span class="na">name</span><span class="pi">:</span> <span class="s">transactions_per_second</span>
      <span class="na">target</span><span class="pi">:</span>
        <span class="na">type</span><span class="pi">:</span> <span class="s">AverageValue</span>
        <span class="na">averageValue</span><span class="pi">:</span> <span class="s2">"</span><span class="s">100"</span>
</pre></table></code></div></div><p><br /></p><h2 id="cloud-controller-manageroptional"><span class="me-2">cloud-controller-manager(optional)</span><a href="#cloud-controller-manageroptional" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>AWS와 같은 특정 Cloud에 대응하는 Control Logic을 담고 있는 component입니다.<br /> 처음에는 Core Controller manager(kube-controller-manager)에 포함되어 있었지만, 현재는 Cloud Provider(AWS와 같은, 이하 클라우드)의 Control logic과 Kubernetes logic이 분리되어 있습니다.</p><dl><dt>이런 ‘분리 설계’를 통해,<dd>Kubernetes와 각 Cloud Provider사이에 분리된 Feature release가 가능해졌습니다.<dd>클라우드별 기능(로드밸런서 생성, 볼륨 프로비저닝, Route 설정 등등)을 외부 플러그인 형태로 관리하게 되었습니다.(클라우드 플러그인만 바꾸면, 다양한 환경에서 사용가능)</dl><h3 id="cloud-controller-manager에-포함된-controller들"><span class="me-2">‘cloud-controller-manager’에 포함된 Controller들</span><a href="#cloud-controller-manager에-포함된-controller들" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><p>Node Controller<br /> 클라우드 서비스에서 제공하는 Node(VM환경)에 대한 controller입니다.<br /> VM들이 Kubernetes의 Node로 역할하도록 합니다.</p><li><p>Route Controller<br /> 클라우드에서 제공하는 Routing설정을 통해 Pod간 통신이 가능하게 합니다.</p><li><p>Service Controller<br /> 클라우드의 LB(Load Balancer)나 IP, networking packet filtering, health checking등을 Kubernetes에 적용하는 controller입니다.</p><li><p>Volume Controller<br /> Kubernetes의 Persistent Volume을 클라우드 서비스에서 제공하는 볼륨과 연결시켜 줍니다.(NAS와 같은 것들)</p></ul><p><br /></p><h2 id="pod배치를-위한-kube-scheduler과-kube-controller-manager의-상호작용"><span class="me-2">Pod배치를 위한 kube-scheduler과 kube-controller-manager의 상호작용</span><a href="#pod배치를-위한-kube-scheduler과-kube-controller-manager의-상호작용" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>‘kube-scheduler’는 Pod을 Node에 배치하는 역할을 하고, ‘kube-controller-manager’는 Desired State를 달성하는 역할(Pod을 늘리는 역할)을 하는데, 이 과정은 어떻게 이루어 질까?</p><p><a href="/assets/img/for-post/k8s%20control%20plane/k8s-pod-binding-flow.png" class="popup img-link shimmer"><img src="/assets/img/for-post/k8s%20control%20plane/k8s-pod-binding-flow.png" alt="Deployment반영을 위한 component간 상호작용 Flow" loading="lazy"></a> <em>Deployment반영을 위한 component간 상호작용 Flow</em></p><p>만약, Deployment를 통해 Pod을 생성하고 있다면,</p><ol><li><p>Controller manager에서 Pod Object 생성<br /> Deployment → ReplicaSet → Pod 오브젝트를 생성합니다.<br /> 이때 Pod은 spec.nodeName이 비어 있는 <strong>“Pending” 상태</strong>입니다</p><li><p>scheduler에서 Pod을 Node에 배치<br /> Pending Pod를 발견 → 노드 리스트 중 필터(Filter)·스코어(Score) → Binding 호출 (spec.nodeName 설정)</p><li><p>Controller manager에서 후속작업 수행(optional)<br /> 예: DaemonSet 컨트롤러로 데몬 배포, HPA 컨트롤러로 Replica 수 조정 등</p><li><p>kubelet에서 바인딩(Binding) 실행<br /> kubelet이, 바인딩된 Node에서 Pod을 실제로 실행합니다.</p></ol><dl><dt>kube-controller-manager가<dd><strong>“무엇을 몇 개”를 만들 것인지</strong>(Pod 등 리소스 생성·삭제)를 결정하고 API 호출을 수행하면,<dt>kube-scheduler는<dd>“어디에” 배치할지(어떤 노드에 놓을지) 결정하여 Binding을 수행합니다.</dl><h2 id="실습"><span class="me-2">실습</span><a href="#실습" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><blockquote class="prompt-info"><p>AWS EKS환경에서 Control Plane은 고객이 직접 접근할 수 없는 완전 관리형(Managed) 서비스로 운영됩니다. 때문에, kubectl로 직접 Control Plane을 접속하진 못하고, AWS CLI도구를 통해 Cluster의 상태를 조회합니다.</p></blockquote><h3 id="kubectl와-cluster-연결"><span class="me-2">kubectl와 Cluster 연결</span><a href="#kubectl와-cluster-연결" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>kubectl은 한번에 하나의 Cluster를 연결하여 명령어를 실행합니다.<br /> 이때, ‘Context’라는 개념으로 Cluster와의 연결을 생성합니다.</p><h4 id="kubectl과-eks-cluster-연결"><span class="me-2">kubectl과 EKS Cluster 연결</span><a href="#kubectl과-eks-cluster-연결" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p><a href="https://docs.aws.amazon.com/ko_kr/eks/latest/userguide/create-kubeconfig.html#create-kubeconfig-automatically">AWS CLI 명령어</a>를 통해, EKS Cluster에 대한 Context를 쉽게 생성할 수 있습니다.</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nv">$ AWS_PROFILE</span><span class="o">=</span><span class="k">****</span> aws eks update-kubeconfig <span class="nt">--region</span> ap-northeast-2 <span class="nt">--name</span> workshopdapne2-yeov
Added new context arn:aws:eks:ap-northeast-2:0000000:cluster/workshopdapne2-yeov to /Users/<span class="k">****</span>/.kube/config
</pre></table></code></div></div><h4 id="local환경에-있는-cluster목록context-조회"><span class="me-2">Local환경에 있는 Cluster목록(Context) 조회</span><a href="#local환경에-있는-cluster목록context-조회" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nv">$ </span>kubectl ctx
arn:aws:eks:ap-northeast-2:0000000:cluster/workshopdapne2-yeov
</pre></table></code></div></div><h3 id="cluster-상태-조회"><span class="me-2">Cluster 상태 조회</span><a href="#cluster-상태-조회" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nv">$ AWS_PROFILE</span><span class="o">=</span><span class="k">****</span> aws eks describe-cluster <span class="nt">--name</span> workshopdapne2-yeov <span class="nt">--query</span> <span class="s2">"cluster.status"</span>
<span class="s2">"ACTIVE"</span>
</pre></table></code></div></div><h2 id="references"><span class="me-2">References</span><a href="#references" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><dl><dt>Componentes | kubernetes.io<dd><a href="https://kubernetes.io/docs/concepts/overview/components/">Kubernetes Components</a><dt>Cluster Architecture | kubernetes.io<dd><a href="https://kubernetes.io/docs/concepts/architecture/">Cluster Architecture</a><dt>Admission control | kubernetes.io<dd><a href="https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/">Admission Control in Kubernetes</a><dt>etcd Learning | etcd.io<dd><a href="https://etcd.io/docs/v3.6/learning/">Learning</a><dt>Etcd란? | IBM<dd><a href="https://www.ibm.com/kr-ko/think/topics/etcd">etcd란 무엇인가요? | IBM</a><dt>Raft 알고리즘<dd><a href="https://en.wikipedia.org/wiki/Raft_(algorithm)">Raft (algorithm)</a><dt>kube-scheduler | kubernetes.io<dd><a href="https://kubernetes.io/docs/concepts/scheduling-eviction/kube-scheduler/">Kubernetes Scheduler</a><dt>Scheduling Framework | kubernetes.io<dd><a href="https://kubernetes.io/docs/concepts/scheduling-eviction/scheduling-framework/">Scheduling Framework</a><dt>kube-controller-manager, Controllers | kubernetes.io<dd><a href="https://kubernetes.io/docs/concepts/architecture/controller/">Controllers</a><dt>Horizontal Pod Autoscaling | kubernetes.io<dd><a href="https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/">Horizontal Pod Autoscaling</a><dt>Understanding Kubernetes Architecture | devopscube.com<dd><a href="https://devopscube.com/kubernetes-architecture-explained/">Understanding Kubernetes Architecture: A Comprehensive Guide</a></dl></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw me-1"></i> <a href="/categories/devops/">DevOps</a>, <a href="/categories/kubernetes/">kubernetes</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw me-1"></i> <a href="/tags/aws/" class="post-tag no-text-decoration" >aws</a> <a href="/tags/kubernetes/" class="post-tag no-text-decoration" >kubernetes</a> <a href="/tags/cncf/" class="post-tag no-text-decoration" >cncf</a> <a href="/tags/k8s/" class="post-tag no-text-decoration" >k8s</a></div><div class=" post-tail-bottom d-flex justify-content-between align-items-center mt-5 pb-2 " ><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper d-flex align-items-center"> <span class="share-label text-muted">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Components%20-%20Control%20Plane%20%7C%20Kubernetes%20Deep%20Dive%20-%202%20-%20KanghoonYi(Pour)&url=https%3A%2F%2Fblog.devpour.net%2Fposts%2Fk8s-control-plane%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Twitter" aria-label="Twitter"> <i class="fa-fw fa-brands fa-square-x-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Components%20-%20Control%20Plane%20%7C%20Kubernetes%20Deep%20Dive%20-%202%20-%20KanghoonYi(Pour)&u=https%3A%2F%2Fblog.devpour.net%2Fposts%2Fk8s-control-plane%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Facebook" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https%3A%2F%2Fblog.devpour.net%2Fposts%2Fk8s-control-plane%2F&text=Components%20-%20Control%20Plane%20%7C%20Kubernetes%20Deep%20Dive%20-%202%20-%20KanghoonYi(Pour)" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Telegram" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <button id="copy-link" aria-label="Copy link" class="btn small" data-bs-toggle="tooltip" data-bs-placement="top" title="Copy link" data-title-succeed="Link copied successfully!" > <i class="fa-fw fas fa-link pe-none fs-6"></i> </button> </span></div></div></div></article></main><aside aria-label="Panel" id="panel-wrapper" class="col-xl-3 ps-2 mb-5 text-muted"><div class="access"><section id="access-lastmod"><h2 class="panel-heading">Recently Updated</h2><ul class="content list-unstyled ps-0 pb-1 ms-1 mt-2"><li class="text-truncate lh-lg"> <a href="/posts/k8s-gpu-1/">kubernetes 환경에서 GPU 서빙 | GPU인식</a><li class="text-truncate lh-lg"> <a href="/posts/Redis/">Redis | Key Technologies - System Design Interview</a><li class="text-truncate lh-lg"> <a href="/posts/Consistent-Hashing/">Consistent Hashing | Core Concepts - System Design Interview</a><li class="text-truncate lh-lg"> <a href="/posts/k8s-introduction/">Kubernetes(Orchestration) 개론</a><li class="text-truncate lh-lg"> <a href="/posts/CAP-Theorem/">CAP Theorem(정리) | Core Concepts - System Design Interview</a></ul></section><section><h2 class="panel-heading">Trending Tags</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/programming/">programming</a> <a class="post-tag btn btn-outline-primary" href="/tags/aws/">aws</a> <a class="post-tag btn btn-outline-primary" href="/tags/leetcode/">leetcode</a> <a class="post-tag btn btn-outline-primary" href="/tags/rust/">rust</a> <a class="post-tag btn btn-outline-primary" href="/tags/computer-science/">Computer Science</a> <a class="post-tag btn btn-outline-primary" href="/tags/cncf/">cncf</a> <a class="post-tag btn btn-outline-primary" href="/tags/k8s/">k8s</a> <a class="post-tag btn btn-outline-primary" href="/tags/kubernetes/">kubernetes</a> <a class="post-tag btn btn-outline-primary" href="/tags/algorithm/">algorithm</a> <a class="post-tag btn btn-outline-primary" href="/tags/architecture/">Architecture</a></div></section></div><section id="toc-wrapper" class="d-none ps-0 pe-4"><h2 class="panel-heading ps-3 mb-2">Contents</h2><nav id="toc"></nav></section></aside></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 px-md-4"><aside id="related-posts" aria-labelledby="related-label"><h3 class="mb-4" id="related-label">Further Reading</h3><nav class="row row-cols-1 row-cols-md-2 row-cols-xl-3 g-4 mb-4"><article class="col"> <a href="/posts/k8s-introduction/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1750777740" data-df="ll" > Jun 25, 2025 </time><h4 class="pt-0 my-2">Kubernetes(Orchestration) 개론</h4><div class="text-muted"><p>오늘날, IT서비스를 구성할때, Kubernetes와 같은 Orchestration 환경을 기본으로 시작하게 됩니다. 여기서는, 이런 배경을 알아보고자 합니다. Kubernetes의 성장 배경 Kubernetes가 오늘날 처럼 인프라 운영의 핵심으로 자리 잡기 까지, 여러 배경이 있습니다. 더 빨라진 비지니스 변화 → 잦은 배포가 발생합니다....</p></div></div></a></article><article class="col"> <a href="/posts/k8s-workloads/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1752036600" data-df="ll" > Jul 9, 2025 </time><h4 class="pt-0 my-2">Workloads | Kubernetes Deep Dive - 4</h4><div class="text-muted"><p>Kubernetes는 Infra에 대한 추상화를 제공하는 Framework입니다. 이때, 가장 기본이 되는 추상화 단위가 ‘Pod(파드)’입니다. 이 Pod를 어떻게 다루느냐(Workload Management)에 따라, 한 단계 더 추상화된, ‘Deployments’, ‘ReplicaSet’, ‘DaemonSet’등의 Workload Object가...</p></div></div></a></article><article class="col"> <a href="/posts/k8s-data-plane/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1751632500" data-df="ll" > Jul 4, 2025 </time><h4 class="pt-0 my-2">Components - Data Plane(Node) | Kubernetes Deep Dive - 3</h4><div class="text-muted"><p>이번에는 Kubernetes에서 사용자의 Application이 돌아가는 ‘Data Plane(Node)’에서, Kubernetes 시스템을 위해 돌아가는 컴포넌트(Components)들을 알아보고자 합니다. Node와 Node의 컴포넌트들 Node에 대해서 컴포넌트들에 대해 이해하기에 앞서, Kubernetes에서 Node의 의미를 짚고 가고...</p></div></div></a></article></nav></aside><nav class="post-navigation d-flex justify-content-between" aria-label="Post Navigation"> <a href="/posts/k8s-philosophy/" class="btn btn-outline-primary" aria-label="Older" ><p>Kubernetes의 철학(Philosophy) | Kubernetes Deep Dive - 1</p></a> <a href="/posts/ChatGPT-API-Pricing-N-Bulk-Request/" class="btn btn-outline-primary" aria-label="Newer" ><p>ChatGPT API 비용최적화 및 Bulk요청 보내기 | Prompt Engineering</p></a></nav><script src="https://utteranc.es/client.js" repo="KanghoonYi/kanghoonyi.github.io" issue-term="pathname" crossorigin="anonymous" async ></script> <script type="text/javascript"> (function () { const origin = 'https://utteranc.es'; const lightTheme = 'github-light'; const darkTheme = 'github-dark'; let initTheme = lightTheme; const html = document.documentElement; if ( (html.hasAttribute('data-mode') && html.getAttribute('data-mode') === 'dark') || (!html.hasAttribute('data-mode') && window.matchMedia('(prefers-color-scheme: dark)').matches) ) { initTheme = darkTheme; } addEventListener('message', (event) => { let theme;if (event.origin === origin) {theme = initTheme; } else if (event.source === window && event.data && event.data.direction === ModeToggle.ID) {const mode = event.data.message; theme = mode === ModeToggle.DARK_MODE ? darkTheme : lightTheme; } else { return; } const message = { type: 'set-theme', theme: theme }; const utterances = document.getElementsByClassName('utterances-frame')[0].contentWindow; utterances.postMessage(message, origin); }); })(); </script><footer aria-label="Site Info" class=" d-flex flex-column justify-content-center text-muted flex-lg-row justify-content-lg-between align-items-lg-center pb-lg-3 " ><p>© <time>2026</time> <a href="https://github.com/KanghoonYi">KanghoonYi</a>. <span data-bs-toggle="tooltip" data-bs-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author." >Some rights reserved.</span></p><p>Using the <a data-bs-toggle="tooltip" data-bs-placement="top" title="v7.1.1" href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener" >Chirpy</a> theme for <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a>.</p></footer></div></div><div id="search-result-wrapper" class="d-flex justify-content-center d-none"><div class="col-11 content"><div id="search-hints"><section><h2 class="panel-heading">Trending Tags</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/programming/">programming</a> <a class="post-tag btn btn-outline-primary" href="/tags/aws/">aws</a> <a class="post-tag btn btn-outline-primary" href="/tags/leetcode/">leetcode</a> <a class="post-tag btn btn-outline-primary" href="/tags/rust/">rust</a> <a class="post-tag btn btn-outline-primary" href="/tags/computer-science/">Computer Science</a> <a class="post-tag btn btn-outline-primary" href="/tags/cncf/">cncf</a> <a class="post-tag btn btn-outline-primary" href="/tags/k8s/">k8s</a> <a class="post-tag btn btn-outline-primary" href="/tags/kubernetes/">kubernetes</a> <a class="post-tag btn btn-outline-primary" href="/tags/algorithm/">algorithm</a> <a class="post-tag btn btn-outline-primary" href="/tags/architecture/">Architecture</a></div></section></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><aside aria-label="Scroll to Top"> <button id="back-to-top" type="button" class="btn btn-lg btn-box-shadow"> <i class="fas fa-angle-up"></i> </button></aside></div><div id="mask"></div><script src="https://cdn.jsdelivr.net/combine/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js,npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.umd.min.js,npm/glightbox@3.3.0/dist/js/glightbox.min.js,npm/clipboard@2.0.11/dist/clipboard.min.js,npm/dayjs@1.11.13/dayjs.min.js,npm/dayjs@1.11.13/locale/en.js,npm/dayjs@1.11.13/plugin/relativeTime.js,npm/dayjs@1.11.13/plugin/localizedFormat.js,npm/tocbot@4.29.0/dist/tocbot.min.js"></script> <script src="/assets/js/dist/post.min.js"></script> <script src="/assets/js/data/mathjax.js"></script> <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script> <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-chtml.js"></script> <script>SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<article class="px-1 px-sm-2 px-lg-4 px-xl-0"><header><h2><a href="{url}">{title}</a></h2><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div></header><p>{snippet}</p></article>', noResultsText: '<p class="mt-5">Oops! No results found.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="me-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
