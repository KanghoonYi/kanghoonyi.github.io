<!doctype html><html lang="ko" data-mode="light"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" ><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="Redis Key Technologies - System Design Interview" /><meta name="author" content="KanghoonYi(pour)" /><meta property="og:locale" content="ko" /><meta name="description" content="Redis 소개" /><meta property="og:description" content="Redis 소개" /><link rel="canonical" href="https://blog.devpour.net/posts/Redis/" /><meta property="og:url" content="https://blog.devpour.net/posts/Redis/" /><meta property="og:site_name" content="KanghoonYi(Pour)" /><meta property="og:image" content="https://blog.devpour.net/assets/img/for-post/Redis/redis-cover.jpg" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2025-08-04T18:57:00+09:00" /><meta name="twitter:card" content="summary_large_image" /><meta property="twitter:image" content="https://blog.devpour.net/assets/img/for-post/Redis/redis-cover.jpg" /><meta property="twitter:title" content="Redis Key Technologies - System Design Interview" /><meta name="google-site-verification" content="rsx_-5MJzSR_3NNCqHNe9IxnKJxlD8Eid8_wN8e9c1I" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"KanghoonYi(pour)","url":"https://www.linkedin.com/in/pour/"},"dateModified":"2025-08-04T22:12:32+09:00","datePublished":"2025-08-04T18:57:00+09:00","description":"Redis 소개","headline":"Redis Key Technologies - System Design Interview","image":"https://blog.devpour.net/assets/img/for-post/Redis/redis-cover.jpg","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.devpour.net/posts/Redis/"},"url":"https://blog.devpour.net/posts/Redis/"}</script><title>Redis | Key Technologies - System Design Interview | KanghoonYi(Pour)</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="KanghoonYi(Pour)"><meta name="application-name" content="KanghoonYi(Pour)"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="/assets/css/jekyll-theme-chirpy.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.6.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.29.0/dist/tocbot.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/glightbox@3.3.0/dist/css/glightbox.min.css"><body><aside aria-label="Sidebar" id="sidebar" class="d-flex flex-column align-items-end"><header class="profile-wrapper"> <a href="/" id="avatar" class="rounded-circle"><img src="/assets/img/pour_profile_img.png" width="112" height="112" alt="avatar" onerror="this.style.display='none'"></a><h1 class="site-title"> <a href="/">KanghoonYi(Pour)</a></h1><p class="site-subtitle fst-italic mb-0">안녕하세요~ Software Engineer pour입니다 This is Pour.</p></header><nav class="flex-column flex-grow-1 w-100 ps-0"><ul class="nav"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle"></i> <span>ABOUT</span> </a></ul></nav><div class="sidebar-bottom d-flex flex-wrap align-items-center w-100"> <a href="https://github.com/KanghoonYi" aria-label="github" target="_blank" rel="noopener noreferrer" > <i class="fab fa-github"></i> </a> <a href="https://twitter.com/" aria-label="twitter" target="_blank" rel="noopener noreferrer" > <i class="fa-brands fa-x-twitter"></i> </a> <a href="javascript:location.href = 'mailto:' + ['rkdgnsdls','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></aside><div id="main-wrapper" class="d-flex justify-content-center"><div class="container d-flex flex-column px-xxl-5"><header id="topbar-wrapper" aria-label="Top Bar"><div id="topbar" class="d-flex align-items-center justify-content-between px-lg-3 h-100" ><nav id="breadcrumb" aria-label="Breadcrumb"> <span> <a href="/">Home</a> </span> <span>Redis | Key Technologies - System Design Interview</span></nav><button type="button" id="sidebar-trigger" class="btn btn-link"> <i class="fas fa-bars fa-fw"></i> </button><div id="topbar-title"> Post</div><button type="button" id="search-trigger" class="btn btn-link"> <i class="fas fa-search fa-fw"></i> </button> <search id="search" class="align-items-center ms-3 ms-lg-0"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..." > </search> <button type="button" class="btn btn-link text-decoration-none" id="search-cancel">Cancel</button></div></header><div class="row flex-grow-1"><main aria-label="Main Content" class="col-12 col-lg-11 col-xl-9 px-md-4"><article class="px-1"><header><h1 data-toc-skip>Redis | Key Technologies - System Design Interview</h1><div class="post-meta text-muted"> <span> Posted <time data-ts="1754301420" data-df="ll" data-bs-toggle="tooltip" data-bs-placement="bottom" > Aug 4, 2025 </time> </span> <span> Updated <time data-ts="1754313152" data-df="ll" data-bs-toggle="tooltip" data-bs-placement="bottom" > Aug 4, 2025 </time> </span><div class="mt-3 mb-3"> <a href="/assets/img/for-post/Redis/redis-cover.jpg" class="popup img-link preview-img shimmer"><img src="/assets/img/for-post/Redis/redis-cover.jpg" alt="Preview Image" width="1200" height="630" loading="lazy"></a></div><div class="d-flex justify-content-between"> <span> By <em> <a href="https://www.linkedin.com/in/pour/">KanghoonYi(pour)</a> </em> </span><div> <span class="readtime" data-bs-toggle="tooltip" data-bs-placement="bottom" title="5034 words" > <em>27 min</em> read</span></div></div></div></header><div class="content"><h2 id="redis-소개"><span class="me-2">Redis 소개</span><a href="#redis-소개" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><blockquote><p>Redis is the world’s fastest in-memory database. - from <a href="https://redis.io/about/">redis.io</a></p></blockquote><dl><dt>Redis는<dd>C로 작성된, 오픈소스 in-memory key-value 저장소 입니다.(데이터를 Disk가 아닌 RAM에 저장하여 사용합니다.)<dd>빠른 속도와 다양한 자료구조(Data structure)를 지원하는, NoSQL DB입니다.<dd>String, List, Hash, Set, Sorted Set, 비트맵, HyperLogLog 등 다양한 자료구조(Data Structure)를 지원합니다.</dl><blockquote class="prompt-info"><p>NoSQL은 기존에 많이 쓰이던, 관계형(SQL) DB가 아닌것을 의미합니다.<br /> 관계형 DB와 다르게, 더 유연한 데이터 모델과 확장성을 제공합니다.</p></blockquote><blockquote class="prompt-info"><p>만약 데이터 저장 과정에서, Durability(영속성)이 더 중요하다면, Redis는 적합하지 않습니다.<br /> Redis가 AOF(Append-Only File)을 통해, Data의 Persistent를 지원하고 있지만, 이는 RDB의 것만큼 보장(guarantee)해주지 못해기 때문입니다.<br /> 단, AWS의 Memory DB와 같은 대안도 가능합니다.</p></blockquote><h3 id="redis는-key-value-store입니다"><span class="me-2">Redis는 Key-Value Store입니다.</span><a href="#redis는-key-value-store입니다" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><a href="/assets/img/for-post/Redis/redis-1.png" class="popup img-link shimmer"><img src="/assets/img/for-post/Redis/redis-1.png" alt="redis-1.png" loading="lazy"></a></p><p>Redis는 Key-Value 저장소 입니다.<br /> Key는 반드시 ‘String’이어야 하며, Value는 Redis가 지원하는 데이터 구조(binary data and strings, sets, lists, hashes, sorted sets 등)는 모두 가능합니다.<br /> 또한, Redis안에서의 모든 object들은 Key를 갖고 있어야 합니다.</p><h3 id="redis의-value-type"><span class="me-2">Redis의 Value Type</span><a href="#redis의-value-type" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><a href="/assets/img/for-post/Redis/image.png" class="popup img-link shimmer"><img src="/assets/img/for-post/Redis/image.png" alt="Redis의 Value Type 및 구현 Algorithm" loading="lazy"></a> <em>Redis의 Value Type 및 구현 Algorithm | from <a href="https://blog.bytebytego.com/p/a-crash-course-in-redis">blog.bytebytego.com</a></em></p><p><br /></p><h2 id="redis의-single-thread와-성능"><span class="me-2">Redis의 Single Thread와 성능</span><a href="#redis의-single-thread와-성능" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Redis는 <strong>단일 스레드(Single Thread)</strong> 구조임에도 불구하고, <strong>수십만 RPS(requests per second)</strong> 를 처리할 수 있을 정도로 매우 빠릅니다.<br /> 여기서는, 이것이 가능한 이유를 살펴보고자 합니다.</p><blockquote class="prompt-info"><p>Redis 6부터는 I/O(read/write) 에 일부 멀티스레드가 도입되었습니다.<br /> 클라이언트 요청을 읽어오거나 응답을 보내는 작업은 멀티스레드 가능하지만, <strong>명령(Command)실행 자체는 여전히 Single Thread</strong>로 작동합니다.</p></blockquote><h3 id="ram-기반-처리"><span class="me-2">RAM 기반 처리</span><a href="#ram-기반-처리" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>모든 데이터는 디스크가 아닌, RAM에 저장되어 있기 때문에, I/O 병목이 거의 없습니다.<br /> 즉, 디스크 → 메모리로 데이터를 불러오는 비용이 들지않고, 즉시 데이터를 이용한 연산이 가능합니다.</p><h3 id="lock-경합race-condition-없음"><span class="me-2">Lock 경합(Race Condition) 없음</span><a href="#lock-경합race-condition-없음" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><a href="/assets/img/for-post/Redis/image%201.png" class="popup img-link w-50 shimmer"><img src="/assets/img/for-post/Redis/image%201.png" alt="Lock Race Condition을 표현하는 이미지" loading="lazy"></a> <em>Lock Race Condition을 표현하는 이미지</em></p><p>Redis는 Single Thread를 사용해서, 여러 Thread간의 동시성 문제를 위해 Lock을 사용할 필요가 없습니다.(애초에 Single Thread이기 때문에)</p><p><a href="/assets/img/for-post/Redis/image%202.png" class="popup img-link w-50 shimmer"><img src="/assets/img/for-post/Redis/image%202.png" alt="CPU의 Context Switching을 비유적으로 표현하는 이미지" loading="lazy"></a> <em>CPU의 Context Switching을 비유적으로 표현하는 이미지</em></p><p>이는 ‘Context Switching(CPU Level에서의 작업 전환)’ 비용과 ‘Lock Condition Race’(Lock을 얻기 위한 경합)을 완전히 제거해줍니다.<br /> 이를 통해, 훨씬 예측 가능하고 빠른 처리 시간을 제공합니다.</p><h3 id="epoll-기반-비동기-이벤트-처리"><span class="me-2">Epoll 기반 비동기 이벤트 처리</span><a href="#epoll-기반-비동기-이벤트-처리" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Redis는 <strong>리눅스 epoll을 사용</strong>해 수천 개의 클라이언트 연결을 하나의 이벤트 루프에서 효율적으로 처리합니다.</p><p><a href="/assets/img/for-post/Redis/image%203.png" class="popup img-link shimmer"><img src="/assets/img/for-post/Redis/image%203.png" alt="Linux Epoll의 역할을 보여주는 이미지" loading="lazy"></a></p><p><em>Linux Epoll의 역할을 보여주는 이미지 | <a href="https://devarea.com/linux-io-multiplexing-select-vs-poll-vs-epoll/">devarea.com</a></em></p><dl><dt>‘epoll’은<dd>수많은 파일 디스크립터(FD)(예: 클라이언트 소켓)의 입출력 가능 상태(I/O readiness) 를 효율적으로 감시합니다.<dd>이벤트가 발생한 것만 알려주는 고성능 커널 기능입니다.</dl><p>이벤트가 없는 Connection은 무시하고, 이벤트가 발생한 소켓만 처리하여, 매우 빠른 성능을 보여줍니다.</p><blockquote class="prompt-info"><p>‘Epoll’은 시스템 콜로 호출되는 커널 기능입니다. 이 또한 Redis의 Single Thread에서 작동합니다</p></blockquote><h3 id="command가-단순하고-작다"><span class="me-2">‘Command’가 단순하고 작다.</span><a href="#command가-단순하고-작다" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Redis에서 사용하는 명령어는, 대부분 매우 가볍습니다.(GET, SET, INCR 등은 O(1) 또는 O(log N) 수준의 처리 시간.)<br /> Redis 내부 데이터 구조가 최적화되어 있어 탐색, 삽입, 정렬 등에 강력한 성능을 보여줍니다.</p><h3 id="c언어-기반"><span class="me-2">C언어 기반</span><a href="#c언어-기반" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Redis는 C언어로 개발되어 있어, 운영체제와 매우 가까운, 저수준에서 동작합니다.<br /> 즉, 별도의 VM없이 실행되어 메모리와 CPU사용을 최적화 하였습니다.</p><p><br /></p><h2 id="redis의-infra-구성-방법들"><span class="me-2">Redis의 Infra 구성 방법들</span><a href="#redis의-infra-구성-방법들" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><a href="/assets/img/for-post/Redis/image%204.png" class="popup img-link shimmer"><img src="/assets/img/for-post/Redis/image%204.png" alt="Redis의 Infra Architecture의 변화" loading="lazy"></a> <em>Redis의 Infra Architecture의 변화 | <a href="https://bytebytego.com/guides/how-redis-architecture-evolve/">bytebytego.com</a></em></p><p>Redis는 기본적으로 Single Node로 동작할 수 있지만, HA(High Availability)를 위해 Replica나 Cluster형태로도 구성 가능합니다.</p><h3 id="redis-cluster"><span class="me-2">Redis Cluster</span><a href="#redis-cluster" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><a href="/assets/img/for-post/Redis/redis-2.png" class="popup img-link shimmer"><img src="/assets/img/for-post/Redis/redis-2.png" alt="Redis Cluster와 Key분배" loading="lazy"></a> <em>Redis Cluster와 Key분배</em></p><h4 id="gossip-protocol"><span class="me-2">Gossip Protocol</span><a href="#gossip-protocol" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p><a href="/assets/img/for-post/Redis/image%205.png" class="popup img-link shimmer"><img src="/assets/img/for-post/Redis/image%205.png" alt="Redis Cluster와 gossip protocol" loading="lazy"></a> <em>Redis Cluster와 gossip protocol</em></p><dl><dt>‘gossip protocol’은<dd>Redis Cluster 환경에서 <strong>노드 간 상태 정보를 전파(synchronize)</strong> 하는 데 사용되는 <strong>간단하고 효율적인 통신 프로토콜</strong>입니다.<dd>클러스터의 각 노드들이 서로의 상태 정보를 주기적으로 교환하면서, 장애 감지, 노드 변경 전파, 뷰 일관성 유지 등을 가능하게 해주는 경량 분산 통신 방식입니다.</dl><blockquote class="prompt-info"><p>Q: 왜 ‘gossip’ protocol이라고 부르나요?<br /> A: Node간 데이터를 주고받는 방식이, 마치 사람들이 소문을 주고받는 것처럼, 일부 정보만 여러 노드 간에 점진적으로 퍼지기 때문입니다.<br /> ex) “노드 X가 다운된 것 같아” → Y가 듣고 Z에게 전파</p></blockquote><h4 id="hash-slot"><span class="me-2">Hash Slot</span><a href="#hash-slot" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Redis Cluster로 구성한다면, ‘Hash Slot’이라는 개념을 사용하게 됩니다.</p><dl><dt>‘Hash Slot’은<dd>Cluster에서 데이터를 분산저장하는 Sharding의 최소 단위입니다.<dd>데이터의 Key값과 Node를 맵핑(mapping)해줍니다.<dd>키를 어느 노드에 저장할지를 결정하는 데 사용되는 <strong>고정된 범위(0 ~ 16383)의 해시 공간</strong>입니다.<dd>만약 구성 Node의 변경이 있다면, Hash Slot단위로 Node에 재분배됩니다.(키 단위가 아닌 “슬롯 단위”로 이동되므로 성능과 일관성 측면에서 유리합니다.)<dd>Redis Client는 이 ‘Hash Slot’을 Caching하여, Key값에 따라 해당 Key를 갖고 있는 Node에 바로 접속합니다.</dl><p><br /></p><h2 id="redis가-consistency를-보장하는-방법"><span class="me-2">Redis가 Consistency를 보장하는 방법</span><a href="#redis가-consistency를-보장하는-방법" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="single-thread를-기반으로-명령어를-원자적으로-처리"><span class="me-2">Single Thread를 기반으로 명령어를 원자적으로 처리</span><a href="#single-thread를-기반으로-명령어를-원자적으로-처리" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><a href="/assets/img/for-post/Redis/image%206.png" class="popup img-link shimmer"><img src="/assets/img/for-post/Redis/image%206.png" alt="여러 Client 요청을 처리하는 단일 Redis Instance" loading="lazy"></a> <em>여러 Client 요청을 처리하는 단일 Redis Instance</em></p><p>Redis 서버 프로세스는 단일 스레드로 동작하기 때문에, 들어오는 모든 명령이 순서대로(serialized) 처리됩니다.<br /> 덕분에 하나의 명령(command) 은 실행 중 중단되지 않으며, 원자성(Atomicity) 을 자연스럽게 보장합니다.</p><blockquote class="prompt-info"><p>단, Redis 6부터, ‘클라이언트 소켓 읽기/쓰기’, ‘명령을 실행하기 전/후의 버퍼 작업’에 대해서 멀티쓰레드 I/O가 도입되었습니다.</p></blockquote><blockquote class="prompt-info"><p>Epoll?<br /> epoll은 Linux 커널에서 제공하는 고성능 I/O 이벤트 통지 메커니즘입니다.<br /> 수많은 파일 디스크립터(FD)(예: 클라이언트 소켓)의 입출력 가능 상태(I/O readiness) 를 효율적으로 감시하고, 이벤트가 발생한 것만 알려주는 고성능 커널 기능입니다.</p></blockquote><h3 id="replication에서는-eventual-consistency사용"><span class="me-2">Replication에서는 Eventual Consistency사용</span><a href="#replication에서는-eventual-consistency사용" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>기본적으로 Redis는 Primary에서 처리된 쓰기 작업을 Replica에게 비동기적으로 전파합니다.<li>이론적으로, 마스터에 쓰기가 완료된 직후 장애가 나면 일부 업데이트가 슬레이브에 전파되지 않을 수 있어, <strong>최종 일관성(Eventual Consistency)</strong> 을 따릅니다.</ul><h3 id="cluster에서의-consistency"><span class="me-2">Cluster에서의 Consistency</span><a href="#cluster에서의-consistency" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><a href="/assets/img/for-post/Redis/image%207.png" class="popup img-link shimmer"><img src="/assets/img/for-post/Redis/image%207.png" alt="Cluster로 구성된 Redis" loading="lazy"></a> <em>Cluster로 구성된 Redis</em></p><ul><li>Redis Cluster는 데이터를 16,384개의 <strong>해시 슬롯(hash slot)</strong> 으로 분산 저장합니다.(Sharding)(Cluster가 하나의 instance처럼 작동)<li><strong>샤드 간 트랜잭션</strong>을 지원하지 않으며, <strong>하나의 키에 대한 연산은 항상 그 키를 소유한 노드(master)에서 처리</strong>됩니다.<li>클러스터 구성원 간 복제는 마스터–슬레이브 모델을 따르므로, 기본적으로 <strong>비동기 복제</strong>에 따른 최종 일관성을 제공합니다.</ul><h2 id="redis의-persistence"><span class="me-2">Redis의 Persistence</span><a href="#redis의-persistence" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><a href="/assets/img/for-post/Redis/durable-redis-1.png" class="popup img-link shimmer"><img src="/assets/img/for-post/Redis/durable-redis-1.png" alt="Redis에서, 'Persistence를 위한 기능들'의 작동 방식" loading="lazy"></a> <em>Redis에서, ‘Persistence를 위한 기능들’의 작동 방식 | from <a href="https://redis.io/technology/durable-redis/">redis.io</a></em></p><blockquote><p>Redis can persist your data either by periodically dumping the dataset to disk or by appending each command to a disk-based log.<br /> - from <a href="https://redis.io/about/">redis.io</a></p></blockquote><dl><dt>Redis에서는 Data를 보존하기 위해,<dd>정기적으로 Disk에 데이터를 쓰거나(periodically dumping the dataset to disk)<dd>각각의 Command를 Disk기반의 Log에 기록하는(appending each command to a disk-based log)</dl><p>방법을 사용합니다.</p><h3 id="정기적으로-disk에-데이터를-쓰기rdb파일로-쓰기"><span class="me-2">정기적으로 Disk에 데이터를 쓰기(rdb파일로 쓰기)</span><a href="#정기적으로-disk에-데이터를-쓰기rdb파일로-쓰기" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>지정된 시점(snapshot)의 메모리 데이터를 통째로 덤프해서 .rdb 파일로 저장하는 방식을 말합니다.</p><h3 id="각각의-command를-disk기반의-log에-기록하기aof"><span class="me-2">각각의 Command를 Disk기반의 Log에 기록하기(AOF)</span><a href="#각각의-command를-disk기반의-log에-기록하기aof" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Redis에서 실행된 모든 쓰기 명령을 순차적으로 로그 파일에 기록하는 방식입니다.<br /> AOF 파일은 계속 커지므로, 주기적으로 <strong>압축 및 재작성</strong>이 필요합니다.<br /> Redis는 자동으로 ‘BGREWRITEAOF(AOF최적화 명려어)’를 수행해 오래된 명령을 요약합니다.</p><h3 id="rdb와-aof조합-방법"><span class="me-2">rdb와 AOF조합 방법</span><a href="#rdb와-aof조합-방법" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>RDB만 사용: 단순하고 빠른 복구가 필요한 경우에 사용합니다.<li>AOF만 사용: 안정성이 중요한 경우에 사용합니다.<li>RDB + AOF 함께 사용<br /> 대부분의 실무 환경에서 추천됩니다.<br /> 이 경우, 복구 시 AOF가 더 최신이면 AOF 우선으로 사용합니다.(AOF를 더 신뢰)</ul><h2 id="redis와-memcached"><span class="me-2">Redis와 Memcached</span><a href="#redis와-memcached" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Redis와 Memcached는 모두 <strong>인메모리 기반의 캐시 시스템</strong>이지만, 목적과 기능 측면에서 다음과 같은 차이점이 있습니다.</p><h3 id="데이터-구조"><span class="me-2"><strong>데이터 구조</strong></span><a href="#데이터-구조" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><strong>Redis</strong>는 리스트, 해시, 셋, 정렬셋 등 다양한 구조를 제공 → 큐, 랭킹, 통계에 유용합니다.<li><strong>Memcached</strong>는 단순한 문자열 key-value 구조 → 복잡한 로직은 애플리케이션에서 직접 구현해야 합니다.</ul><h3 id="persistence-데이터-보존"><span class="me-2"><strong>Persistence (데이터 보존)</strong></span><a href="#persistence-데이터-보존" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><strong>Redis</strong>는 RDB(rdb파일로 저장)/AOF(Append-Only File) 방식으로 디스크에 데이터를 저장 가능하며, 이를 통해 장애 후 복구가 가능합니다.<li><strong>Memcached</strong>는 서버 재시작 시 모든 데이터가 사라집니다.</ul><h3 id="분산성과-고가용성"><span class="me-2"><strong>분산성과 고가용성</strong></span><a href="#분산성과-고가용성" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>Redis는 Sentinel, Cluster 등을 통해 <strong>자동 failover</strong> 와 <strong>수평 확장</strong>이 가능합니다.<li>Memcached는 클라이언트 단에서 key hashing을 통해 수동 샤딩(consistent hashing)을 구현해야 합니다.</ul><h3 id="pubsub-기능"><span class="me-2"><strong>Pub/Sub 기능</strong></span><a href="#pubsub-기능" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>Redis는 채널 기반 메시지 전달 기능(Pub/Sub)을 제공하여 실시간 이벤트 알림 등에 사용 가능합니다.<li>Memcached는 이런 기능 없이, 단순 Cache용도로 사용합니다.</ul><h3 id="요약"><span class="me-2">요약</span><a href="#요약" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><dl><dt>‘Memcached’는<dd>가볍고 빠른, 단순 캐시용으로 사용하고,<dt>‘Redis’는<dd>다기능 인메모리 데이터 플랫폼으로 사용합니다.</dl><p><br /></p><h2 id="redis-사용-방법들"><span class="me-2">Redis 사용 방법들</span><a href="#redis-사용-방법들" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="redis-as-a-cache"><span class="me-2">Redis as a Cache</span><a href="#redis-as-a-cache" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><a href="/assets/img/for-post/Redis/image%208.png" class="popup img-link shimmer"><img src="/assets/img/for-post/Redis/image%208.png" alt="image.png" loading="lazy"></a> <em>Redis를 Cache로 사용할때의 Flow</em></p><p>Redis를 Cache로 사용하는것은 가장 흔하게 사용되는 사례중 하나입니다.</p><dl><dt>Redis를 Cache로 사용할때는,<dd>각 key에 대해 TTL(Time-to-live)를 설정합니다.(이는 Redis가 데이터를 관리하는 방법을 가이드 해주는 역할을 합니다.)</dl><blockquote class="prompt-info"><p>Cache용도로 Redis를 사용하다 보면, ‘Hot key’문제에 부딪히게 되는데, 이는 뒤에서 다루려고 합니다.</p></blockquote><h3 id="redis-as-a-distributed-lock"><span class="me-2">Redis as a Distributed Lock</span><a href="#redis-as-a-distributed-lock" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>‘Distributed Lock’으로 Redis를 사용하는것 또한 가장 흔한 사례중 하나입니다.<br /> 만약 System에서, ‘Ticket 구매’와 같이 ‘Strong Consistency’가 필요한 경우, Redis를 사용하여 Lock을 구현할 수 있습니다.</p><blockquote class="prompt-info"><p>만약, 사용하고 있는 DB레벨에서 이미 Consistency를 제공하고 있다면, 해당 기능을 쓰는게 좋습니다. Redis를 통해 Lock을 구현하면, 불필요하게 복잡도를 높이게 됩니다.</p></blockquote><p>Redis를 이용하여 ‘Distributed Lock(분산 Lock)’을 구현하는 알고리즘 및 프로토콜로 ‘Redlock’이 있습니다.</p><h3 id="redis-for-leaderboards"><span class="me-2">Redis for LeaderBoards</span><a href="#redis-for-leaderboards" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Redis의 ‘sorted set’데이터 타입은 정렬된 데이터를 제공해주며, $log(N)$시간의 Query응답을 제공해줍니다.<br /> 이는 LeaderBoard App에 적합한 스펙입니다.<br /> 만약 LeaderBoard와 같이, Write throughput은 높고, Read Latency는 낮아야 하는 경우를 SQL DB로 대응하려고 하면, 꽤나 힘들겁니다.</p><h3 id="redis-for-rate-limiting"><span class="me-2">Redis for Rate Limiting</span><a href="#redis-for-rate-limiting" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Rate Limiting은 특정 클라이언트가 지나치게 많은 요청을 보내지 못하도록 제한하는 기법입니다.</p><dl><dt>Redis는<dd>고속의 in-memory 연산 + TTL 기능 + 원자적 연산을 제공하기 때문에, ‘Rate Limiting’용으로 사용할 수 있습니다.<dd>카운터 기반, 토큰 버킷, 슬라이딩 윈도우 등 다양한 알고리즘으로 지원할 수 있습니다.</dl><p><a href="https://redis.io/learn/howtos/ratelimiting">How to build a Rate Limiter using Redis</a></p><h3 id="redis-for-proximity-search근접-검색-예-위치-기반-검색-또는-유사-단어-검색"><span class="me-2">Redis for Proximity Search(근접 검색, 예: 위치 기반 검색 또는 유사 단어 검색)</span><a href="#redis-for-proximity-search근접-검색-예-위치-기반-검색-또는-유사-단어-검색" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Redis는 기본적으로 전통적인 RDBMS의 공간 인덱스(GIS) 나 벡터 검색 엔진은 아니지만, 몇 가지 기능을 조합하여 근접 검색을 구현할 수 있습니다.</p><p><a href="https://redis.io/learn/howtos/solutions/geo/getting-started">Getting Started With Geo Location Search in Redis</a></p><p>‘Proximity Search에는 2가지 맥락이 있는데, ‘지리적 근접 검색’과 ‘유사 문자열 검색’이 그것입니다.</p><h4 id="redis-geo-기능으로-위치-기반-proximity-search"><span class="me-2">Redis GEO 기능으로 위치 기반 Proximity Search</span><a href="#redis-geo-기능으로-위치-기반-proximity-search" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Redis는 GEOADD, GEORADIUS, GEODIST, GEOPOS 등의 명령어로 <strong>지리 정보(위도, 경도)</strong>를 저장하고 검색할 수 있습니다.<br /> 내부적으로는 Geohash + Sorted Set으로 구현되어 있습니다.</p><h4 id="문자열-유사성-기반-proximity-search"><span class="me-2">문자열 유사성 기반 Proximity Search</span><a href="#문자열-유사성-기반-proximity-search" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Redis 자체적으로 지원하지는 않고, <a href="https://github.com/RediSearch/RediSearch">RediSearch</a> 모듈을 통해 구현할 수 있습니다.<br /> ‘RediSearch’는 텍스트 인덱싱, 검색, 유사 단어 매칭, <strong>벡터 검색 (ANN)</strong> 까지도 지원합니다.</p><h3 id="redis-for-event-sourcing"><span class="me-2">Redis for Event Sourcing</span><a href="#redis-for-event-sourcing" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Redis 5.0부터 추가된 데이터 구조인 ‘Stream’을 통해, ‘Event Sourcing’패턴을 구현할 수 있습니다.</p><p><a href="/assets/img/for-post/Redis/redis-3.png" class="popup img-link shimmer"><img src="/assets/img/for-post/Redis/redis-3.png" alt="Redis streams and consumer groups" loading="lazy"></a> <em>Redis streams and consumer groups | <a href="https://www.hellointerview.com/learn/system-design/deep-dives/redis#redis-for-event-sourcing">hellointerview.com</a></em></p><dl><dt>‘Event Sourcing’은<dd>상태를 저장하는 대신, 모든 변경 이벤트의 로그(event stream)를 기록해서, 나중에 그 이벤트들을 재생(replay)하여 현재 상태를 만들어내는 아키텍처 패턴입니다.<dt>‘Redis Stream’은<dd>‘Append-only Log’처럼 작동하는 자료구조입니다.<dd>시간 순서대로, Log형식으로 데이터를 저장합니다.<dd>내부적으로는 Kafka의 topic-like 구조와 매우 유사하며, ID 순 정렬, 범위 조회, consumer group 처리 등이 가능합니다.</dl><p>때문에 ‘Stream’을 통해 ‘Event Sourcing’을 구현할 수 있으며, 메모리 기반이라 매우 빠른 성능을 제공해줍니다.(Redis 특성에서 오는 데이터 유실 가능성이 있음.)</p><h3 id="redis-for-pubsub"><span class="me-2">Redis for Pub/Sub</span><a href="#redis-for-pubsub" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><a href="/assets/img/for-post/Redis/image%209.png" class="popup img-link shimmer"><img src="/assets/img/for-post/Redis/image%209.png" alt="Redis Pub/Sub" loading="lazy"></a> <em>Redis Pub/Sub | from <a href="https://www.geeksforgeeks.org/system-design/redis-publish-subscribe/">geeksforgeeks.org</a></em></p><p>Redis는 자체적으로 ‘publish/subscribe(Pub/Sub)’ Messaging pattern을 지원하며, 메시지 브로커처럼 채널 기반으로 메시지를 전달하는 기능입니다.<br /> 이는 주로 Chat System이나 실시간 Notification 혹은 ‘Message생산자와 소비자를 decouple하는 시나리오’에서 사용됩니다.</p><blockquote class="prompt-info"><p>Redis는, Pub/Sub에 대해서도 sharding을 지원합니다. (Redis 구버전에서는 불가)</p></blockquote><p><strong>장점</strong></p><ul><li>메모리 기반이라 초 저지연 메세징 기능을 제공합니다.<li>간단한 설정으로 바로 사용할 수 있습니다.<li>Pub/Sub Client는 Redis Cluster를 구성하는 각 Node마다 하나의 Connection을 사용합니다.<br /> Pub/Sub Channel마다 하나씩 쓰는게 아니라서, 커넥션 사용을 최소화할 수 있습니다.</ul><p><strong>단점</strong></p><ul><li><p>메세지 영속성(Persistence)이 없습니다.<br /> Subscriber가 연결되어 있지 않으면, 메시지는 버려집니다.</p><li><p>큐(queue) 가 아닌, 모든 구독자에게 동시에 전달하는 ‘Broadcast’구조입니다.</p></ul><p><br /></p><h2 id="redis의-단점과-개선방법"><span class="me-2">Redis의 단점과 개선방법</span><a href="#redis의-단점과-개선방법" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="hot-key-issues"><span class="me-2">Hot Key Issues</span><a href="#hot-key-issues" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><a href="/assets/img/for-post/Redis/redis-4.png" class="popup img-link shimmer"><img src="/assets/img/for-post/Redis/redis-4.png" alt="Redis Cluster에서 0-100범위에 대해 Hot Key Issue가 발생" loading="lazy"></a> <em>Redis Cluster에서 0-100범위에 대해 Hot Key Issue가 발생 | from <a href="https://www.hellointerview.com/learn/system-design/deep-dives/redis#redis-for-event-sourcing">hellointerview.com</a></em></p><dl><dt>‘Hot Key Issues’는<dd>특정 키(key)에 과도하게 많은 요청이 집중되어 시스템의 성능 저하 또는 병목이 발생하는 문제를 말합니다.<dd>Redis의 특정 key에 트래픽이 몰리면서 해당 key와 연관된 노드나 자원이 비정상적으로 과부하 되는 문제입니다.</dl><p>Redis는 기본적으로 <strong>단일 스레드 기반이기 때문</strong>에, 하나의 key에 너무 많은 명령이 몰리면 그 key를 포함한 처리 루프 전체가 지연될 수 있습니다.<br /> 만약 Cluster환경이라면, 해당 key가 할당된 해시 슬롯(slots)이 포함된 특정 노드에만 부하가 집중될 수 있으며, 이는 노드간 불균형(CPU, 메모리, 네트워크 I/O에 대한)을 초래합니다.</p><h4 id="해결-방법"><span class="me-2">해결 방법</span><a href="#해결-방법" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>Client level에서 In-memory Cache를 추가하여, Redis에 너무 많은 요청이 발생하지 않도록 합니다.<li>Redis에서 사용하는 Key에 Random number를 추가하여, 여러 Node에 걸쳐서 데이터가 분산되도록 합니다. (Key Sharding)<br /> 예: “rank:global” → “rank:global:shard1”, “rank:global:shard2”</ul><h3 id="big-key-issues"><span class="me-2">Big Key Issues</span><a href="#big-key-issues" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><dl><dt>Big Key Issue란,<dd>Redis의 단일 key가 너무 많은 요소(예: 리스트, 해시, 셋 등)를 가지고 있어서, 해당 key에 대한 연산이 느려지거나 전체 Redis 인스턴스에 영향을 주는 문제입니다.<dd>key 자체가 크다는 의미가 아니라, 하나의 key에 저장된 데이터가 지나치게 많은 경우를 말합니다.</dl><blockquote class="prompt-info"><p>‘Big Key’에 대한 정의 및 평가 기준은 실제 사용 및 애플리케이션의 특정 요구 사항에 따라 달라질 수 있습니다.<br /> 예를 들어, 높은 동시성 및 낮은 지연 시간 시나리오에서는 10KB의 키만 빅 키로 간주될 수 있습니다. 그러나 낮은 동시성 및 고용량 환경에서는 빅 키의 임계값이 약 100KB일 수 있습니다</p></blockquote><h4 id="해결-방법-1"><span class="me-2">해결 방법</span><a href="#해결-방법-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li><p>Key를 나눕니다.(Sharding / Chunking)<br /> 큰 리스트를 “chat:room:123:page:1”, “chat:room:123:page:2” 처럼 분할합니다.</p><li>Key에 대한 전체 연산은 피합니다.<li>문자열 data인 경우, 압축을 고려합니다.</ul><h2 id="references"><span class="me-2">References</span><a href="#references" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><dl><dt>Redis | hellointerview.com<dd><a href="https://www.hellointerview.com/learn/system-design/deep-dives/redis">Hello Interview | System Design in a Hurry</a><dt>Redis About | redis.io<dd><a href="https://redis.io/about/">About - Redis</a><dt>Redis Distributed Caching | redis.io<dd><a href="https://redis.io/glossary/distributed-caching/">Distributed Caching</a><dt>Redis Cluster Architecture | redis.io<dd><a href="https://redis.io/technology/redis-enterprise-cluster-architecture/">Redis Cluster Architecture | Redis Enterprise</a><dt>Three Ways to Maintain Cache Consistency | redis.io<dd><a href="https://redis.io/blog/three-ways-to-maintain-cache-consistency/">Three Ways to Maintain Cache Consistency | Redis</a><dt>Redis Race Condition | redis.io<dd><a href="https://redis.io/glossary/redis-race-condition/">Redis Race Condition</a><dt>High-Concurrency Practices of Redis: Snap-Up System | alibabacloud.com<dd><a href="https://www.alibabacloud.com/blog/high-concurrency-practices-of-redis-snap-up-system_597858">High-Concurrency Practices of Redis: Snap-Up System</a><dt>Understanding the Failover Mechanism of Redis Cluster | alibabacloud.com<dd><a href="https://www.alibabacloud.com/blog/understanding-the-failover-mechanism-of-redis-cluster_594707">Understanding the Failover Mechanism of Redis Cluster</a><dt>Snapshotting | redis.io<dd><a href="https://redis.io/docs/latest/operate/oss_and_stack/management/persistence/#snapshotting">Redis persistence</a><dt>Append-only file | redis.io<dd><a href="https://redis.io/docs/latest/operate/oss_and_stack/management/persistence/#append-only-file">Redis persistence</a><dt>Redis Architecture의 진화 | bytebytego.com<dd><a href="https://bytebytego.com/guides/how-redis-architecture-evolve/">ByteByteGo | How Redis Architecture Evolved</a><dt>What makes Redis lightning fast ? | engineeringatscale.substack.com<dd><a href="https://engineeringatscale.substack.com/p/what-makes-redis-lightning-fast">What makes Redis lightning fast ?</a><dt>Linux – IO Multiplexing – Select vs Poll vs Epoll | devarea.com<dd><a href="https://devarea.com/linux-io-multiplexing-select-vs-poll-vs-epoll/">Linux – IO Multiplexing – Select vs Poll vs Epoll</a><dt>BGREWRITEAOF | redis.io<dd><a href="https://redis.io/docs/latest/commands/bgrewriteaof/">BGREWRITEAOF</a><dt>Distributed Locks with Redis | redis.io<dd><a href="https://redis.io/docs/latest/develop/clients/patterns/distributed-locks/">Distributed Locks with Redis</a><dt>How to build a Rate Limiter using Redis | redis.io<dd><a href="https://redis.io/learn/howtos/ratelimiting">How to build a Rate Limiter using Redis</a><dt>Getting Started With Geo Location Search in Redis | redis.io<dd><a href="https://redis.io/learn/howtos/solutions/geo/getting-started">Getting Started With Geo Location Search in Redis</a><dt>How to Use Redis as an Event Store for Communication Between Microservices | redis.io<dd><a href="https://redis.io/blog/use-redis-event-store-communication-microservices/">How to Use Redis as an Event Store for Communication Between Microservices | Redis</a></dl></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw me-1"></i> <a href="/categories/system-design-interview/">System Design Interview</a>, <a href="/categories/key-technologies/">Key Technologies</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw me-1"></i> <a href="/tags/system-design/" class="post-tag no-text-decoration" >System Design</a> <a href="/tags/interview/" class="post-tag no-text-decoration" >interview</a> <a href="/tags/redis/" class="post-tag no-text-decoration" >redis</a></div><div class=" post-tail-bottom d-flex justify-content-between align-items-center mt-5 pb-2 " ><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper d-flex align-items-center"> <span class="share-label text-muted">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Redis%20%7C%20Key%20Technologies%20-%20System%20Design%20Interview%20-%20KanghoonYi(Pour)&url=https%3A%2F%2Fblog.devpour.net%2Fposts%2FRedis%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Twitter" aria-label="Twitter"> <i class="fa-fw fa-brands fa-square-x-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Redis%20%7C%20Key%20Technologies%20-%20System%20Design%20Interview%20-%20KanghoonYi(Pour)&u=https%3A%2F%2Fblog.devpour.net%2Fposts%2FRedis%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Facebook" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https%3A%2F%2Fblog.devpour.net%2Fposts%2FRedis%2F&text=Redis%20%7C%20Key%20Technologies%20-%20System%20Design%20Interview%20-%20KanghoonYi(Pour)" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Telegram" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <button id="copy-link" aria-label="Copy link" class="btn small" data-bs-toggle="tooltip" data-bs-placement="top" title="Copy link" data-title-succeed="Link copied successfully!" > <i class="fa-fw fas fa-link pe-none fs-6"></i> </button> </span></div></div></div></article></main><aside aria-label="Panel" id="panel-wrapper" class="col-xl-3 ps-2 mb-5 text-muted"><div class="access"><section id="access-lastmod"><h2 class="panel-heading">Recently Updated</h2><ul class="content list-unstyled ps-0 pb-1 ms-1 mt-2"><li class="text-truncate lh-lg"> <a href="/posts/Redis/">Redis | Key Technologies - System Design Interview</a><li class="text-truncate lh-lg"> <a href="/posts/Consistent-Hashing/">Consistent Hashing | Core Concepts - System Design Interview</a><li class="text-truncate lh-lg"> <a href="/posts/k8s-introduction/">Kubernetes(Orchestration) 개론</a><li class="text-truncate lh-lg"> <a href="/posts/CAP-Theorem/">CAP Theorem(정리) | Core Concepts - System Design Interview</a><li class="text-truncate lh-lg"> <a href="/posts/What-is-CloudNativePG/">What is CloudNativePG? | CloudNative</a></ul></section><section><h2 class="panel-heading">Trending Tags</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/programming/">programming</a> <a class="post-tag btn btn-outline-primary" href="/tags/aws/">aws</a> <a class="post-tag btn btn-outline-primary" href="/tags/leetcode/">leetcode</a> <a class="post-tag btn btn-outline-primary" href="/tags/rust/">rust</a> <a class="post-tag btn btn-outline-primary" href="/tags/computer-science/">Computer Science</a> <a class="post-tag btn btn-outline-primary" href="/tags/cncf/">cncf</a> <a class="post-tag btn btn-outline-primary" href="/tags/k8s/">k8s</a> <a class="post-tag btn btn-outline-primary" href="/tags/kubernetes/">kubernetes</a> <a class="post-tag btn btn-outline-primary" href="/tags/algorithm/">algorithm</a> <a class="post-tag btn btn-outline-primary" href="/tags/architecture/">Architecture</a></div></section></div><section id="toc-wrapper" class="d-none ps-0 pe-4"><h2 class="panel-heading ps-3 mb-2">Contents</h2><nav id="toc"></nav></section></aside></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 px-md-4"><aside id="related-posts" aria-labelledby="related-label"><h3 class="mb-4" id="related-label">Further Reading</h3><nav class="row row-cols-1 row-cols-md-2 row-cols-xl-3 g-4 mb-4"><article class="col"> <a href="/posts/Consistent-Hashing/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1753809540" data-df="ll" > Jul 30, 2025 </time><h4 class="pt-0 my-2">Consistent Hashing | Core Concepts - System Design Interview</h4><div class="text-muted"><p>‘Consistent Hashing’은 분산 시스템(Distributed System)의 Cluster에서, 데이터를 분산 저장할때 사용하는 기초적인 알고리즘 입니다. 예시로 보는 Consistent Hashing의 필요성 ‘Ticketing System을 구성한다고 해봅시다. Simple System과 Sharding이 적용된 System...</p></div></div></a></article><article class="col"> <a href="/posts/CAP-Theorem/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1753369440" data-df="ll" > Jul 25, 2025 </time><h4 class="pt-0 my-2">CAP Theorem(정리) | Core Concepts - System Design Interview</h4><div class="text-muted"><p>CAP Theorem 소개 CAP는 각각 Consistency, Availability, Partition Tolerance를 의미합니다. 이 ‘CAP Theorem’은 ‘Distributed System(분산처리 시스템)’의 3가지 핵심 속성에서, 이중 딱 2개만 취할 수 있다는 theorem(정리, 일정한 조건하에 참이라는 것이 증명됨...</p></div></div></a></article><article class="col"> <a href="/posts/networking-essentials/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1752733200" data-df="ll" > Jul 17, 2025 </time><h4 class="pt-0 my-2">Networking Essentials | Core Concepts - System Design Interview</h4><div class="text-muted"><p>시스템 디자인(System Design)에 있어, 네트워킹(Netwoking)은 고려해야하는 필수적인 부분중 하나입니다. 이 Post에선, 네트워킹에서도 가장 중요한 부분만 정리하려고 합니다. 네트워킹 기초(Networking 101) OSI(Open Systems Interconnection) Model 7 Layers OSI Model 7 L...</p></div></div></a></article></nav></aside><nav class="post-navigation d-flex justify-content-between" aria-label="Post Navigation"> <a href="/posts/Consistent-Hashing/" class="btn btn-outline-primary" aria-label="Older" ><p>Consistent Hashing | Core Concepts - System Design Interview</p></a><div class="btn btn-outline-primary disabled" aria-label="Newer"><p>-</p></div></nav><script src="https://utteranc.es/client.js" repo="KanghoonYi/kanghoonyi.github.io" issue-term="pathname" crossorigin="anonymous" async ></script> <script type="text/javascript"> (function () { const origin = 'https://utteranc.es'; const lightTheme = 'github-light'; const darkTheme = 'github-dark'; let initTheme = lightTheme; const html = document.documentElement; if ( (html.hasAttribute('data-mode') && html.getAttribute('data-mode') === 'dark') || (!html.hasAttribute('data-mode') && window.matchMedia('(prefers-color-scheme: dark)').matches) ) { initTheme = darkTheme; } addEventListener('message', (event) => { let theme;if (event.origin === origin) {theme = initTheme; } else if (event.source === window && event.data && event.data.direction === ModeToggle.ID) {const mode = event.data.message; theme = mode === ModeToggle.DARK_MODE ? darkTheme : lightTheme; } else { return; } const message = { type: 'set-theme', theme: theme }; const utterances = document.getElementsByClassName('utterances-frame')[0].contentWindow; utterances.postMessage(message, origin); }); })(); </script><footer aria-label="Site Info" class=" d-flex flex-column justify-content-center text-muted flex-lg-row justify-content-lg-between align-items-lg-center pb-lg-3 " ><p>© <time>2025</time> <a href="https://github.com/KanghoonYi">KanghoonYi</a>. <span data-bs-toggle="tooltip" data-bs-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author." >Some rights reserved.</span></p><p>Using the <a data-bs-toggle="tooltip" data-bs-placement="top" title="v7.1.1" href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener" >Chirpy</a> theme for <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a>.</p></footer></div></div><div id="search-result-wrapper" class="d-flex justify-content-center d-none"><div class="col-11 content"><div id="search-hints"><section><h2 class="panel-heading">Trending Tags</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/programming/">programming</a> <a class="post-tag btn btn-outline-primary" href="/tags/aws/">aws</a> <a class="post-tag btn btn-outline-primary" href="/tags/leetcode/">leetcode</a> <a class="post-tag btn btn-outline-primary" href="/tags/rust/">rust</a> <a class="post-tag btn btn-outline-primary" href="/tags/computer-science/">Computer Science</a> <a class="post-tag btn btn-outline-primary" href="/tags/cncf/">cncf</a> <a class="post-tag btn btn-outline-primary" href="/tags/k8s/">k8s</a> <a class="post-tag btn btn-outline-primary" href="/tags/kubernetes/">kubernetes</a> <a class="post-tag btn btn-outline-primary" href="/tags/algorithm/">algorithm</a> <a class="post-tag btn btn-outline-primary" href="/tags/architecture/">Architecture</a></div></section></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><aside aria-label="Scroll to Top"> <button id="back-to-top" type="button" class="btn btn-lg btn-box-shadow"> <i class="fas fa-angle-up"></i> </button></aside></div><div id="mask"></div><script src="https://cdn.jsdelivr.net/combine/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js,npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.umd.min.js,npm/glightbox@3.3.0/dist/js/glightbox.min.js,npm/clipboard@2.0.11/dist/clipboard.min.js,npm/dayjs@1.11.13/dayjs.min.js,npm/dayjs@1.11.13/locale/en.js,npm/dayjs@1.11.13/plugin/relativeTime.js,npm/dayjs@1.11.13/plugin/localizedFormat.js,npm/tocbot@4.29.0/dist/tocbot.min.js"></script> <script src="/assets/js/dist/post.min.js"></script> <script src="/assets/js/data/mathjax.js"></script> <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script> <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-chtml.js"></script> <script>SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<article class="px-1 px-sm-2 px-lg-4 px-xl-0"><header><h2><a href="{url}">{title}</a></h2><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div></header><p>{snippet}</p></article>', noResultsText: '<p class="mt-5">Oops! No results found.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="me-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
