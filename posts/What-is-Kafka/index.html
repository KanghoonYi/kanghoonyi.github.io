<!doctype html><html lang="ko" data-mode="light"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" ><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="What is Kafka? CloudNative" /><meta name="author" content="KanghoonYi(pour)" /><meta property="og:locale" content="ko" /><meta name="description" content="Kafka 소개" /><meta property="og:description" content="Kafka 소개" /><link rel="canonical" href="https://blog.devpour.net/posts/What-is-Kafka/" /><meta property="og:url" content="https://blog.devpour.net/posts/What-is-Kafka/" /><meta property="og:site_name" content="KanghoonYi(Pour)" /><meta property="og:image" content="https://blog.devpour.net/assets/img/for-post/What%20is%20Kafka/kafka-cover.png" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2025-07-23T14:09:00+09:00" /><meta name="twitter:card" content="summary_large_image" /><meta property="twitter:image" content="https://blog.devpour.net/assets/img/for-post/What%20is%20Kafka/kafka-cover.png" /><meta property="twitter:title" content="What is Kafka? CloudNative" /><meta name="google-site-verification" content="rsx_-5MJzSR_3NNCqHNe9IxnKJxlD8Eid8_wN8e9c1I" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"KanghoonYi(pour)","url":"https://www.linkedin.com/in/pour/"},"dateModified":"2025-07-23T14:09:00+09:00","datePublished":"2025-07-23T14:09:00+09:00","description":"Kafka 소개","headline":"What is Kafka? CloudNative","image":"https://blog.devpour.net/assets/img/for-post/What%20is%20Kafka/kafka-cover.png","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.devpour.net/posts/What-is-Kafka/"},"url":"https://blog.devpour.net/posts/What-is-Kafka/"}</script><title>What is Kafka? | CloudNative | KanghoonYi(Pour)</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="KanghoonYi(Pour)"><meta name="application-name" content="KanghoonYi(Pour)"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="/assets/css/jekyll-theme-chirpy.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.6.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.29.0/dist/tocbot.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/glightbox@3.3.0/dist/css/glightbox.min.css"><body><aside aria-label="Sidebar" id="sidebar" class="d-flex flex-column align-items-end"><header class="profile-wrapper"> <a href="/" id="avatar" class="rounded-circle"><img src="/assets/img/pour_profile_img.png" width="112" height="112" alt="avatar" onerror="this.style.display='none'"></a><h1 class="site-title"> <a href="/">KanghoonYi(Pour)</a></h1><p class="site-subtitle fst-italic mb-0">안녕하세요~ Software Engineer pour입니다 This is Pour.</p></header><nav class="flex-column flex-grow-1 w-100 ps-0"><ul class="nav"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle"></i> <span>ABOUT</span> </a></ul></nav><div class="sidebar-bottom d-flex flex-wrap align-items-center w-100"> <a href="https://github.com/KanghoonYi" aria-label="github" target="_blank" rel="noopener noreferrer" > <i class="fab fa-github"></i> </a> <a href="https://twitter.com/" aria-label="twitter" target="_blank" rel="noopener noreferrer" > <i class="fa-brands fa-x-twitter"></i> </a> <a href="javascript:location.href = 'mailto:' + ['rkdgnsdls','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></aside><div id="main-wrapper" class="d-flex justify-content-center"><div class="container d-flex flex-column px-xxl-5"><header id="topbar-wrapper" aria-label="Top Bar"><div id="topbar" class="d-flex align-items-center justify-content-between px-lg-3 h-100" ><nav id="breadcrumb" aria-label="Breadcrumb"> <span> <a href="/">Home</a> </span> <span>What is Kafka? | CloudNative</span></nav><button type="button" id="sidebar-trigger" class="btn btn-link"> <i class="fas fa-bars fa-fw"></i> </button><div id="topbar-title"> Post</div><button type="button" id="search-trigger" class="btn btn-link"> <i class="fas fa-search fa-fw"></i> </button> <search id="search" class="align-items-center ms-3 ms-lg-0"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..." > </search> <button type="button" class="btn btn-link text-decoration-none" id="search-cancel">Cancel</button></div></header><div class="row flex-grow-1"><main aria-label="Main Content" class="col-12 col-lg-11 col-xl-9 px-md-4"><article class="px-1"><header><h1 data-toc-skip>What is Kafka? | CloudNative</h1><div class="post-meta text-muted"> <span> Posted <time data-ts="1753247340" data-df="ll" data-bs-toggle="tooltip" data-bs-placement="bottom" > Jul 23, 2025 </time> </span><div class="mt-3 mb-3"> <a href="/assets/img/for-post/What%20is%20Kafka/kafka-cover.png" class="popup img-link preview-img shimmer"><img src="/assets/img/for-post/What%20is%20Kafka/kafka-cover.png" alt="Preview Image" width="1200" height="630" loading="lazy"></a></div><div class="d-flex justify-content-between"> <span> By <em> <a href="https://www.linkedin.com/in/pour/">KanghoonYi(pour)</a> </em> </span><div> <span class="readtime" data-bs-toggle="tooltip" data-bs-placement="bottom" title="6600 words" > <em>36 min</em> read</span></div></div></div></header><div class="content"><h2 id="kafka-소개"><span class="me-2">Kafka 소개</span><a href="#kafka-소개" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><dl><dt>Kafka는<dd>대용량의 실시간 데이터 스트리밍을 처리하는 <strong>분산(Distributed) 메시징 시스템</strong>입니다.<dd>원래 <strong>LinkedIn</strong>에서 개발되었고, 이후 <strong>Apache Software Foundation</strong>에서 오픈소스로 관리되고 있습니다.</dl><h3 id="탄생-배경linkedin에서"><span class="me-2">탄생 배경(LinkedIn에서)</span><a href="#탄생-배경linkedin에서" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><p>로그와 사용자 이벤트 데이터 폭증<br /> ‘LinkedIn’에서는 Web에서 사용자들의 행동을 추적(tracking)하고 있었는데, 사용자가 급격하게 늘어남에 따라, 데이터가 폭발적으로 증가하였습니다.<br /> 수천만 명의 사용자가 활동하면서 광고 클릭, 검색, 프로필 조회, 추천 요청 등의 이벤트가 초당 수십만 건씩 발생하였으며, 기존의 로그 수집 시스템(파일 로그 → 수집기 → Hadoop ETL)은 이를 감당하지 못했습니다.</p><li><p>실시간 분석 불가능<br /> 모든 데이터는 Hadoop에 쌓인 후 <strong>배치 처리</strong>해야 했습니다.(즉, 실시간 분석이 불가능.)<br /> 실시간 분석은 거의 불가능하고, 결과를 보려면 <strong>수 시간 또는 하루 이상 지연</strong>되었습니다.</p><li><p>AMQP(Advanced Message Queuing Protocol)의 한계<br /> LinkedIn에서 처음에는 AMQP서비스들을 고려했다고 합니다. 하지만, AMQP로 분산처리 환경을 구현하는데에 여러 어려움이 있었습니다.</p></ul><p>이를 극복하기 위해, 기존에 있던 Messaging System을 고려했지만, 적합한게 없어, Kafka를 만들게 되었습니다.</p><h3 id="kafka의-초기-설계-철학"><span class="me-2">Kafka의 초기 설계 철학</span><a href="#kafka의-초기-설계-철학" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Kafka는 단순한 메시지 큐가 아니라, <strong>범용 로그 시스템(log-centric system)</strong>으로 설계되었습니다.<br /> 핵심 철학은 다음과 같습니다.</p><h4 id="모든-데이터를-이벤트-로그로-저장합니다"><span class="me-2">모든 데이터를 이벤트 로그로 저장합니다.</span><a href="#모든-데이터를-이벤트-로그로-저장합니다" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>이벤트 중심(Event-driven) 아키텍처를 채택하였습니다.</p><blockquote class="prompt-info"><p>모든 시스템 간 통신과 상태 변화를 이벤트 로그로 기록·전파하여, 비동기·분산·확장 가능한 구조를 구현했다는 의미입니다.</p></blockquote><p>모든 시스템 간 통신도 <strong>로그 기반 이벤트 스트림</strong>으로 표현합니다.</p><h4 id="고성능--고내구성"><span class="me-2">고성능 &amp; 고내구성</span><a href="#고성능--고내구성" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p><strong>디스크에 바로 쓰되, 디스크 I/O를 최적화</strong>하여 메모리 버퍼처럼 빠르게 동작합니다.<br /> 메시지를 디스크에 저장하되 복제(replication)로 데이터 유실 방지합니다.</p><h4 id="단순하고-확장-가능한-api"><span class="me-2">단순하고 확장 가능한 API</span><a href="#단순하고-확장-가능한-api" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Producer, Consumer 모두 단순한 API로 통신합니다.<br /> 파티셔닝(partitioning)을 통해 <strong>수평 확장(Horizontal Scaling)</strong>이 쉽습니다.</p><h4 id="리플레이-가능한-스트림-처리"><span class="me-2">리플레이 가능한 스트림 처리</span><a href="#리플레이-가능한-스트림-처리" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>데이터는 소비 후에도 삭제되지 않으며, <strong>필요할 때 다시 읽을 수 있습니다.</strong><br /> 이 덕분에 <strong>재처리, 재분석, 에러 복구</strong>가 쉬워집니다.</p><h4 id="다양한-시스템-연결을-위한-허브"><span class="me-2">다양한 시스템 연결을 위한 허브</span><a href="#다양한-시스템-연결을-위한-허브" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Kafka를 중심으로 Hadoop, HDFS, Cassandra, Storm 등과 연계하곤 합니다.<br /> 즉, Kafka는 <strong>데이터의 허브</strong>가 됩니다.</p><p><br /></p><h2 id="kafka-architecture"><span class="me-2">Kafka Architecture</span><a href="#kafka-architecture" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Kafka는 여러 Broker를 통해 Cluster를 생성하여, 분산처리를 위한 Architecture를 갖추고 있습니다.</p><p><a href="/assets/img/for-post/What%20is%20Kafka/image.png" class="popup img-link shimmer"><img src="/assets/img/for-post/What%20is%20Kafka/image.png" alt="Kafka Cluster Architecture" loading="lazy"></a> <em>Kafka Cluster Architecture | from <a href="https://ibm-cloud-architecture.github.io/refarch-eda/technology/kafka-overview/">ibm-cloud-architecture.github.io</a></em></p><p><a href="/assets/img/for-post/What%20is%20Kafka/image%201.png" class="popup img-link shimmer"><img src="/assets/img/for-post/What%20is%20Kafka/image%201.png" alt="Kafka Architecture with Offset" loading="lazy"></a> <em>Kafka Architecture with Offset | from <a href="https://d3s.mff.cuni.cz/files/teaching/nswi080/lectures/notes/ch02s11.html">d3s.mff.cuni.cz</a></em></p><h3 id="components"><span class="me-2">Components</span><a href="#components" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h4 id="brokers"><span class="me-2">Brokers</span><a href="#brokers" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Kafka는 여러 Broker로 이루어진 Cluster로 운영됩니다. 즉, Broker는 Kafka 서버 인스턴스 하나하나를 의미합니다.</p><dl><dt>이 Broker들은<dd>데이터의 Replication을 관리하고,<dd>Topic/partition을 관리하고,<dd>Broker안에 있는 Partition의 Offset을 관리합니다.</dl><p>Broker에는 Topic(실제로 Record Stream이 저장되는 곳)의 Partition이 저장됩니다.</p><blockquote class="prompt-info"><p>만약, 여러 데이터센터를 걸쳐서 Kafka를 구성한다면, 센터간 15ms이하의 network latency를 요구합니다.<br /> 이는 Kafka Broker와 zookeeper사이에 많은 통신이 있기때문입니다.</p></blockquote><blockquote class="prompt-info"><p>Production level에선, 최소한 5개의 노드(Broker)를 구성하는게 좋다고 합니다.</p></blockquote><h4 id="zookeeper최신버전에서는-kraft-controller-사용"><span class="me-2">Zookeeper(최신버전에서는 KRaft Controller 사용)</span><a href="#zookeeper최신버전에서는-kraft-controller-사용" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><dl><dt>‘Zookeeper’는<dd>Component나 Kafka의 상태를 유지하는데 사용됩니다.<dd>HA(High Availability)를 위해, Cluster형태로 실행됩니다.<dd>클러스터의 메타데이터(파티션 배치, ISR, 브로커 생·사 등) 관리합니다.</dl><blockquote class="prompt-info"><p>Kafka Version에 따라, zookeeper에서 offset을 관리합니다.<br /> 최신 버젼에서는 Kafka내부에서 ‘consumer offset’이라는 이름으로 관리합니다.</p></blockquote><blockquote class="prompt-info"><p>Zookeeper는 Kafka 3.5부터 deprecated처리 되며, 4.0부터는 완전히 제거됩니다.</p></blockquote><h4 id="kraft-controller40이상부터-default"><span class="me-2">KRaft Controller(4.0이상부터 default)</span><a href="#kraft-controller40이상부터-default" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><dl><dt>KRaft Controller는<dd>Zookeeper의 역할을 대체하면서도, Kafka 외부(Zookeeper)의 도움 없이 Kafka 스스로 클러스터가 운영될 수 있도록 합니다.<dd>Kafka의 아키텍처를 단순화하고, 운영 부담을 감소시켜 줍니다.(ZooKeeper에 대한 관리가 불필요)</dl><p><a href="/assets/img/for-post/What%20is%20Kafka/image%202.png" class="popup img-link shimmer"><img src="/assets/img/for-post/What%20is%20Kafka/image%202.png" alt="ZooKeeper mode vs. KRaft mode" loading="lazy"></a> <em>ZooKeeper mode vs. KRaft mode</em></p><p>Kafka 3.3부터 KRaft가 새 클러스터에 “프로덕션 레디”로 승인되고, 3.5에서 Zookeeper 모드가 deprecated, 4.0에서 제거될 예정입니다.(현재시점 4.0.0 출시)</p><blockquote class="prompt-info"><p>‘Raft’는 뗏목을 의미하며, Cluster에서 Leader를 선출하는 합의 알고리즘중 하나입니다.</p></blockquote><h4 id="topics과-partitions-replication"><span class="me-2">Topics과 Partitions, Replication</span><a href="#topics과-partitions-replication" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><dl><dt>‘Topic’은<dd>메시지 논리 채널입니다.<dd>Record를 Publish하고, Consume하는 엔드포인트를 제공합니다.<dd>하나의 Topic을 N개의 Partition으로 나누어, 각 Partition은 독립적인 append-only(추가만 되는) 로그로 관리합니다.</dl><p><a href="/assets/img/for-post/What%20is%20Kafka/image%203.png" class="popup img-link shimmer"><img src="/assets/img/for-post/What%20is%20Kafka/image%203.png" alt="하나의 Topic은 여러개의 Partition과 Replicas로 구성되어 있습니다." loading="lazy"></a> <em>하나의 Topic은 여러개의 Partition과 Replicas로 구성되어 있습니다.</em></p><dl><dt>Partition은<dd>단일 서버가 모든 이벤트를 처리할 수 없을 때, Broker Clustering을 사용하여 이벤트 처리를 병렬화하는 데에 사용됩니다.<dd>Topic을 병렬 처리 단위로 분할하는 개념이며, Broker에 분산 배치되어 쓰기·읽기 부하 분산 구현합니다.<dd>Consumer나 ‘Traffic pattern’에 따라 파티션의 갯수를 조절할 수 있으며, 각 Broker는 2000개의 파티션을 가질 수 있습니다.<dd><strong>append-only Log파일로 구현</strong>되어 있으며(<strong>Disk에 저장</strong>), 오래된 Record는 정해진 시간이나, 파일 limit에 도달하면 지워집니다.</dl><p><a href="/assets/img/for-post/What%20is%20Kafka/image%204.png" class="popup img-link shimmer"><img src="/assets/img/for-post/What%20is%20Kafka/image%204.png" alt="Kafka의 Topic은 여러 Partition으로 이루어져 있습니다." loading="lazy"></a> <em>Kafka의 Topic은 여러 Partition으로 이루어져 있습니다.</em></p><dl><dt>Replication은<dd>Partition이 여러 Broker(서버)에 걸쳐 복제된 ‘복제본’을 말합니다.<dd>각 Partition은 Leader와 하나 이상의 Follower Replica를 갖고 있어, 장애 시에도 데이터 가용성·내구성 유지합니다.<dd><strong>Leader가 모든 Read/Write 요청을 다루고</strong>, Follower는 Leader의 컨텐츠를 복제합니다.</dl><p><a href="/assets/img/for-post/What%20is%20Kafka/image%205.png" class="popup img-link shimmer"><img src="/assets/img/for-post/What%20is%20Kafka/image%205.png" alt="Topic의 Partition과 Replication" loading="lazy"></a> <em>Topic의 Partition과 Replication</em></p><h4 id="producer"><span class="me-2">Producer</span><a href="#producer" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><blockquote><p>A producer is a thread safe kafka client API that publishes records to the cluster.<br /> - from <a href="https://ibm-cloud-architecture.github.io/refarch-eda/technology/kafka-producers/">ibm-cloud-architecture.github.io</a></p></blockquote><dl><dt>‘Producer’는<dd>Kafka에 메세지를 등록(publish)하는 Client입니다.<dd>초기 연결(initial bootstrap connection)후에, 토픽(파티션)과 연결할 Leader Broker에 대한 메타데이터를 얻습니다.<dt>메세지를 파티션에 할당할때,<dd>Key가 지정되지 않은경우, Round-robin을 사용합니다.<dd>Key가 정해져 있다면, Key의 Hash값으로 partition이 정해집니다.<dd>혹은 이 과정을 Custom할 수 있습니다.</dl><h4 id="consumer와-consumer-group"><span class="me-2">Consumer와 Consumer Group</span><a href="#consumer와-consumer-group" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><dl><dt>Consumer는<dd>특정 Topic의 Partition에서 Record를 Pull방식으로 가져와서 처리하는 컴포넌트입니다.<dd>일반적으로 poll() 루프를 돌며 일정량씩 읽고(fetch), 처리 후 offset을 커밋(commit)합니다.<dt>Consumer Group은<dd>동일한 <code class="language-plaintext highlighter-rouge">group.id</code> 를 가진, Consumer들의 집합을 ‘Consumer Group’이라고 합니다.<dd>하나의 Topic 파티션을 그룹 내에서 단 1개의 Consumer만 소비하도록 해서 작업을 분산 합니다(Queue semantics).<dd>각 partition마다 최소 1개의 Consumer가 있어야 하며, Consumer가 Group에 하나만 있다면, 모든 partition의 데이터를 다룹니다.</dl><p><a href="/assets/img/for-post/What%20is%20Kafka/image%206.png" class="popup img-link shimmer"><img src="/assets/img/for-post/What%20is%20Kafka/image%206.png" alt="image.png" loading="lazy"></a> <em>Consumer와 Consumer Group의 관계</em></p><h4 id="message-구조"><span class="me-2">Message 구조</span><a href="#message-구조" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p><a href="/assets/img/for-post/What%20is%20Kafka/image%207.png" class="popup img-link shimmer"><img src="/assets/img/for-post/What%20is%20Kafka/image%207.png" alt="Kafka Message Anatomy" loading="lazy"></a> <em>Kafka Message Anatomy | <a href="https://www.geeksforgeeks.org/java/how-kafka-producers-message-keys-message-format-and-serializers-work-in-apache-kafka/">geeksforgeeks.org</a></em></p><ul><li><p>Message의 Key는 nullable입니다.<br /> key가 null이라면, Round-robin을 통해 random하게 Partition에 할당됩니다.</p><li>Compression Type을 통해, Message의 합축을 표현할 수 있습니다.<li>Header는 key/value 형식의 Metadata를 저장합니다.<li>Partition은 전송 대상을 의미합니다.(어떤 partition에 저장될 지)<li>Offset은 Broker가 메세지를 partition에 저장할때 부여되며, Consumer가 읽을 때 확인합니다.<li>Timestamp는 이벤트의 생성시간 혹은 Log에 추가된 시간을 의미합니다.</ul><h4 id="avro"><span class="me-2">Avro</span><a href="#avro" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Avro는 메시지를 직렬화(serialize)할 때 쓰는 포맷/스키마 언어입니다.(Protobuf와 유사)</p><div class="language-json highlighter-rouge"><div class="code-header"> <span data-label-text="JSON"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="err">//</span><span class="w"> </span><span class="err">user_event.avsc</span><span class="w">
</span><span class="p">{</span><span class="w">
  </span><span class="nl">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"record"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"UserEvent"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"namespace"</span><span class="p">:</span><span class="w"> </span><span class="s2">"com.example"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"fields"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
    </span><span class="p">{</span><span class="w"> </span><span class="nl">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"id"</span><span class="p">,</span><span class="w"> </span><span class="nl">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"string"</span><span class="w"> </span><span class="p">},</span><span class="w">
    </span><span class="p">{</span><span class="w"> </span><span class="nl">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"email"</span><span class="p">,</span><span class="w"> </span><span class="nl">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"string"</span><span class="w"> </span><span class="p">},</span><span class="w">
    </span><span class="p">{</span><span class="w"> </span><span class="nl">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"age"</span><span class="p">,</span><span class="w"> </span><span class="nl">"type"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">"null"</span><span class="p">,</span><span class="w"> </span><span class="s2">"int"</span><span class="p">],</span><span class="w"> </span><span class="nl">"default"</span><span class="p">:</span><span class="w"> </span><span class="kc">null</span><span class="w"> </span><span class="p">}</span><span class="w">
  </span><span class="p">]</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></pre></table></code></div></div><p>데이터의 Schema를 JSON형식으로 입력하여 사용합니다. 이를 기반으로 데이터를 Binary로 변환하여 전송합니다.<br /> Schema Registry(Confluent, Apicurio)를 통해, Schema를 등록해서 재사용 하곤 합니다.</p><p><a href="/assets/img/for-post/What%20is%20Kafka/image%208.png" class="popup img-link shimmer"><img src="/assets/img/for-post/What%20is%20Kafka/image%208.png" alt="Schema Registry의 사용 Flow" loading="lazy"></a> <em>Schema Registry의 사용 Flow | <a href="https://docs.confluent.io/platform/current/schema-registry/index.html">docs.confluent.io</a></em></p><p><br /></p><h2 id="kafka의-기능과-구현"><span class="me-2">Kafka의 기능과 구현</span><a href="#kafka의-기능과-구현" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="producer의-exactly-once-delivery-exactly-once-semantics-eos"><span class="me-2">Producer의 Exactly-Once Delivery(= Exactly-Once Semantics, EOS)</span><a href="#producer의-exactly-once-delivery-exactly-once-semantics-eos" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><dl><dt>‘Exactly-Once Delivery’는<dd>“재시도·네트워크 오류가 있어도 Kafka 로그에 동일 레코드가 단 한 번만 쓰이고, 다운스트림(다른 토픽/컨슈머)에도 중복 없이 한 번만 보이게 하는 것”을 목표로 합니다.</dl><blockquote class="prompt-info"><p>분산 시스템에서 정확히 한 번만 Delivery하는 것이, 가장 해결하기 어려운 문제 중 하나입니다.</p></blockquote><p>이를 위해 2가지 기능이 결합되어 있습니다.</p><h4 id="멱등성idempotent을-제공하는-producer"><span class="me-2">멱등성(Idempotent)을 제공하는 Producer</span><a href="#멱등성idempotent을-제공하는-producer" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Producer에서 메세지의 멱등성(Idempotent)을 위한 기능을 제공합니다.<br /> Producer가 ProducerId(PID) 와 시퀀스 번호를 붙여 전송합니다. → 브로커가 중복 쓰기 감지 후 무시하도록 처리합니다.<br /> 같은 파티션에 대한 중복 기록 방지(“딱 한 번 쓰기”)는 보장할 수 있습니다</p><h4 id="트랜잭셔널transactional-producer"><span class="me-2">트랜잭셔널(Transactional) Producer</span><a href="#트랜잭셔널transactional-producer" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>여러 파티션·토픽에 걸친 쓰기와 Consumer 오프셋 커밋까지 하나의 트랜잭션으로 묶어 정확히 한 번 처리를 보장합니다. <br /></p><h3 id="broker의-offset-management"><span class="me-2">Broker의 Offset Management</span><a href="#broker의-offset-management" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>“브로커가 오프셋을 관리한다”는 말은 보통 두 가지 Layer를 포함합니다.</p><ol><li><strong>메시지 자체의 오프셋(Log Offset)</strong>을 브로커가 붙입니다.<li><strong>“Consumer가 어디까지 읽었는지”</strong>를 브로커가 저장해 줍니다(Committed Offset)</ol><h4 id="log-offset"><span class="me-2">Log Offset</span><a href="#log-offset" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p><strong>메시지 자체의 오프셋(Log Offset)</strong>을 브로커가 붙입니다.<br /> 각 파티션은 <strong>append-only 로그 파일</strong>이고, 브로커가 새 레코드가 들어올 때마다 0,1,2…처럼 증가하는 번호(Offset)를 붙여 저장합니다.<br /> 그래서 <strong>파티션 안에서만</strong> 순서가 보장되고, Consumer는 “나는 offset=123부터 읽을래”처럼 요청할 수 있습니다.</p><p><a href="/assets/img/for-post/What%20is%20Kafka/image%209.png" class="popup img-link shimmer"><img src="/assets/img/for-post/What%20is%20Kafka/image%209.png" alt="Distributed Log와 Offset" loading="lazy"></a> <em>Distributed Log와 Offset | <a href="https://oso.sh/blog/apache-kafka-101/">oso.sh</a></em></p><h4 id="consumer-group과-committed-offset"><span class="me-2">Consumer group과 Committed Offset</span><a href="#consumer-group과-committed-offset" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p><a href="/assets/img/for-post/What%20is%20Kafka/image%2010.png" class="popup img-link shimmer"><img src="/assets/img/for-post/What%20is%20Kafka/image%2010.png" alt="Consumer Group과 Offset의 관계" loading="lazy"></a> <em>Consumer Group과 Offset의 관계</em></p><p><strong>“Consumer가 어디까지 읽었는지”</strong>를 브로커가 저장해 줍니다. (Committed Offset)<br /> Consumer Group은 처리 완료한 위치(offset)를 <strong>커밋(commit)</strong>합니다.<br /> 이 커밋 정보는 브로커 내부의 <strong>__consumer_offsets라는 내부(compacted) 토픽</strong>에 저장됩니다.</p><ul><li>키: (group, topic, partition)<li>값: committed offset + 메타데이터<br /> 이렇게 해두면 Consumer가 재시작하거나 다른 인스턴스로 넘어가도 <strong>“마지막으로 읽은 지점”을 브로커에서 다시 가져올 수</strong> 있습니다.</ul><blockquote class="prompt-info"><p><strong>메세지 순서 보장</strong><br /> 같은 Partition 내에서는 메시지 순서(order)가 보장되지만, Partition 간 순서는 보장되지 않습니다.</p></blockquote><p><br /></p><h3 id="consumer-rebalancing"><span class="me-2">Consumer Rebalancing</span><a href="#consumer-rebalancing" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><dl><dt>‘Consumer Rebalancing’은<dd>같은 Consumer Group 안에서 어떤 Consumer가 어떤 파티션을 읽을지 다시 배분하는 과정을 말합니다.<dd>새 Consumer가 추가/제거되거나, 파티션 수가 변할 때, “공평하게 나눠 읽도록” 그룹 전체가 잠깐 멈추고 재조정(Rebalancing)합니다.</dl><p><a href="/assets/img/for-post/What%20is%20Kafka/image%2011.png" class="popup img-link shimmer"><img src="/assets/img/for-post/What%20is%20Kafka/image%2011.png" alt="Stop-the-world rebalancing" loading="lazy"></a> <em>Stop-the-world rebalancing | <a href="https://www.redpanda.com/guides/kafka-performance-kafka-rebalancing">redpanda.com</a></em></p><h4 id="rebalancing-발생-환경"><span class="me-2">Rebalancing 발생 환경</span><a href="#rebalancing-발생-환경" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li><p><strong>그룹 구성에 변화가 있을때.</strong><br /> 새 Consumer 추가되거나, 기존 Consumer가 <strong>leave</strong> 또는 <strong>죽음(heartbeat 끊김)</strong> 상태일때.</p><li><strong>토픽 파티션 수가 변경될때.</strong><li><strong>Group Coordinator가 교체되거나 장애가 발생했을때.</strong></ul><h4 id="rebalancing-과정eager-방식"><span class="me-2">Rebalancing 과정(Eager 방식)</span><a href="#rebalancing-과정eager-방식" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ol><li><p>JoinGroup 요청<br /> 모든 Consumer가 Coordinator(그룹을 관리하는 브로커)에게 “나 여기 있어요”라고 알립니다.</p><li><p>리더 선출 &amp; 파티션 할당 계산<br /> Coordinator가 <em>그룹 내 리더 Consumer</em>를 하나 선출합니다.<br /> 리더가 partition.assignment.strategy(Range, RoundRobin, Sticky 등)에 따라 ‘파티션 분배’ 세부 내용을 계산합니다.</p><li><p>SyncGroup<br /> 리더가 계산 결과를 Coordinator에 전달합니다.<br /> Coordinator가 모든 Consumer에게 “너는 이 파티션들 담당” 통보합니다.</p><li><p>재시작<br /> 각 Consumer는 자신에게 배정된 파티션을 다시 poll()하기 시작합니다.</p></ol><blockquote class="prompt-info"><p>Eager방식에서는, 모든 Consumer가 한 번에 파티션을 반납했다가 다시 받기 때문에, ‘Stop-the-world’ 구간이 크다는 단점이 있습니다.</p></blockquote><h4 id="side-effects-of-kafka-rebalancing"><span class="me-2">Side effects of Kafka rebalancing</span><a href="#side-effects-of-kafka-rebalancing" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Kafka Rebalancing과정으로 인해, 예기지 않은 side effect가 발생할 수 있습니다.</p><ul><li><p>Latency 증가(Increased latency)<br /> 대량 이벤트를 처리하고 있다면, 잦은 리밸런스로 처리가 지연될 수 있습니다.</p><li><p>처리량 감소(Reduced Throughput)<br /> poll()이 멈춰 Consumer Lag 증가할 수 있습니다.</p><li>컴퓨팅 리소스 사용량 증가(Increased resource usage)<li>중복 처리 가능성<br /> 재시작 전에 커밋 못한 레코드는 재처리될 수 있음 (At-least-once)</ul><h4 id="cooperativeincremental-rebalancing"><span class="me-2">Cooperative(Incremental) Rebalancing</span><a href="#cooperativeincremental-rebalancing" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><dl><dt>‘Cooperative(Incremental) Rebalancing’은<dd>Kafka Consumer Group에서 필요한 파티션만 “부분적으로” 재할당해, 기존의 “모든 파티션을 일단 반납(Eager)” 방식이 만들던 Stop-the-world(중단 시간) 문제를 줄이려는 메커니즘입니다.<dd>Kafka 2.4+ 클라이언트부터 도입되었습니다.</dl><p><br /></p><h3 id="consumer-group과-partition-구성-best-practice"><span class="me-2">Consumer Group과 Partition 구성 Best Practice</span><a href="#consumer-group과-partition-구성-best-practice" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><p><strong>파티션 수 ≥ Consumer 수</strong>로 구성해야 합니다<br /> Consumer가 파티션보다 많으면 일부는 놀게되는 상황이 만들어집니다.</p><li><p><strong>수동 커밋 + 에러 처리 전략 수립합니다.</strong><br /> 처리가 끝난 후 커밋(At-least-once, 최소한 1회)하도록 설계하고,<br /> 재처리를 허용하도록 설계하는게 좋습니다(Idempotency, 멱등성 확보).</p><li><p><strong>리밸런스 상황을 최소화 합니다.</strong><br /> 긴 처리 작업은 별도 쓰레드/큐로 넘기고 poll 주기를 짧게 유지합니다.<br /> 최신 클라이언트를 통해, Cooperative rebalancing 사용하여, Balancing자체를 효율화 합니다.</p><li><p><strong>Lag를 모니터링합니다</strong><br /> Latency가 커지면 스케일 아웃 또는 처리 로직 최적화가 필요합니다.</p><li><p><strong>여러 Consumer Group으로 팬아웃(fanout, 입력 확장)합니다.</strong><br /> 서로 다른 용도(실시간 분석, ETL, 알림 등)는 <strong>각기 다른 Consumer Group(다른 group.id)</strong>로 독립 소비하도록 구성합니다.</p></ul><p><br /></p><h3 id="producer-partition-strategies"><span class="me-2">Producer partition strategies</span><a href="#producer-partition-strategies" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Producer가 Partition에 메세지를 할당하는 Strategy(전략)에 대해서 알아봅니다.</p><h4 id="키-기반-해싱-keyed-partitioningdefault-strategy"><span class="me-2">키 기반 해싱 (Keyed Partitioning)(default strategy)</span><a href="#키-기반-해싱-keyed-partitioningdefault-strategy" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p><a href="/assets/img/for-post/What%20is%20Kafka/image%2012.png" class="popup img-link shimmer"><img src="/assets/img/for-post/What%20is%20Kafka/image%2012.png" alt="Hash로 작동하는 Default Strategy." loading="lazy"></a> <em>Hash로 작동하는 Default Strategy.</em></p><p><strong>키가 null이 아닐 때</strong>의 기본 전략입니다.<br /> <strong>같은 키는 항상 같은 파티션에 할당됩니다.</strong> → 키 단위 순서 보장해서, 로컬 캐시/상태 활용에 유리합니다.</p><h4 id="round-robin-partition-strategy"><span class="me-2">Round-Robin Partition Strategy</span><a href="#round-robin-partition-strategy" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p><a href="/assets/img/for-post/What%20is%20Kafka/image%2013.png" class="popup img-link shimmer"><img src="/assets/img/for-post/What%20is%20Kafka/image%2013.png" alt="Round-Robin으로 Random하게 분배." loading="lazy"></a> <em>Round-Robin으로 Random하게 분배.</em></p><p>이 전략은 메시지 내용에 관계없이 메시지를 파티션에 순환적으로 할당합니다.<br /> 모든 파티션에 메시지가 균등하게 분배되도록 보장하지만, 관련 메시지가 서로 다른 파티션에 배치될 수 있으므로 순서대로 처리된다는 보장은 없습니다.</p><h4 id="sticky-partitioning-키가-null일-때-기본"><span class="me-2">Sticky Partitioning (키가 null일 때 기본)</span><a href="#sticky-partitioning-키가-null일-때-기본" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p><strong>키가 null이면 “한 파티션을 당분간 고정(sticky)”</strong>해서 배치를 크게 묶어 성능을 향상시켰습니다.<br /> 배치를 flush 하거나 파티션 추가/에러 발생 시 다른 파티션을 새로 선택합니다.</p><h4 id="uniform-sticky-partition-strategy"><span class="me-2">Uniform Sticky Partition Strategy</span><a href="#uniform-sticky-partition-strategy" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p><a href="/assets/img/for-post/What%20is%20Kafka/image%2014.png" class="popup img-link shimmer"><img src="/assets/img/for-post/What%20is%20Kafka/image%2014.png" alt="Uniform Sticky Partition Strategy" loading="lazy"></a> <em>Uniform Sticky Partition Strategy</em></p><p>Sticky의 장점(큰 배치 유지)을 살리면서 <strong>토픽 전체 파티션에 더 균일하게 분배</strong>하는 전략입니다.<br /> 특히 <strong>많은 토픽/파티션</strong>을 동시에 다룰 때 분포 불균형을 줄여줍니다. <br /></p><h3 id="consumer-assignment-strategies"><span class="me-2">Consumer assignment strategies</span><a href="#consumer-assignment-strategies" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>같은 <strong>Consumer Group 안에서 파티션을 어떤 규칙으로 나눠 가질지</strong> 결정하는 알고리즘입니다.<br /> Rebalancing 때, partition.assignment.strategy에 지정된 클래스가 실행돼 Partition→Consumer 매핑을 계산합니다.</p><h4 id="range-assignor-default"><span class="me-2">Range assignor (default)</span><a href="#range-assignor-default" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p><a href="/assets/img/for-post/What%20is%20Kafka/image%2015.png" class="popup img-link shimmer"><img src="/assets/img/for-post/What%20is%20Kafka/image%2015.png" alt="Range assignor" loading="lazy"></a> <em>Range assignor | from <a href="https://developer.confluent.io/courses/architecture/consumer-group-protocol/">developer.confluent.io</a></em></p><p>토픽별로 파티션을 정렬 후 컨슈머 수로 나눠 “연속 구간(range)” 배정합니다.<br /> 즉, 단순하게 파티션을 순서대로 컨슈머에 분배하되, 파티션과 컨슈머가 짝수로 나누어떨어지지 않으면, 앞부분의 컨슈머들에 파티션을 좀 더 가져갑니디.(Round Robin과는 여기서 차이가 있음)</p><h4 id="round-robin-assignor"><span class="me-2">Round-robin assignor</span><a href="#round-robin-assignor" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p><a href="/assets/img/for-post/What%20is%20Kafka/image%2016.png" class="popup img-link shimmer"><img src="/assets/img/for-post/What%20is%20Kafka/image%2016.png" alt="Round-robin Assignor" loading="lazy"></a> <em>Round-robin Assignor | from <a href="https://developer.confluent.io/courses/architecture/consumer-group-protocol/">developer.confluent.io</a></em></p><p>모든 토픽의 파티션을 하나의 리스트로 붙여 라운드로빈을 돌립니다.(토픽 구분 없이 모든 파티션을 균등 분배.)<br /> 사용되는 Consumer 수를 극대화하는 것을 목표로 할때 사용합니다.<br /> 하지만, Rebalancing시에, 전체 Partition에 대해 재배치가 이루어저야 하는 문제(Eager Rebalance)가 있습니다. 즉, 일부분의 Partition만 조정하지 못하는 문제가 있습니다.</p><h4 id="sticky-assignor"><span class="me-2">Sticky assignor</span><a href="#sticky-assignor" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>‘Round-robin’과 유사하지만, Rebalancing 할 때에 일부의 Partition만 재배치됩니다.</p><h4 id="cooperative-sticky-assignor권장"><span class="me-2">Cooperative Sticky assignor(권장)</span><a href="#cooperative-sticky-assignor권장" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Sticky기반에, ‘필요 파티션만 천천히 이동’하는 assignor입니다.</p><blockquote class="prompt-info"><p>Eager(전통적)인 assignore는 컨슈머 목록에 변화가 생기면, 모든 Consumer를 반납하고 다시 할당 받습니다. 이 과정에서 ‘Stop-the-world’가 발생하여, Lag 급증, 중복 처리 위험이 발생하게 됩니다.</p></blockquote><p><a href="/assets/img/for-post/What%20is%20Kafka/image%2017.png" class="popup img-link shimmer"><img src="/assets/img/for-post/What%20is%20Kafka/image%2017.png" alt="Avoid Pause with CooperativeStickyAssignor Step 1" loading="lazy"></a> <em>Avoid Pause with CooperativeStickyAssignor Step 1</em></p><p><a href="/assets/img/for-post/What%20is%20Kafka/image%2018.png" class="popup img-link shimmer"><img src="/assets/img/for-post/What%20is%20Kafka/image%2018.png" alt="Avoid Pause with CooperativeStickyAssignor Step 2" loading="lazy"></a> <em>Avoid Pause with CooperativeStickyAssignor Step 2</em></p><p>두 단계를 거쳐, “필요한 파티션만” 이동시켜 Stop-the-world를 피합니다.</p><h3 id="kafka-message의-forwardbackward-compatibility-필요성"><span class="me-2">Kafka Message의 Forward/Backward Compatibility 필요성</span><a href="#kafka-message의-forwardbackward-compatibility-필요성" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>System이 성장하면서, Kafka의 Message도 계속 성장합니다.<br /> Kafka에서는 <strong>Avro를 통해, Schema의 진화(혹은 성장, Schema Evolution)를 가능하게 합니다.</strong><br /> 여기서는 Avro를 이용하여, Message의 ‘Forward/Backward Compatibility’가 왜 필요한지 알아봅니다.</p><h4 id="kafka는-장기-보존--리플레이reprocess가-가능합니다"><span class="me-2">Kafka는 장기 보존 &amp; 리플레이(Reprocess)가 가능합니다.</span><a href="#kafka는-장기-보존--리플레이reprocess가-가능합니다" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Kafka는 메시지를 며칠~몇 달 이상 보존하고, 언제든 <strong>과거 데이터를 다시 읽어 처리</strong>합니다.<br /> 시간이 흐르면서 <strong>메시지 구조가 바뀌어도</strong> 과거 이벤트를 해석할 수 있어야 합니다.<br /> Avro는 <strong>작성 시점(writer) 스키마</strong>와 <strong>읽기 시점(reader) 스키마</strong>를 맞추는 규칙으로, 과거 데이터도 안전하게 디코딩할 수 있게 합니다.</p><h4 id="producerconsumer의-독립-배포가-이루어집니다"><span class="me-2">Producer/Consumer의 독립 배포가 이루어집니다</span><a href="#producerconsumer의-독립-배포가-이루어집니다" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>마이크로서비스 환경에서 Producer와 Consumer는 <strong>동시에 배포되지 않습니다.</strong></p><dl><dt>Producer가 필드를 추가/변경했는데 만약, Consumer가 구버전이라면..?<dd>JSON처럼 암묵적인 약속에만 의존하면 쉽게, 시스템이 깨질 수 있습니다.<dd>Avro + Schema Registry는 <strong>호환성 모드</strong>(BACKWARD/FORWARD/FULL 등)를 통해 “새 스키마 등록” 자체를 통제하고, 깨지는 변경을 차단합니다.</dl><h4 id="다양한-consumeranalytics-etl-alert-등에-대응해야-합니다"><span class="me-2">다양한 Consumer(Analytics, ETL, Alert 등)에 대응해야 합니다.</span><a href="#다양한-consumeranalytics-etl-alert-등에-대응해야-합니다" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>하나의 토픽을 <strong>여러 Consumer Group</strong>이 서로 다른 목적/언어/프레임워크로 읽는 환경입니다.<br /> 모든 Consumer가 <strong>정확한 필드 타입, 기본값, null 허용 여부</strong>를 알아야만 안정적으로 처리할 수 있습니다.</p><p><br /></p><h2 id="kafka와-rabbitmq전통적인-message-queue의-차이"><span class="me-2">Kafka와 RabbitMQ(전통적인 Message Queue)의 차이</span><a href="#kafka와-rabbitmq전통적인-message-queue의-차이" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Kafka와 RabbitMQ는 그 사용 목적과 디자인된 방향성에 차이가 있습니다.</p><p><strong>메시지 전송 방식</strong></p><ul><li><strong>RabbitMQ</strong>: 메시지 큐 방식으로 메시지를 큐에 저장한 후, 소비자가 가져가면 메시지가 삭제됩니다. <strong>메시지의 지속성</strong>보다는 즉각적인 전달이 중요할 때 적합합니다.<li><strong>Kafka</strong>: 로그 스트림 방식으로, 메시지가 브로커에 쓰여지면 <strong>로그처럼 유지</strong>됩니다. 소비자는 오프셋을 기반으로 메시지를 읽기 때문에 여러 소비자가 같은 메시지를 반복적으로 읽을 수 있으며, 메시지가 삭제되지 않고 설정된 기간 동안 저장됩니다.</ul><p><strong>데이터 영속성 및 내구성</strong></p><ul><li><strong>RabbitMQ</strong>: 메시지는 큐에 있고 기본적으로 소비 후 사라지므로 일시적인 데이터 전송에 적합합니다. 영구 큐 설정을 통해 메시지 영속성을 유지할 수 있지만, Kafka와 같은 로그 저장 방식과는 다릅니다.<li><strong>Kafka</strong>: 기본적으로 데이터가 로그로 유지되기 때문에 저장 기간을 설정하지 않는 한 삭제되지 않습니다. 따라서 <strong>데이터의 내구성이 높고</strong> 이벤트의 순차적 흐름을 유지하기 위해 적합합니다.</ul><p><strong>성능 및 처리량</strong></p><ul><li><strong>RabbitMQ</strong>: 낮은 지연 시간과 빠른 전송 속도를 제공하여, <strong>단일 메시지의 빠른 처리</strong>가 필요한 경우 유리합니다. 하지만 대용량의 데이터 스트리밍이나 로그 수집에는 성능이 한계에 도달할 수 있습니다.<li><strong>Kafka</strong>: 초당 수백 MB의 데이터를 처리할 수 있는 고성능 스트리밍 시스템으로, <strong>대용량의 실시간 로그 및 이벤트 스트리밍</strong>에 적합합니다.</ul><p><strong>메시지 순서와 중복 처리</strong></p><ul><li><strong>RabbitMQ</strong>: 메시지 순서를 보장하지는 않지만, 필요한 경우 순서가 보장되도록 설정할 수 있습니다. <strong>중복 처리 방지</strong>를 지원하며 각 메시지를 고유하게 식별하고 소비자에게 전달합니다.<li><strong>Kafka</strong>: 파티션 내에서 메시지 순서를 보장하며, 메시지가 중복될 수 있습니다. 여러 소비자가 같은 메시지를 반복적으로 읽을 수 있으므로 <strong>순차적 로그 분석</strong>에 적합합니다.</ul><p>RabbitMQ는 빠른 메시지 전달과 작업 큐가 필요한 마이크로서비스 통신에 적합하며, Kafka는 대규모 데이터 스트리밍 및 로그 처리에 강점을 갖고 있습니다.</p><p><br /></p><h2 id="적용-예시"><span class="me-2">적용 예시</span><a href="#적용-예시" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="espresso"><span class="me-2">Espresso</span><a href="#espresso" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Espresso는 LinkedIn의 분산 NoSQL DB입니다.<br /> Kafka는 그 Espresso에서 발생한 변경 사항을 복제·전파하기 위한 내부 커밋 로그/스트림(backbone)으로 쓰입니다.<br /> 즉, Espresso가 ‘Source of truth’라면, <strong>Kafka는 그 변경을 다른 레플리카나 시스템으로 정확하고 순서 있게 전달하는 파이프 역할</strong>을 합니다.</p><p><a href="/assets/img/for-post/What%20is%20Kafka/image%2019.png" class="popup img-link shimmer"><img src="/assets/img/for-post/What%20is%20Kafka/image%2019.png" alt="MySQL DB를 Kafka를 통해 Replication하는 Flow. Kafka에 이벤트를 전달하기까지만 보여줌." loading="lazy"></a> <em>Yelp에서 MySQL DB를 Kafka를 통해 Replication하는 Flow. Kafka에 이벤트를 전달하기까지만 보여줌. | <a href="https://engineeringblog.yelp.com/2016/08/streaming-mysql-tables-in-real-time-to-kafka.html">engineeringblog.yelp.com</a></em></p><h3 id="kubernetes에서-적용하기"><span class="me-2">Kubernetes에서 적용하기</span><a href="#kubernetes에서-적용하기" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Kubernetes에서 Kafka를 구성할때는, Operator를 통해 구성합니다.</p><h4 id="strimzi"><span class="me-2">Strimzi</span><a href="#strimzi" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Strimzi는 Kubernetes(또는 OpenShift) 위에서 Apache Kafka를 쉽게 배포·운영·보안·업그레이드할 수 있도록 해주는 오픈소스 Kafka 오퍼레이터 세트입니다.</p><h2 id="references"><span class="me-2">References</span><a href="#references" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><dl><dt>Apache Kafka | kafka.apache.org<dd><a href="https://kafka.apache.org/">Apache Kafka</a><dt>Kafka Overview | ibm-cloud-architecture.github.io<dd><a href="https://ibm-cloud-architecture.github.io/refarch-eda/technology/kafka-overview/">Kafka Overview - IBM Automation - Event-driven Solution - Sharing knowledge</a><dt>LinkedIn and Apache Kafka | linkedin.com<dd><a href="https://www.linkedin.com/pulse/linkedin-apache-kafka-muhammad-waqas-dilawar/">LinkedIn and Apache Kafka</a><dt>Kafka Ecosystem at LinkedIn | linkedin.com<dd><a href="https://www.linkedin.com/blog/engineering/open-source/kafka-ecosystem-at-linkedin">Kafka Ecosystem at LinkedIn</a><dt>Kafka at LinkedIn: Current and Future | engineering.linkedin.com<dd><a href="https://engineering.linkedin.com/kafka/kafka-linkedin-current-and-future">Kafka at LinkedIn: Current and Future</a><dt>Kafka on Kubernetes: Reloaded for fault tolerance | engineering.grab.com<dd><a href="https://engineering.grab.com/kafka-on-kubernetes">Kafka on Kubernetes: Reloaded for fault tolerance</a><dt>The Fundamentals of Apache Kafka Architecture | developer.confluent.io<dd><a href="https://developer.confluent.io/courses/architecture/get-started/">Apache Kafka Architecture Deep Dive</a><dt>How LinkedIn Customizes Its 7 Trillion Message Kafka Ecosystem | blog.bytebytego.com<dd><a href="https://blog.bytebytego.com/p/how-linkedin-customizes-its-7-trillion">How LinkedIn Customizes Its 7 Trillion Message Kafka Ecosystem</a><dt>Jay Kreps Hadoop Summit 2011 Building Kafka and LinkedIn’s Data Pipeline | youtube.com<dd><a href="https://youtu.be/Eq3i2m8aJBI?si=YwTu9QHnq9x8889L">Jay Kreps Hadoop Summit 2011 Building Kafka and LinkedIn’s Data Pipeline</a><dt>Building a Real-time Data Pipeline: Apache Kafka at LinkedIn | youtube.com<dd><a href="https://youtu.be/MA_3fPBFBtg?si=aLnAu9DlcTcH3XcI">Building a Real-time Data Pipeline: Apache Kafka at LinkedIn</a><dt>How Kafka Producers, Message Keys, Message Format and Serializers Work in Apache Kafka? | geeksforgeeks.org<dd><a href="https://www.geeksforgeeks.org/java/how-kafka-producers-message-keys-message-format-and-serializers-work-in-apache-kafka/">How Kafka Producers, Message Keys, Message Format and Serializers Work in Apache Kafka? - GeeksforGeeks</a><dt>Apache Kafka | d3s.mff.cuni.cz<dd><a href="https://d3s.mff.cuni.cz/files/teaching/nswi080/lectures/notes/ch02s11.html">2.11 Apache Kafka</a><dt>Apache Avro | avro.apache.org<dd><a href="https://avro.apache.org/docs/">Documentation</a><dt>About Schema Registry | docs.confluent.io<dd><a href="https://docs.confluent.io/platform/current/schema-registry/index.html">Schema Registry for Confluent Platform | Confluent Documentation</a><dt>Kafka Partition Strategies | github.com/AutoMQ<dd><a href="https://github.com/AutoMQ/automq/wiki/Kafka-Partition:-All-You-Need-to-Know-&amp;-Best-Practices">Kafka Partition: All You Need to Know &amp; Best Practices</a><dt>Kafka partition strategy | redpanda.com<dd><a href="https://www.redpanda.com/guides/kafka-tutorial-kafka-partition-strategy">Kafka Partition Strategies: Optimize Your Data Streaming</a><dt>Consumer Group Protocol | developer.confluent.io<dd><a href="https://developer.confluent.io/courses/architecture/consumer-group-protocol/">Consumer Group Protocol: Scalability and Fault Tolerance</a><dt>Guide to Consumer Offsets: Manual Control, Challenges, and the Innovations of KIP-1094 | confluent.io<dd><a href="https://www.confluent.io/blog/guide-to-consumer-offsets/">Kafka Consumer Offsets Guide—Basic Principles, Insights &amp; Enhancements</a><dt>Kafka Rebalancing: Triggers, Side Effects, and Mitigation Strategies | redpanda.com<dd><a href="https://www.redpanda.com/guides/kafka-performance-kafka-rebalancing">Kafka Rebalancing: Triggers, Effects, and Mitigation</a><dt>Kafka consumer lag—Measure and reduce | redpanda.com<dd><a href="https://www.redpanda.com/guides/kafka-performance-kafka-consumer-lag">Kafka consumer lag - Measure and reduce</a><dt>Kafka와 RabbitMQ비교 | ibm.com<dd><a href="https://www.ibm.com/think/topics/apache-kafka">What is Apache Kafka? | IBM</a><dt>Introducing Espresso - LinkedIn’s hot new distributed document store | engineering.linkedin.com<dd><a href="https://engineering.linkedin.com/espresso/introducing-espresso-linkedins-hot-new-distributed-document-store">Introducing Espresso - LinkedIn’s hot new distributed document store</a><dt>Espresso Database Replication with Kafka | confluent.io<dd><a href="https://www.confluent.io/ko-kr/resources/kafka-summit-2016/espresso-database-replication-kafka/">Espresso Database Replication with Kafka - Confluent | KR</a><dt>Streaming MySQL tables in real-time to Kafka | engineeringblog.yelp.com<dd><a href="https://engineeringblog.yelp.com/2016/08/streaming-mysql-tables-in-real-time-to-kafka.html">Streaming MySQL tables in real-time to Kafka</a><dt>strimzi | strimzi.io<dd><a href="https://strimzi.io/">Strimzi - Apache Kafka on Kubernetes</a><dt>Scaling Elasticsearch Across Data Centers With Kafka | elastic.co<dd><a href="https://www.elastic.co/blog/scaling_elasticsearch_across_data_centers_with_kafka">Scaling Elasticsearch Across Data Centers With Kafka</a></dl></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw me-1"></i> <a href="/categories/devops/">DevOps</a>, <a href="/categories/cloudnative/">CloudNative</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw me-1"></i> <a href="/tags/aws/" class="post-tag no-text-decoration" >aws</a> <a href="/tags/kubernetes/" class="post-tag no-text-decoration" >kubernetes</a> <a href="/tags/cncf/" class="post-tag no-text-decoration" >cncf</a> <a href="/tags/k8s/" class="post-tag no-text-decoration" >k8s</a> <a href="/tags/kafka/" class="post-tag no-text-decoration" >kafka</a></div><div class=" post-tail-bottom d-flex justify-content-between align-items-center mt-5 pb-2 " ><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper d-flex align-items-center"> <span class="share-label text-muted">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=What%20is%20Kafka?%20%7C%20CloudNative%20-%20KanghoonYi(Pour)&url=https%3A%2F%2Fblog.devpour.net%2Fposts%2FWhat-is-Kafka%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Twitter" aria-label="Twitter"> <i class="fa-fw fa-brands fa-square-x-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=What%20is%20Kafka?%20%7C%20CloudNative%20-%20KanghoonYi(Pour)&u=https%3A%2F%2Fblog.devpour.net%2Fposts%2FWhat-is-Kafka%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Facebook" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https%3A%2F%2Fblog.devpour.net%2Fposts%2FWhat-is-Kafka%2F&text=What%20is%20Kafka?%20%7C%20CloudNative%20-%20KanghoonYi(Pour)" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Telegram" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <button id="copy-link" aria-label="Copy link" class="btn small" data-bs-toggle="tooltip" data-bs-placement="top" title="Copy link" data-title-succeed="Link copied successfully!" > <i class="fa-fw fas fa-link pe-none fs-6"></i> </button> </span></div></div></div></article></main><aside aria-label="Panel" id="panel-wrapper" class="col-xl-3 ps-2 mb-5 text-muted"><div class="access"><section id="access-lastmod"><h2 class="panel-heading">Recently Updated</h2><ul class="content list-unstyled ps-0 pb-1 ms-1 mt-2"><li class="text-truncate lh-lg"> <a href="/posts/Redis/">Redis | Key Technologies - System Design Interview</a><li class="text-truncate lh-lg"> <a href="/posts/Consistent-Hashing/">Consistent Hashing | Core Concepts - System Design Interview</a><li class="text-truncate lh-lg"> <a href="/posts/k8s-introduction/">Kubernetes(Orchestration) 개론</a><li class="text-truncate lh-lg"> <a href="/posts/CAP-Theorem/">CAP Theorem(정리) | Core Concepts - System Design Interview</a><li class="text-truncate lh-lg"> <a href="/posts/What-is-CloudNativePG/">What is CloudNativePG? | CloudNative</a></ul></section><section><h2 class="panel-heading">Trending Tags</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/programming/">programming</a> <a class="post-tag btn btn-outline-primary" href="/tags/aws/">aws</a> <a class="post-tag btn btn-outline-primary" href="/tags/leetcode/">leetcode</a> <a class="post-tag btn btn-outline-primary" href="/tags/rust/">rust</a> <a class="post-tag btn btn-outline-primary" href="/tags/computer-science/">Computer Science</a> <a class="post-tag btn btn-outline-primary" href="/tags/cncf/">cncf</a> <a class="post-tag btn btn-outline-primary" href="/tags/k8s/">k8s</a> <a class="post-tag btn btn-outline-primary" href="/tags/kubernetes/">kubernetes</a> <a class="post-tag btn btn-outline-primary" href="/tags/algorithm/">algorithm</a> <a class="post-tag btn btn-outline-primary" href="/tags/architecture/">Architecture</a></div></section></div><section id="toc-wrapper" class="d-none ps-0 pe-4"><h2 class="panel-heading ps-3 mb-2">Contents</h2><nav id="toc"></nav></section></aside></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 px-md-4"><aside id="related-posts" aria-labelledby="related-label"><h3 class="mb-4" id="related-label">Further Reading</h3><nav class="row row-cols-1 row-cols-md-2 row-cols-xl-3 g-4 mb-4"><article class="col"> <a href="/posts/What-is-CloudNativePG/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1753084200" data-df="ll" > Jul 21, 2025 </time><h4 class="pt-0 my-2">What is CloudNativePG? | CloudNative</h4><div class="text-muted"><p>CloudNativePG 소개 CloudNativePG(이하 CNPG)는 PostgreSQL을 Kubernetes 환경에 네이티브하게 배포 및 운영할 수 있도록 해주는 오픈소스 오퍼레이터(Operator)입니다. CNCF(Cloud Native Computing Foundation)의 인큐베이팅 프로젝트로 채택되어 있으며, Postgre...</p></div></div></a></article><article class="col"> <a href="/posts/k8s-introduction/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1750777740" data-df="ll" > Jun 25, 2025 </time><h4 class="pt-0 my-2">Kubernetes(Orchestration) 개론</h4><div class="text-muted"><p>오늘날, IT서비스를 구성할때, Kubernetes와 같은 Orchestration 환경을 기본으로 시작하게 됩니다. 여기서는, 이런 배경을 알아보고자 합니다. Kubernetes의 성장 배경 Kubernetes가 오늘날 처럼 인프라 운영의 핵심으로 자리 잡기 까지, 여러 배경이 있습니다. 더 빨라진 비지니스 변화 → 잦은 배포가 발생합니다....</p></div></div></a></article><article class="col"> <a href="/posts/k8s-workloads/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1752036600" data-df="ll" > Jul 9, 2025 </time><h4 class="pt-0 my-2">Workloads | Kubernetes Deep Dive - 4</h4><div class="text-muted"><p>Kubernetes는 Infra에 대한 추상화를 제공하는 Framework입니다. 이때, 가장 기본이 되는 추상화 단위가 ‘Pod(파드)’입니다. 이 Pod를 어떻게 다루느냐(Workload Management)에 따라, 한 단계 더 추상화된, ‘Deployments’, ‘ReplicaSet’, ‘DaemonSet’등의 Workload Object가...</p></div></div></a></article></nav></aside><nav class="post-navigation d-flex justify-content-between" aria-label="Post Navigation"> <a href="/posts/What-is-CloudNativePG/" class="btn btn-outline-primary" aria-label="Older" ><p>What is CloudNativePG? | CloudNative</p></a> <a href="/posts/CAP-Theorem/" class="btn btn-outline-primary" aria-label="Newer" ><p>CAP Theorem(정리) | Core Concepts - System Design Interview</p></a></nav><script src="https://utteranc.es/client.js" repo="KanghoonYi/kanghoonyi.github.io" issue-term="pathname" crossorigin="anonymous" async ></script> <script type="text/javascript"> (function () { const origin = 'https://utteranc.es'; const lightTheme = 'github-light'; const darkTheme = 'github-dark'; let initTheme = lightTheme; const html = document.documentElement; if ( (html.hasAttribute('data-mode') && html.getAttribute('data-mode') === 'dark') || (!html.hasAttribute('data-mode') && window.matchMedia('(prefers-color-scheme: dark)').matches) ) { initTheme = darkTheme; } addEventListener('message', (event) => { let theme;if (event.origin === origin) {theme = initTheme; } else if (event.source === window && event.data && event.data.direction === ModeToggle.ID) {const mode = event.data.message; theme = mode === ModeToggle.DARK_MODE ? darkTheme : lightTheme; } else { return; } const message = { type: 'set-theme', theme: theme }; const utterances = document.getElementsByClassName('utterances-frame')[0].contentWindow; utterances.postMessage(message, origin); }); })(); </script><footer aria-label="Site Info" class=" d-flex flex-column justify-content-center text-muted flex-lg-row justify-content-lg-between align-items-lg-center pb-lg-3 " ><p>© <time>2025</time> <a href="https://github.com/KanghoonYi">KanghoonYi</a>. <span data-bs-toggle="tooltip" data-bs-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author." >Some rights reserved.</span></p><p>Using the <a data-bs-toggle="tooltip" data-bs-placement="top" title="v7.1.1" href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener" >Chirpy</a> theme for <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a>.</p></footer></div></div><div id="search-result-wrapper" class="d-flex justify-content-center d-none"><div class="col-11 content"><div id="search-hints"><section><h2 class="panel-heading">Trending Tags</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/programming/">programming</a> <a class="post-tag btn btn-outline-primary" href="/tags/aws/">aws</a> <a class="post-tag btn btn-outline-primary" href="/tags/leetcode/">leetcode</a> <a class="post-tag btn btn-outline-primary" href="/tags/rust/">rust</a> <a class="post-tag btn btn-outline-primary" href="/tags/computer-science/">Computer Science</a> <a class="post-tag btn btn-outline-primary" href="/tags/cncf/">cncf</a> <a class="post-tag btn btn-outline-primary" href="/tags/k8s/">k8s</a> <a class="post-tag btn btn-outline-primary" href="/tags/kubernetes/">kubernetes</a> <a class="post-tag btn btn-outline-primary" href="/tags/algorithm/">algorithm</a> <a class="post-tag btn btn-outline-primary" href="/tags/architecture/">Architecture</a></div></section></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><aside aria-label="Scroll to Top"> <button id="back-to-top" type="button" class="btn btn-lg btn-box-shadow"> <i class="fas fa-angle-up"></i> </button></aside></div><div id="mask"></div><script src="https://cdn.jsdelivr.net/combine/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js,npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.umd.min.js,npm/glightbox@3.3.0/dist/js/glightbox.min.js,npm/clipboard@2.0.11/dist/clipboard.min.js,npm/dayjs@1.11.13/dayjs.min.js,npm/dayjs@1.11.13/locale/en.js,npm/dayjs@1.11.13/plugin/relativeTime.js,npm/dayjs@1.11.13/plugin/localizedFormat.js,npm/tocbot@4.29.0/dist/tocbot.min.js"></script> <script src="/assets/js/dist/post.min.js"></script> <script>SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<article class="px-1 px-sm-2 px-lg-4 px-xl-0"><header><h2><a href="{url}">{title}</a></h2><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div></header><p>{snippet}</p></article>', noResultsText: '<p class="mt-5">Oops! No results found.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="me-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
