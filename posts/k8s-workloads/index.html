<!doctype html><html lang="ko" data-mode="light"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" ><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="Workloads Kubernetes Deep Dive - 4" /><meta name="author" content="KanghoonYi(pour)" /><meta property="og:locale" content="ko" /><meta name="description" content="Kubernetes는 Infra에 대한 추상화를 제공하는 Framework입니다. 이때, 가장 기본이 되는 추상화 단위가 ‘Pod(파드)’입니다. 이 Pod를 어떻게 다루느냐(Workload Management)에 따라, 한 단계 더 추상화된, ‘Deployments’, ‘ReplicaSet’, ‘DaemonSet’등의 Workload Object가 있습니다. 이 Post에서는 Kubernetes에서의 각 Wokrload를 살펴보고, 이해하려고 합니다." /><meta property="og:description" content="Kubernetes는 Infra에 대한 추상화를 제공하는 Framework입니다. 이때, 가장 기본이 되는 추상화 단위가 ‘Pod(파드)’입니다. 이 Pod를 어떻게 다루느냐(Workload Management)에 따라, 한 단계 더 추상화된, ‘Deployments’, ‘ReplicaSet’, ‘DaemonSet’등의 Workload Object가 있습니다. 이 Post에서는 Kubernetes에서의 각 Wokrload를 살펴보고, 이해하려고 합니다." /><link rel="canonical" href="https://blog.devpour.net/posts/k8s-workloads/" /><meta property="og:url" content="https://blog.devpour.net/posts/k8s-workloads/" /><meta property="og:site_name" content="KanghoonYi(Pour)" /><meta property="og:image" content="https://blog.devpour.net/assets/img/for-post/k8s%20workloads/k8s-workloads-cover.jpg" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2025-07-09T13:50:00+09:00" /><meta name="twitter:card" content="summary_large_image" /><meta property="twitter:image" content="https://blog.devpour.net/assets/img/for-post/k8s%20workloads/k8s-workloads-cover.jpg" /><meta property="twitter:title" content="Workloads Kubernetes Deep Dive - 4" /><meta name="google-site-verification" content="rsx_-5MJzSR_3NNCqHNe9IxnKJxlD8Eid8_wN8e9c1I" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"KanghoonYi(pour)","url":"https://www.linkedin.com/in/pour/"},"dateModified":"2025-07-09T13:50:00+09:00","datePublished":"2025-07-09T13:50:00+09:00","description":"Kubernetes는 Infra에 대한 추상화를 제공하는 Framework입니다. 이때, 가장 기본이 되는 추상화 단위가 ‘Pod(파드)’입니다. 이 Pod를 어떻게 다루느냐(Workload Management)에 따라, 한 단계 더 추상화된, ‘Deployments’, ‘ReplicaSet’, ‘DaemonSet’등의 Workload Object가 있습니다. 이 Post에서는 Kubernetes에서의 각 Wokrload를 살펴보고, 이해하려고 합니다.","headline":"Workloads Kubernetes Deep Dive - 4","image":"https://blog.devpour.net/assets/img/for-post/k8s%20workloads/k8s-workloads-cover.jpg","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.devpour.net/posts/k8s-workloads/"},"url":"https://blog.devpour.net/posts/k8s-workloads/"}</script><title>Workloads | Kubernetes Deep Dive - 4 | KanghoonYi(Pour)</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="KanghoonYi(Pour)"><meta name="application-name" content="KanghoonYi(Pour)"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="/assets/css/jekyll-theme-chirpy.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.6.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.29.0/dist/tocbot.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/glightbox@3.3.0/dist/css/glightbox.min.css"><body><aside aria-label="Sidebar" id="sidebar" class="d-flex flex-column align-items-end"><header class="profile-wrapper"> <a href="/" id="avatar" class="rounded-circle"><img src="/assets/img/pour_profile_img.png" width="112" height="112" alt="avatar" onerror="this.style.display='none'"></a><h1 class="site-title"> <a href="/">KanghoonYi(Pour)</a></h1><p class="site-subtitle fst-italic mb-0">안녕하세요~ Software Engineer pour입니다 This is Pour.</p></header><nav class="flex-column flex-grow-1 w-100 ps-0"><ul class="nav"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle"></i> <span>ABOUT</span> </a></ul></nav><div class="sidebar-bottom d-flex flex-wrap align-items-center w-100"> <a href="https://github.com/KanghoonYi" aria-label="github" target="_blank" rel="noopener noreferrer" > <i class="fab fa-github"></i> </a> <a href="https://twitter.com/" aria-label="twitter" target="_blank" rel="noopener noreferrer" > <i class="fa-brands fa-x-twitter"></i> </a> <a href="javascript:location.href = 'mailto:' + ['rkdgnsdls','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></aside><div id="main-wrapper" class="d-flex justify-content-center"><div class="container d-flex flex-column px-xxl-5"><header id="topbar-wrapper" aria-label="Top Bar"><div id="topbar" class="d-flex align-items-center justify-content-between px-lg-3 h-100" ><nav id="breadcrumb" aria-label="Breadcrumb"> <span> <a href="/">Home</a> </span> <span>Workloads | Kubernetes Deep Dive - 4</span></nav><button type="button" id="sidebar-trigger" class="btn btn-link"> <i class="fas fa-bars fa-fw"></i> </button><div id="topbar-title"> Post</div><button type="button" id="search-trigger" class="btn btn-link"> <i class="fas fa-search fa-fw"></i> </button> <search id="search" class="align-items-center ms-3 ms-lg-0"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..." > </search> <button type="button" class="btn btn-link text-decoration-none" id="search-cancel">Cancel</button></div></header><div class="row flex-grow-1"><main aria-label="Main Content" class="col-12 col-lg-11 col-xl-9 px-md-4"><article class="px-1"><header><h1 data-toc-skip>Workloads | Kubernetes Deep Dive - 4</h1><div class="post-meta text-muted"> <span> Posted <time data-ts="1752036600" data-df="ll" data-bs-toggle="tooltip" data-bs-placement="bottom" > Jul 9, 2025 </time> </span><div class="mt-3 mb-3"> <a href="/assets/img/for-post/k8s%20workloads/k8s-workloads-cover.jpg" class="popup img-link preview-img shimmer"><img src="/assets/img/for-post/k8s%20workloads/k8s-workloads-cover.jpg" alt="Preview Image" width="1200" height="630" loading="lazy"></a></div><div class="d-flex justify-content-between"> <span> By <em> <a href="https://www.linkedin.com/in/pour/">KanghoonYi(pour)</a> </em> </span><div> <span class="readtime" data-bs-toggle="tooltip" data-bs-placement="bottom" title="7103 words" > <em>39 min</em> read</span></div></div></div></header><div class="content"><p>Kubernetes는 Infra에 대한 추상화를 제공하는 Framework입니다. 이때, 가장 기본이 되는 추상화 단위가 ‘Pod(파드)’입니다.<br /> 이 Pod를 어떻게 다루느냐(Workload Management)에 따라, 한 단계 더 추상화된, ‘Deployments’, ‘ReplicaSet’, ‘DaemonSet’등의 Workload Object가 있습니다.<br /> 이 Post에서는 Kubernetes에서의 각 Wokrload를 살펴보고, 이해하려고 합니다.</p><h2 id="pod파드"><span class="me-2">Pod(파드)</span><a href="#pod파드" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><blockquote><p>Pods are the smallest deployable units of computing that you can create and manage in Kubernetes.<br /> - from <a href="https://kubernetes.io/docs/concepts/workloads/pods/">kubernetes.io</a></p></blockquote><dl><dt>Pod는<dd>Kubernetes의 가장 작은 단위의 배포가능한(deployable) 컴퓨팅 단위입니다.<dd>하나 혹은 여러 Container를 포함하는 Group입니다.<dd>Pod안에서, Container들 끼리 Storage와 Network 자원을 공유합니다.</dl><h3 id="pod-사용-방법-2가지"><span class="me-2">Pod 사용 방법 2가지</span><a href="#pod-사용-방법-2가지" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h4 id="하나의-container를-돌리는-pod"><span class="me-2">하나의 Container를 돌리는 Pod</span><a href="#하나의-container를-돌리는-pod" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Pod당 1개의 container를 포함하여 운영합니다. 이 경우, Kubernetes가 Container를 직접관리하지 못하니, Pod로 Wrapping하여 관리합니다.</p><div class="language-yaml highlighter-rouge"><div class="code-header"> <span data-label-text="YAML"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Pod</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">nginx</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">containers</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">nginx</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">nginx:1.14.2</span>
    <span class="na">ports</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">containerPort</span><span class="pi">:</span> <span class="m">80</span>
</pre></table></code></div></div><h4 id="여러개의-container를-돌리는-pod"><span class="me-2">여러개의 Container를 돌리는 Pod</span><a href="#여러개의-container를-돌리는-pod" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Container간 서로 강하게 엮여있는(tightly coupled) 경우, Pod안에 여러 Container를 포함시켜 운영할 수 있습니다.</p><blockquote class="prompt-info"><p>만약, 동일한 Container를 여러개 돌리고 싶은 경우라면, 이 방식이 아니라, 뒤에 나올 ‘ReplicaSet’을 고려해야 합니다.</p></blockquote><p><br /></p><h3 id="pod안에서의-자원resource-공유-원리"><span class="me-2">Pod안에서의 자원(Resource) 공유 원리</span><a href="#pod안에서의-자원resource-공유-원리" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><a href="/assets/img/for-post/k8s%20workloads/image.png" class="popup img-link shimmer"><img src="/assets/img/for-post/k8s%20workloads/image.png" alt="Linux technologies that contribute to containers" loading="lazy"></a> <em>Linux technologies that contribute to containers</em></p><blockquote><p>The shared context of a Pod is a set of Linux namespaces, cgroups, and potentially other facets of isolation - the same things that isolate a container.<br /> - from kubernetes.io</p></blockquote><p>Pod안의 Container들끼리는 Storage(Volume), Network, 컴퓨팅 자원을 공유합니다.<br /> 이런 Pod 내부 Container들끼리의 Context공유(Resource 공유)는, Linux의 namespaces와 cgroups(Control Groups)과 다른 격리 기술의 집합(set)으로 이루어져 있습니다.</p><dl><dt>Namespaces로<dd>Pod별로 Process 격리(Isolation)를 구현하고,<dt>cgroups로<dd>Container별로(즉, Process별로) 자원(Resource)을 제어합니다.</dl><h4 id="linux의-namespaces"><span class="me-2">Linux의 namespaces</span><a href="#linux의-namespaces" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p><a href="/assets/img/for-post/k8s%20workloads/image%201.png" class="popup img-link w-50 shimmer"><img src="/assets/img/for-post/k8s%20workloads/image%201.png" alt="Pod와 linux namespace의 관계" loading="lazy"></a> <em>Pod와 linux namespace의 관계</em></p><p>‘Namespaces’는 Linux kernel 기능중 하나입니다.<br /> 프로세스별로 ‘가상화된’ 시스템 리소스를 제공하기 위해 도입한 기능입니다. 네임스페이스 덕분에 서로 격리된 프로세스 그룹이 각자 독립적인 환경(파일 시스템, 네트워크, 프로세스 ID 등)을 갖고 동작할 수 있습니다.</p><blockquote class="prompt-info"><p>여기서, ‘시스템 리소스’는 ‘파일 시스템 마운트 정보’, ‘프로세스 식별자(PID) 공간’, ‘네트워크 스택’, ‘cgroup 계층 구조’등이 해당됩니다.</p></blockquote><p>Kubernetes에서, <strong>하나의 Pod는 실제로 “네임스페이스 집합(namespace bundle, process나 network namespace의 집합을 얘기함)” 위에서 돌아갑니다.</strong></p><p>Pod에 사용하는 namespace의 컨셉을 이해하기 위해, 그 일부를 함께 정리하고자 합니다.</p><ul><li><p>Process isolation(PID namespace)<br /> OS의 ‘Process’단위의 격리(isolation)를 위한 namespace입니다.<br /> Pod는 각각의 PID namespace를 가지며, 같은 Host머신에서도 Process가 격리(isolation)되어 작동합니다.</p><li><p>Network interfaces(net namespace) ‘net namespace’는 ‘Process’에 새로운 IP(Virtual IP)를 부여하여, 독립적인 Port운영을 가능하게 해줍니다.<br /> 예를 들면, 메일서버를 운영한다고 했을때, 해당 메일 서버가 25 Port를 요구하기 때문에, Host당 하나만 띄울 수 있습니다(PID 격리가 되어있다 하더라도).<br /> ‘net namespace’는 IP레벨의 격리를 제공하여, <strong>같은 Host에서도 Network interface를 Pod단위로 분리시켜 줍니다.</strong></p><li><p>Cgroups<br /> Linux안에서 시스템의 리소스를 조정하는 메커니즘(mechanism) 입니다.<br /> 밑에서 더 자세히 다룹니다.</p><li><p>등등…</p></ul><h4 id="linux의-cgroupscontrol-groups"><span class="me-2">Linux의 cgroups(Control Groups)</span><a href="#linux의-cgroupscontrol-groups" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>‘cgroups’은 Process단위로 Resource(CPU, memory, disk I/O 등)을 격리(isolate)하고, 계산하고(accounts), 제한(limit)하는 Kernel 기능입니다.</p><p>cgroups의 기능은 다음과 같습니다.</p><ul><li><p>리소스 제한(Resource limiting)<br /> 메모리 사용량(파일 시스템 캐시 포함), 디스크 I/O 대역폭, CPU quota, CPU set, 프로세스당 최대 열린 파일 수 등 그룹 전체에 대한 상한선을 설정할 수 있습니다.</p><li><p>우선순위 조절(Prioritization)<br /> CPU 스케줄링 비중(cpu.shares)이나 블록 디바이스 I/O 우선순위(blkio.weight)를 조절해, 특정 그룹이 더 많은 리소스를 확보하도록 할 수 있습니다 .</p><li><p>리소스 사용량 측정 및 계산(Accounting)<br /> 그룹 단위로 CPU 사용량, 메모리 사용량, I/O 활동 등을 계측하여, 과금(billing)·모니터링·로그 수집 등에 활용할 수 있습니다.</p><li><p>프로세스 제어(Control)<br /> 프로세스 그룹 전체를 freeze/unfreeze(일시 중단/재개)하거나, checkpoint &amp; restore(검사점 생성 후 재시작) 기능을 통해 상태를 보존·복원할 수 있습니다</p></ul><blockquote class="prompt-info"><p>‘cgroups v1’에서는 다중 계층을 사용하여, 각각의 cgroup 정책에 따라 별도의 Controller를 사용할 수 있지만, 복잡성이 높아지는 원인이 되었습니다.<br /> 최신버전인 ‘cgroups v2’에서는 변경되어, 단일 계층에서 Controller(리소스 관리를 위한)를 관리합니다.</p></blockquote><p>아래는 Kubenetes에서 Pod를 정의하는 부분에서, cgroup과 관련이 있는 부분을 표시하고 있습니다.</p><div class="language-yaml highlighter-rouge"><div class="code-header"> <span data-label-text="YAML"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Pod</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">cgroup-demo-pod</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">containers</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">web-server</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">nginx:latest</span>
    <span class="c1"># ───────────────────────────────────────────────────────────────</span>
    <span class="c1"># 이 부분이 cgroup으로 구현되는, 리소스 격리 설정입니다.</span>
    <span class="na">resources</span><span class="pi">:</span>
      <span class="c1"># 최소 보장(request)와 최대 제한(limit)을 지정합니다.</span>
      <span class="na">requests</span><span class="pi">:</span>
        <span class="na">cpu</span><span class="pi">:</span> <span class="s2">"</span><span class="s">250m"</span>        <span class="c1"># 이 컨테이너에 최소 0.25 CPU 코어를 보장.</span>
        <span class="na">memory</span><span class="pi">:</span> <span class="s2">"</span><span class="s">128Mi"</span>    <span class="c1"># 최소 128MiB 메모리를 보장.</span>
      <span class="na">limits</span><span class="pi">:</span>
        <span class="na">cpu</span><span class="pi">:</span> <span class="s2">"</span><span class="s">500m"</span>        <span class="c1"># 최대 0.5 CPU 코어까지만 사용 가능.</span>
        <span class="na">memory</span><span class="pi">:</span> <span class="s2">"</span><span class="s">256Mi"</span>    <span class="c1"># 최대 256MiB 메모리까지만 사용 가능.</span>
    <span class="c1"># ───────────────────────────────────────────────────────────────</span>
    <span class="na">ports</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">containerPort</span><span class="pi">:</span> <span class="m">80</span>
</pre></table></code></div></div><p><br /></p><h3 id="pod-lifecycle"><span class="me-2">Pod Lifecycle</span><a href="#pod-lifecycle" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><blockquote><p>Like individual application containers, Pods are considered to be relatively ephemeral (rather than durable) entities.<br /> - from kubernetes.io</p></blockquote><p>Pod는 영속적(durable)이라기 보다, 일시적인(ephemeral) entity로 여겨집니다.<br /> Kubernetes에서는 Pod의 Lifecycle를 통해, 일시적으로 사용되는 Pod의 상태를 추상화하였습니다.</p><blockquote class="prompt-info"><p>반복적이고 빠르게, 제거되고 생성되기 때문에, Lifecycle이 필요하다는 뜻</p></blockquote><h4 id="pod와-fault-recoveryself-healing"><span class="me-2">Pod와 Fault Recovery(Self-Healing)</span><a href="#pod와-fault-recoveryself-healing" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Pod는 포함하고 있는 Container중 하나가 ‘fail’상태에 빠지면, 해당 Container를 재시작하려고 시도합니다.<br /> 하지만, Pod을 복구할 수 없는 상태에 빠진 경우, <strong>Kubernetes는 더 이상 Pod자체를 복구하려고 하지 않습니다.</strong><br /> 문제가 있는 Pod을 제거하고, 다른 구성요소(Control plane의 <a href="https://blog.devpour.net/posts/k8s-control-plane/#kube-controller-manager">Control Manager</a>)를 통해 <strong>Pod을 재생성하여 복구 합니다.</strong></p><blockquote><p>A given Pod (as defined by a UID) is never “rescheduled” to a different node; instead, that Pod can be replaced by a new, near-identical Pod. - from <a href="https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#pod-fault-recovery">kubernetes.io</a></p></blockquote><p>이미 생성된 Pod는 <strong>절대로 다른 노드에 재배치 되지 않습니다</strong>. 대신에, <strong>새로운 Pod으로 대체됩니다.</strong>(Pod의 <code class="language-plaintext highlighter-rouge">.metadata.uid</code> 가 바뀝니다. 즉, 새로 생성됩니다.)</p><blockquote class="prompt-info"><p>이 경우, 새롭게 생성된 Pod이 같은 Node에 배치되는것을 보장하지 않습니다. (Pod를 새로 생성하는거기 때문에, 당연한 얘기일 수도.. filtering을 통해 같은 Node로 배치되게 유도할 수는 있습니다.)</p></blockquote><h4 id="pod-phase"><span class="me-2">Pod phase</span><a href="#pod-phase" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Pod의 status는 여러 정보를 포함한 Object Field로 구성되어 있습니다.<br /> 여기에는 <code class="language-plaintext highlighter-rouge">phase</code> 라는 field가 있는데, 이는 추상화된 lifecycle의 ‘high-level summary’입니다.<br /> Pod의 phase는 아래의 List로 제한되어 있으며, 이외의 다른 어떤 값도 존재해선 안됩니다.</p><ul><li><p>Pending<br /> 클러스터가 Pod ‘정의’를 수용했으나, 아직 스케줄링이 완료되지 않았거나 컨테이너 이미지 다운로드·생성 과정이 진행 중인 상태입니다.</p><li><p>Running<br /> 최소 하나의 “주요(main)” 컨테이너가 정상적으로 시작된 상태. 모든 컨테이너가 생성되어 Running 상태가 되면 이 Phase로 진입.</p><li><p>Succeeded<br /> 모든 컨테이너가 정상 종료(Exit 0)하고, 재시작 정책에 따라 재시작되지 않을 때. 주로 일회성 작업(Job/CronJob이 생성한 Pod)에서 볼 수 있습니다.</p><li><p>Failed<br /> 적어도 하나의 컨테이너가 비정상 종료(Non-zero Exit)하거나, 시스템(OOM 등)에 의해 강제 종료된 상태.이 Phase로 들어가면 다시 다른 Phase로 전환되지 않습니다.</p><li><p>Unknown<br /> kube-apiserver가 해당 Pod의 상태를 확인할 수 없을 때. 네트워크 단절이나 kubelet 오류 등으로 인해 노드와의 통신이 끊긴 경우에 주로 발생합니다.</p></ul><h4 id="crashloopbackoff이-phase라고-혼동하지-마세요"><span class="me-2">CrashLoopBackOff이 phase라고 혼동하지 마세요</span><a href="#crashloopbackoff이-phase라고-혼동하지-마세요" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Pod가 반복적으로 ‘시작 실패’를 겪을 때, <code class="language-plaintext highlighter-rouge">CrashLoopBackOff</code> 값이 kubectl명령어로 나오는 status field에 노출 될 수 있습니다.(아래 예시 참고)</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="nv">$ </span>kubectl get pods <span class="nt">--namespace</span><span class="o">=</span>alessandras-namespace

 NAMESPACE               NAME               READY   STATUS             RESTARTS   AGE
alessandras-namespace   alessandras-pod    0/1     CrashLoopBackOff   200        2d9h
</pre></table></code></div></div><p>마찬가지로, <code class="language-plaintext highlighter-rouge">Terminating</code> 값이 Status에 표시될 때도 있습니다.<br /> 이때, 이 <code class="language-plaintext highlighter-rouge">CrashLoopBackoff</code> 와 <code class="language-plaintext highlighter-rouge">Terminating</code> 값이 Pod의 Phase값은 아닙니다.<br /> kubectl에서 표시되는 Status는 유저 친화적인(직관적인) 값일 뿐이고, 반드시 Pod의 Phase값이 위치하는건 아닙니다.</p><p><br /></p><h3 id="init-containers"><span class="me-2">Init Containers</span><a href="#init-containers" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><dl><dt>‘Init Containers’는<dd>Pod initialization 과정에서, Main App container가 실행되기전에 실행되어, initialization작업을 하는 Container입니다.<dd>항상 Container 작업이 성공적으로 완료(complete successfully)되어야 합니다.<dd>작업이 실패하게 되면, 성공할때까지 재실행 합니다.(<code class="language-plaintext highlighter-rouge">restartPolicy</code> 가 있다면, 해당 정책에 따라 ‘Pod fail’로 다루게 됩니다.)</dl><h4 id="일반-container와의-차이점"><span class="me-2">일반 Container와의 차이점</span><a href="#일반-container와의-차이점" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>‘lifecycle’, ‘livenessProbe’, ‘readinessProbe’, or ‘startupProbe’ fields를 지원하지 않습니다.<li>Pod이 ‘Ready’상태에 들어가기전에 모든 작업을 완료하고, 종료되어야 합니다.<li>만약, 여러개의 init Container를 정의하였다면, 정의한 순서대로 실행되며, 반드시 이전의 container 작업이 성공적으로 완료되어야 합니다.<li>Main App Container와 같은 시스템 Resource를 사용하지만, 상호작용하지 않습니다.<blockquote><p>Init containers share the same resources (CPU, memory, network) with the main application containers but do not interact directly with them. They can, however, use shared volumes for data exchange.<br /> - from <a href="https://kubernetes.io/docs/concepts/workloads/pods/init-containers/#differences-from-sidecar-containers">kubernetes.io</a></p></blockquote></ul><p>아래는 Init Container의 예시입니다.</p><div class="language-yaml highlighter-rouge"><div class="code-header"> <span data-label-text="YAML"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Pod</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">myapp-pod</span>
  <span class="na">labels</span><span class="pi">:</span>
    <span class="na">app.kubernetes.io/name</span><span class="pi">:</span> <span class="s">MyApp</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">containers</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">myapp-container</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">busybox:1.28</span>
    <span class="na">command</span><span class="pi">:</span> <span class="pi">[</span><span class="s1">'</span><span class="s">sh'</span><span class="pi">,</span> <span class="s1">'</span><span class="s">-c'</span><span class="pi">,</span> <span class="s1">'</span><span class="s">echo</span><span class="nv"> </span><span class="s">The</span><span class="nv"> </span><span class="s">app</span><span class="nv"> </span><span class="s">is</span><span class="nv"> </span><span class="s">running!</span><span class="nv"> </span><span class="s">&amp;&amp;</span><span class="nv"> </span><span class="s">sleep</span><span class="nv"> </span><span class="s">3600'</span><span class="pi">]</span>
  <span class="na">initContainers</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">init-myservice</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">busybox:1.28</span>
    <span class="na">command</span><span class="pi">:</span> <span class="pi">[</span><span class="s1">'</span><span class="s">sh'</span><span class="pi">,</span> <span class="s1">'</span><span class="s">-c'</span><span class="pi">,</span> <span class="s2">"</span><span class="s">until</span><span class="nv"> </span><span class="s">nslookup</span><span class="nv"> </span><span class="s">myservice.$(cat</span><span class="nv"> </span><span class="s">/var/run/secrets/kubernetes.io/serviceaccount/namespace).svc.cluster.local;</span><span class="nv"> </span><span class="s">do</span><span class="nv"> </span><span class="s">echo</span><span class="nv"> </span><span class="s">waiting</span><span class="nv"> </span><span class="s">for</span><span class="nv"> </span><span class="s">myservice;</span><span class="nv"> </span><span class="s">sleep</span><span class="nv"> </span><span class="s">2;</span><span class="nv"> </span><span class="s">done"</span><span class="pi">]</span>
  <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">init-mydb</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">busybox:1.28</span>
    <span class="na">command</span><span class="pi">:</span> <span class="pi">[</span><span class="s1">'</span><span class="s">sh'</span><span class="pi">,</span> <span class="s1">'</span><span class="s">-c'</span><span class="pi">,</span> <span class="s2">"</span><span class="s">until</span><span class="nv"> </span><span class="s">nslookup</span><span class="nv"> </span><span class="s">mydb.$(cat</span><span class="nv"> </span><span class="s">/var/run/secrets/kubernetes.io/serviceaccount/namespace).svc.cluster.local;</span><span class="nv"> </span><span class="s">do</span><span class="nv"> </span><span class="s">echo</span><span class="nv"> </span><span class="s">waiting</span><span class="nv"> </span><span class="s">for</span><span class="nv"> </span><span class="s">mydb;</span><span class="nv"> </span><span class="s">sleep</span><span class="nv"> </span><span class="s">2;</span><span class="nv"> </span><span class="s">done"</span><span class="pi">]</span>
</pre></table></code></div></div><p><br /></p><h3 id="sidecar-containers"><span class="me-2">Sidecar Containers</span><a href="#sidecar-containers" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><dl><dt>‘Sidecar Containers’는<dd>Pod 안에서, Main Container와 함께 계속 실행되는 Container입니다.<dd>Main Application Container가 시작되기 전에, 먼저 시작합니다.<dd>App Container의 기능을 확장하거나 강화하기 위해 사용됩니다(<strong>App code변경 없이</strong>).<dd>예를 들면, 로깅, 모니터링, 보안, 데이터 동기화 같은것이 있습니다.</dl><h4 id="kubernetes에서의-sidecar-containers"><span class="me-2">Kubernetes에서의 Sidecar containers</span><a href="#kubernetes에서의-sidecar-containers" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li><p>‘init container’의 special case 입니다.(즉, init container의 한 종류입니다.)<br /> Kubernetes에서, ‘Sidecar container’는 ‘init container’의 special case 입니다.<br /> ‘Sidecar container’는 Pod의 부팅(startup)이후에도 계속 실행된 상태로 있습니다. (보통의 ‘init container’는 Pod의 부팅이후에는 종료됩니다.)<br /> ‘init container’와 다르게, sidecar container가 ‘running’상태라면, 종료되지 않고 다음 container가 실행됩니다.</p><li><p>동일 Pod의 네임스페이스(namespaces)와 볼륨(volumes), 네트워크를 공유합니다.</p><li>Cluster단위에서 <a href="https://kubernetes.io/docs/reference/command-line-tools-reference/feature-gates/">feature</a>를 enable해줘야 합니다.<div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>  <span class="nt">--feature-gates</span><span class="o">=</span>..,SidecarContainers<span class="o">=</span><span class="nb">true</span>
</pre></table></code></div></div><p>위와 같이 Sidecar를 사용하도록 설정하면, <code class="language-plaintext highlighter-rouge">initContainers.restartPolicy</code> 를 설정할 수 있게 됩니다.(재실행 가능하도록 설정)</p><li>종료시엔, Main Container가 완전히 종료되고, Sidecar의 shutdown이 실행됩니다.(Pod에 정의된 순서의 역순으로 실행)<blockquote class="prompt-info"><p>이는 종료시에도, Sidecar가 다른 Container를 보조하는 역할이 빈틈없이 수행되도록 합니다.</p></blockquote></ul><p>아래는 Sidecar 정의 예시입니다.</p><div class="language-yaml highlighter-rouge"><div class="code-header"> <span data-label-text="YAML"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre><td class="rouge-code"><pre><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">apps/v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Deployment</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">myapp</span>
  <span class="na">labels</span><span class="pi">:</span>
    <span class="na">app</span><span class="pi">:</span> <span class="s">myapp</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">replicas</span><span class="pi">:</span> <span class="m">1</span>
  <span class="na">selector</span><span class="pi">:</span>
    <span class="na">matchLabels</span><span class="pi">:</span>
      <span class="na">app</span><span class="pi">:</span> <span class="s">myapp</span>
  <span class="na">template</span><span class="pi">:</span>
    <span class="na">metadata</span><span class="pi">:</span>
      <span class="na">labels</span><span class="pi">:</span>
        <span class="na">app</span><span class="pi">:</span> <span class="s">myapp</span>
    <span class="na">spec</span><span class="pi">:</span>
      <span class="na">containers</span><span class="pi">:</span>
        <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">myapp</span>
          <span class="na">image</span><span class="pi">:</span> <span class="s">alpine:latest</span>
          <span class="na">command</span><span class="pi">:</span> <span class="pi">[</span><span class="s1">'</span><span class="s">sh'</span><span class="pi">,</span> <span class="s1">'</span><span class="s">-c'</span><span class="pi">,</span> <span class="s1">'</span><span class="s">while</span><span class="nv"> </span><span class="s">true;</span><span class="nv"> </span><span class="s">do</span><span class="nv"> </span><span class="s">echo</span><span class="nv"> </span><span class="s">"logging"</span><span class="nv"> </span><span class="s">&gt;&gt;</span><span class="nv"> </span><span class="s">/opt/logs.txt;</span><span class="nv"> </span><span class="s">sleep</span><span class="nv"> </span><span class="s">1;</span><span class="nv"> </span><span class="s">done'</span><span class="pi">]</span>
          <span class="na">volumeMounts</span><span class="pi">:</span>
            <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">data</span>
              <span class="na">mountPath</span><span class="pi">:</span> <span class="s">/opt</span>
      <span class="na">initContainers</span><span class="pi">:</span>
        <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">logshipper</span>
          <span class="na">image</span><span class="pi">:</span> <span class="s">alpine:latest</span>
          <span class="na">restartPolicy</span><span class="pi">:</span> <span class="s">Always</span>
          <span class="na">command</span><span class="pi">:</span> <span class="pi">[</span><span class="s1">'</span><span class="s">sh'</span><span class="pi">,</span> <span class="s1">'</span><span class="s">-c'</span><span class="pi">,</span> <span class="s1">'</span><span class="s">tail</span><span class="nv"> </span><span class="s">-F</span><span class="nv"> </span><span class="s">/opt/logs.txt'</span><span class="pi">]</span>
          <span class="na">volumeMounts</span><span class="pi">:</span>
            <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">data</span>
              <span class="na">mountPath</span><span class="pi">:</span> <span class="s">/opt</span>
      <span class="na">volumes</span><span class="pi">:</span>
        <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">data</span>
          <span class="na">emptyDir</span><span class="pi">:</span> <span class="pi">{}</span>
</pre></table></code></div></div><p><br /></p><h3 id="pod의-리소스-요청-기준"><span class="me-2">Pod의 리소스 요청 기준</span><a href="#pod의-리소스-요청-기준" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Pod에는 여러 Container가 포함될 수 있습니다. 이때, Container의 리소스(CPU같은) 정의는 어떻게 처리되어 Pod로서 스케쥴링 되는지 알아봅니다.<br /> <br /></p><p>컨테이너들은 Pod 단위로 네임스페이스(namespaces)와 볼륨을 공유하지만, 리소스(CPU·메모리·I/O) 관리는 컨테이너별 cgroup을 통해 개별적으로 격리・제어됩니다.</p><ul><li>requests 합산<br /> 스케줄러는 Pod 스펙의 각 컨테이너 <code class="language-plaintext highlighter-rouge">resources.requests</code> 값을 모두 더한 만큼의 CPU/메모리 리소스가 노드에 남아 있는지 보고, Pod를 배치합니다.<br /> 예: 컨테이너 A가 cpu: 200m, memory: 100Mi, 컨테이너 B가 cpu: 100m, memory: 50Mi 라면, 스케줄러는 “이 Pod는 최소 300m CPU와 150Mi 메모리를 필요로 한다”고 판단합니다.</ul><p><br /></p><p>만약 Pod으로만 Application을 운영한다면, Pod자체로는 HA(High Availability) 관련 기능을 제공하지 않기때문에, 관리하는데에 많은 노력이 필요합니다.<br /> 때문에 별도의 ‘Workload Management(Deployment, Daemonset 등)’를 통해 Pod을 관리합니다.</p><h2 id="deployment와-replicaset"><span class="me-2">Deployment와 ReplicaSet</span><a href="#deployment와-replicaset" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="deployment"><span class="me-2">Deployment</span><a href="#deployment" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Kubernetes에서, ‘Deployment’는 선언적(Declarative)으로 애플리케이션의 Pod 복제본Set(ReplicaSet)을 관리하고, 롤링 업데이트·롤백 같은 배포 전략을 자동화해 주는 상위 리소스입니다.<br /> <br /><br /> 아래는 ‘Deployment’의 예시입니다.</p><div class="language-yaml highlighter-rouge"><div class="code-header"> <span data-label-text="YAML"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">apps/v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Deployment</span>
<span class="na">metadata</span><span class="pi">:</span>
 <span class="na">name</span><span class="pi">:</span> <span class="s">nginx-deployment</span>
 <span class="na">labels</span><span class="pi">:</span>
   <span class="na">app</span><span class="pi">:</span> <span class="s">nginx</span>
<span class="na">spec</span><span class="pi">:</span>
 <span class="na">replicas</span><span class="pi">:</span> <span class="m">3</span>
 <span class="na">selector</span><span class="pi">:</span>
   <span class="na">matchLabels</span><span class="pi">:</span>
     <span class="na">app</span><span class="pi">:</span> <span class="s">nginx</span>
 <span class="na">template</span><span class="pi">:</span>
   <span class="na">metadata</span><span class="pi">:</span>
     <span class="na">labels</span><span class="pi">:</span>
       <span class="na">app</span><span class="pi">:</span> <span class="s">nginx</span>
   <span class="na">spec</span><span class="pi">:</span>
     <span class="na">containers</span><span class="pi">:</span>
     <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">nginx</span>
       <span class="na">image</span><span class="pi">:</span> <span class="s">nginx:1.14.2</span>
       <span class="na">ports</span><span class="pi">:</span>
       <span class="pi">-</span> <span class="na">containerPort</span><span class="pi">:</span> <span class="m">80</span>
 <span class="na">strategy</span><span class="pi">:</span>
   <span class="na">type</span><span class="pi">:</span> <span class="s">RollingUpdate</span>
   <span class="na">rollingUpdate</span><span class="pi">:</span>
     <span class="na">maxSurge</span><span class="pi">:</span> <span class="m">1</span>
     <span class="na">maxUnavailable</span><span class="pi">:</span> <span class="m">1</span>
</pre></table></code></div></div><h4 id="주요-기능"><span class="me-2">주요 기능</span><a href="#주요-기능" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li><p><strong>ReplicaSet 관리</strong><br /> Deployment는 내부적으로 ReplicaSet을 생성·관리하여, 지정한 수(spec.replicas)만큼 Pod이 항상 가동되어 있도록 보장합니다.</p><li><p><strong>롤링 업데이트(RollingUpdate)</strong><br /> 새로운 버전의 컨테이너 이미지로 점진 교체하면서 가용성(Availability)을 유지합니다.<br /> 기본값은 최대 25% 오버프로비저닝, 최대 25% 미달 허용(maxSurge: 25%, maxUnavailable: 25%).</p><li><p><strong>롤백(Rollback)</strong><br /> 문제가 생기면 이전 버전의 ReplicaSet으로 자동 혹은 수동 복귀가 가능합니다.</p><li><p><strong>버전 관리(Revision)</strong><br /> 각 변경은 Revision 번호를 부여받아, <code class="language-plaintext highlighter-rouge">kubectl rollout history</code>로 추적할 수 있습니다.</p><div class="language-yaml highlighter-rouge"><div class="code-header"> <span data-label-text="YAML"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre>  <span class="c1"># deployment의 history를 확인합니다</span>
  <span class="s">$ kubectl rollout history deployment/nginx-deployment</span>
    
  <span class="s">deployments "nginx-deployment"</span>
  <span class="s">REVISION    CHANGE-CAUSE</span>
  <span class="s">1           kubectl apply --filename=https://k8s.io/examples/controllers/nginx-deployment.yaml</span>
  <span class="s">2           kubectl set image deployment/nginx-deployment nginx=nginx:1.16.1</span>
  <span class="s">3           kubectl set image deployment/nginx-deployment nginx=nginx:1.161</span>
</pre></table></code></div></div></ul><h4 id="배포전략strategy들"><span class="me-2">배포전략(Strategy)들</span><a href="#배포전략strategy들" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p><code class="language-plaintext highlighter-rouge">.spec.strategy</code> 를 통해, Deployment의 배포 전략을 선택할 수 있습니다.</p><ul><li><p>RollingUpdate(기본값)<br /> 점진적으로 새로운 ReplicaSet의 Pod를 늘리고, 구 버전 Pod를 줄이며 교체합니다.<br /> maxSurge·maxUnavailable로 스피드·가용성 균형 조정할 수 있습니다.</p><li><p>Recreate<br /> 먼저 모든 기존 Pod를 삭제한 뒤(Zero-downtime 없이) 새 버전 Pod를 생성하는 방식입니다.<br /> Stateless 애플리케이션에서 단순하게 사용할때만 사용합니다.</p><blockquote class="prompt-info"><p>This will only guarantee Pod termination previous to creation for upgrades. ‘Recreate’은 새로운 버젼이 생성되기 전에, 반드시 그 이전버전이 제거되는것만 보장합니다. 즉, zero downtime을 보장하지 않습니다.</p></blockquote></ul><h4 id="운영관련-팁tip들"><span class="me-2">운영관련 팁(Tip)들</span><a href="#운영관련-팁tip들" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li><strong>컨테이너 이미지 벡터 태그</strong> 대신 <strong>SHA digest</strong>(my-app@sha256:…)를 쓰면, 동일 버전 재배포 시에도 불필요한 롤아웃을 방지할 수 있습니다.<li><strong>Blue–Green</strong> 혹은 <strong>Canary</strong> 배포: Deployment를 여러 개 만들고, Deployment사이에서 서비스(Service) 라우팅을 전환하거나, ‘Argo Rollouts, Flagger’ 같은 툴을 활용하여 구현합니다.</ul><p><br /></p><h3 id="replicaset"><span class="me-2">ReplicaSet</span><a href="#replicaset" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><blockquote><p>A ReplicaSet’s purpose is to maintain a stable set of replica Pods running at any given time. Usually, you define a Deployment and let that Deployment manage ReplicaSets automatically.<br /> - from kubernetes.io</p></blockquote><p>‘ReplicaSet’은 Pod의 복제본이 어느때든(즉, 항상) 지정한 수 만큼 가동되어 있도록 보장하는 역할을 합니다.</p><h4 id="replicaset의-작동-방식"><span class="me-2">ReplicaSet의 작동 방식</span><a href="#replicaset의-작동-방식" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><div class="language-yaml highlighter-rouge"><div class="code-header"> <span data-label-text="YAML"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">apps/v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">ReplicaSet</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">frontend</span>
  <span class="na">labels</span><span class="pi">:</span>
    <span class="na">app</span><span class="pi">:</span> <span class="s">guestbook</span>
    <span class="na">tier</span><span class="pi">:</span> <span class="s">frontend</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="c1"># modify replicas according to your case</span>
  <span class="na">replicas</span><span class="pi">:</span> <span class="m">3</span>
  <span class="na">selector</span><span class="pi">:</span>
    <span class="na">matchLabels</span><span class="pi">:</span>
      <span class="na">tier</span><span class="pi">:</span> <span class="s">frontend</span>
  <span class="na">template</span><span class="pi">:</span>
    <span class="na">metadata</span><span class="pi">:</span>
      <span class="na">labels</span><span class="pi">:</span>
        <span class="na">tier</span><span class="pi">:</span> <span class="s">frontend</span>
    <span class="na">spec</span><span class="pi">:</span>
      <span class="na">containers</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">php-redis</span>
        <span class="na">image</span><span class="pi">:</span> <span class="s">us-docker.pkg.dev/google-samples/containers/gke/gb-frontend:v5</span>

</pre></table></code></div></div><ul><li>여러 필드를 통해, 특정 ReplicaSet으로 관리되고 있는 Pod을 구분합니다.<ul><li><p><code class="language-plaintext highlighter-rouge">spec.selector</code> (Label Selector)<br /> ReplicaSet 컨트롤러가 ‘지금 클러스터에 매칭되는 Pod이 몇 개인지’ 세고, 부족하면 생성, 초과면 삭제하기 위해 사용하는 핵심 필터입니다.<br /> 스케줄러가 ‘이 ReplicaSet의 Pod’를 노드에 스케줄링하거나, Service가 ‘어떤 Pod로 트래픽을 보낼지’ 결정할 때도 이 Selector를 활용합니다.<br /> 처음부터 <code class="language-plaintext highlighter-rouge">.spec.template.metadata.labels</code>(Pod의 Template에 있는 label정보)와 <strong>일치하도록 정의</strong>해야 하며, 라벨 구조를 바꾸면 스케일링 대상이 달라집니다.</p><li><p><code class="language-plaintext highlighter-rouge">metadata.ownerReferences</code> (Owner Reference)<br /> ‘이 Pod는 이 ReplicaSet의 자식’이라는 관계 정보로, ReplicaSet이 삭제될 때 자동으로 Pod를 정리(garbage collect)하도록 Kubernetes에 알려 줍니다.</p></ul><li>ReplicaSet이 유지해야 하는 상태를 정의하고, 이 상태를 유지합니다.<ul><li><p><code class="language-plaintext highlighter-rouge">spec.selector</code><br /> 여러 Pod들 사이에서, ReplicaSet에 포함된 Pod을 식별하는데 사용하는 field입니다. 이를 통해 현재 개수와 Desired 개수를 확인하여, 일치하도록 조정합니다.</p><li><p><code class="language-plaintext highlighter-rouge">spec.replicas</code><br /> 유지되어야할 Pod의 수(a number of replicas)를 표현합니다.</p><li><p><code class="language-plaintext highlighter-rouge">spec.template</code><br /> Pod를 생성할때 사용하는 Template입니다.</p></ul></ul><p><br /></p><h3 id="deployments와-replicaset의-관계"><span class="me-2">Deployments와 ReplicaSet의 관계</span><a href="#deployments와-replicaset의-관계" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><dl><dt>ReplicaSet은<dd>‘원하는 개수의 Pod가 항상 구동되도록 보장’하는 역할에 집중한 리소스인 반면,<dt>Deployment는<dd>ReplicaSet 위에 ‘업데이트 관리’, ‘버전 관리’, ‘롤백’ 같은 추가 기능을 제공하는 상위 추상화입니다.</dl><blockquote class="prompt-info"><p>때문에, ReplicaSet을 직접 쓰는것보다, Deployment를 사용하는것을 추천합니다.</p></blockquote><p><br /></p><h2 id="statefulset"><span class="me-2">StatefulSet</span><a href="#statefulset" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><blockquote><p>A StatefulSet runs a group of Pods, and maintains a sticky identity for each of those Pods. This is useful for managing applications that need persistent storage or a stable, unique network identity.<br /> - from <a href="https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/">kubernetes.io</a></p></blockquote><p>‘StatefulSet’은 쿠버네티스에서 상태(stateful)를 갖는 애플리케이션을 안정적으로 배포·확장·업데이트하기 위해 설계된 Workload 객체입니다. Deployment와 달리 각 Pod에 고정된 네트워크 ID와 영속 스토리지(Persistent Volume)를 보장하며, 생성·삭제·업데이트 시에도 순서(order)와 안정성(stability) 을 제공합니다.</p><h3 id="사용-사례"><span class="me-2">사용 사례</span><a href="#사용-사례" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>데이터베이스 클러스터 <em>**</em>(예: Cassandra, MongoDB, MySQL Replication)<li>분산 캐시 (예: Redis Sentinel, ZooKeeper)<li>메시지 브로커 (예: Kafka, RabbitMQ)<li>상태 저장 애플리케이션 (예: Elasticsearch, Etcd)</ul><blockquote class="prompt-info"><p>반드시 Stateful이 필요한 APP이 아니라면, 되도록 Deployment를 사용하길 추천합니다.<br /> Scalable을 고려해야하는 시스템에서, Stateful 시스템으로 App을 만든다면, Pod이 영속적인 개념이 아니기 때문에, Stateful을 위해 많은 작업이 추가로 필요해집니다.</p></blockquote><p><br /></p><h3 id="statefulset과-headless-service"><span class="me-2">StatefulSet과 Headless Service</span><a href="#statefulset과-headless-service" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><a href="/assets/img/for-post/k8s%20workloads/image%202.png" class="popup img-link shimmer"><img src="/assets/img/for-post/k8s%20workloads/image%202.png" alt="StatefulSet과 Headless Service의 관계. mysql CQRS패턴을 예시로 사용. | [alibabacloud.com](https://www.alibabacloud.com/blog/kubernetes-application-management-stateful-services_595087)" loading="lazy"></a> <em>StatefulSet과 Headless Service의 관계. mysql CQRS패턴을 예시로 사용. | <a href="https://www.alibabacloud.com/blog/kubernetes-application-management-stateful-services_595087">alibabacloud.com</a></em></p><h4 id="statefulset에-service가-아닌-별도의-headless-service가-필요한-이유"><span class="me-2">StatefulSet에 ‘Service’가 아닌, 별도의 ‘Headless Service’가 필요한 이유?</span><a href="#statefulset에-service가-아닌-별도의-headless-service가-필요한-이유" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>StatefulSet이 ‘상태 저장(stateful)’ 애플리케이션을 다루기 위해 제공하는 핵심 기능 중 하나가 <strong>각 Pod에 고정된 네트워크 ID</strong>를 부여하는 것입니다.<br /> 그런데 쿠버네티스의 기본 ‘Service’는 <strong>클러스터 IP</strong>와 <strong>로드밸런싱(LB)</strong>을 전제로 동작하기 때문에, StatefulSet이 원하는 ‘Pod별로 고정된 DNS 이름’을 제공해 주지 않습니다.</p><dl><dt>정리하면,<dd>Kubernetes에서는 보통, Pod가 아닌 ‘Service’를 통해 Pod에 접속합니다. 이 ‘Service’를 이용하면, LB를 통해 Pod에 random하게 접속하게 됩니다.<dd>하지만, DB와 같은 App들은 구분을 위해, Pod에 대한 고정된 DNS주소가 필요할 수 있습니다.<dd>StatefulSet은 이를 위해, 고정된 네크워크 ID(대표적으로 IP)를 제공하고,<dd>이를 Headless Service를 통해, Pod에 접속하기 위한 개별 IP를 조회할 수 있게 합니다.(DNS에 개별 Pod에 접속하기 위한 Domain을 등록하는 방식.)</dl><h4 id="headless-service의-역할"><span class="me-2">Headless Service의 역할</span><a href="#headless-service의-역할" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>Service에 속한 Pod별로 A 레코드를 생성합니다<ul><li><p>일반 Service(clusterIP가 할당됩니다)<br /> 동일한 Service 이름에 대해 하나의 VIP(가상 IP)만 DNS에 등록되는 방식입니다. 이후, LB와 kube-proxy를 통해 Pod로 연결됩니다.</p><li><p>Headless Service(clusterIP가 부여되지 않습니다.)<br /> selector에 걸리는 각 Pod의 IP를 개별 A 레코드로 DNS에 등록하여, Service Discovery가 되도록 합니다.</p></ul><li><p>Stable Network Identity 보장<br /> statefulSet이 생성하는 Pod 이름(mysql-0, mysql-1…)과 Headless Service 이름(headless-mysql-svc)을 조합해<br /> <code class="language-plaintext highlighter-rouge">mysql-0.headless-mysql-svc</code>, <code class="language-plaintext highlighter-rouge">mysql-1.headless-svc</code> 와 같은 영구적인 DNS 이름을 제공합니다.<br /> <strong>Pod IP가 변경되더라도 DNS 이름은 그대로 유지</strong>되어, 애플리케이션은 항상 같은 호스트명으로 자신(또는 다른 노드)을 참조할 수 있습니다.</p><li><p>Service Discover(서비스 디스커버리) 지원<br /> ZooKeeper, Cassandra 같은 분산 시스템은 클러스터 토폴로지를 구성할 때 피어(peer) 노드의 정확한 주소가 필요합니다.<br /> Headless Service를 통해 “내 토폴로지 멤버 리스트”를 DNS 기반으로 조회할 수 있게 해 줍니다.</p><li>로드밸런싱이 아니라 직접 연결<br /> Headless Service는 프록시나 로드밸런싱 기능을 제공하지 않습니다. DNS 조회 결과로 얻은 Pod IP 리스트를 클라이언트가 직접 사용하게 됩니다.<br /> 이 방식이 StatefulSet이 요구하는 ‘개별 Pod에 대한 직접 연결’하는 시나리오에 딱 맞습니다.</ul><p><br /></p><h2 id="daemonset"><span class="me-2">DaemonSet</span><a href="#daemonset" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><blockquote><p>A DaemonSet defines Pods that provide node-local facilities. These might be fundamental to the operation of your cluster, such as a networking helper tool, or be part of an add-on. - from <a href="https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/">kubernetes.io</a></p></blockquote><p>DaemonSet은 클러스터의 모든(또는 지정한) <strong>노드에 ‘하나씩’</strong> Pod를 배포·유지하도록 보장하는 컨트롤러입니다. 주로 노드별 에이전트(로그 수집기, 모니터링 에이전트, 네트워크 플러그인 등)를 배포할 때 사용합니다.<br /> 노드가 추가되면, 해당 노드에 대한 Pod이 추가로 생성됩니다.</p><h3 id="사용-사례-1"><span class="me-2">사용 사례</span><a href="#사용-사례-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>로그 수집 &amp; 모니터링 에이전트: Fluentd, Filebeat, Telegraf, Datadog Agent<li>네트워크 플러그인: Calico, Cilium, Weave Net<li>스토리지 드라이버: CSI 플러그인 데몬<li>보안 에이전트: Falco, Istio 데몬 서비스</ul><h3 id="daemonset-spec-예시"><span class="me-2">DaemonSet Spec 예시</span><a href="#daemonset-spec-예시" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-yaml highlighter-rouge"><div class="code-header"> <span data-label-text="YAML"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
</pre><td class="rouge-code"><pre><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">apps/v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">DaemonSet</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">fluentd-elasticsearch</span>
  <span class="na">namespace</span><span class="pi">:</span> <span class="s">kube-system</span>
  <span class="na">labels</span><span class="pi">:</span>
    <span class="na">k8s-app</span><span class="pi">:</span> <span class="s">fluentd-logging</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">selector</span><span class="pi">:</span>
    <span class="na">matchLabels</span><span class="pi">:</span>
      <span class="na">name</span><span class="pi">:</span> <span class="s">fluentd-elasticsearch</span>
  <span class="na">template</span><span class="pi">:</span>
    <span class="na">metadata</span><span class="pi">:</span>
      <span class="na">labels</span><span class="pi">:</span>
        <span class="na">name</span><span class="pi">:</span> <span class="s">fluentd-elasticsearch</span>
    <span class="na">spec</span><span class="pi">:</span>
      <span class="na">tolerations</span><span class="pi">:</span>
      <span class="c1"># these tolerations are to have the daemonset runnable on control plane nodes</span>
      <span class="c1"># remove them if your control plane nodes should not run pods</span>
      <span class="pi">-</span> <span class="na">key</span><span class="pi">:</span> <span class="s">node-role.kubernetes.io/control-plane</span>
        <span class="na">operator</span><span class="pi">:</span> <span class="s">Exists</span>
        <span class="na">effect</span><span class="pi">:</span> <span class="s">NoSchedule</span>
      <span class="pi">-</span> <span class="na">key</span><span class="pi">:</span> <span class="s">node-role.kubernetes.io/master</span>
        <span class="na">operator</span><span class="pi">:</span> <span class="s">Exists</span>
        <span class="na">effect</span><span class="pi">:</span> <span class="s">NoSchedule</span>
      <span class="na">containers</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">fluentd-elasticsearch</span>
        <span class="na">image</span><span class="pi">:</span> <span class="s">quay.io/fluentd_elasticsearch/fluentd:v2.5.2</span>
        <span class="na">resources</span><span class="pi">:</span>
          <span class="na">limits</span><span class="pi">:</span>
            <span class="na">memory</span><span class="pi">:</span> <span class="s">200Mi</span>
          <span class="na">requests</span><span class="pi">:</span>
            <span class="na">cpu</span><span class="pi">:</span> <span class="s">100m</span>
            <span class="na">memory</span><span class="pi">:</span> <span class="s">200Mi</span>
        <span class="na">volumeMounts</span><span class="pi">:</span>
        <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">varlog</span>
          <span class="na">mountPath</span><span class="pi">:</span> <span class="s">/var/log</span>
      <span class="c1"># it may be desirable to set a high priority class to ensure that a DaemonSet Pod</span>
      <span class="c1"># preempts running Pods</span>
      <span class="c1"># priorityClassName: important</span>
      <span class="na">terminationGracePeriodSeconds</span><span class="pi">:</span> <span class="m">30</span>
      <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">varlog</span>
        <span class="na">hostPath</span><span class="pi">:</span>
          <span class="na">path</span><span class="pi">:</span> <span class="s">/var/log</span>
</pre></table></code></div></div><p><br /></p><h2 id="jobs"><span class="me-2">Jobs</span><a href="#jobs" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><blockquote><p>Jobs represent one-off tasks that run to completion and then stop. - from <a href="https://kubernetes.io/docs/concepts/workloads/controllers/job/">kubernetes.io</a></p></blockquote><p>‘Jobs’는 1회성 작업(실행을 완료하고 멈추는)을 안전하게 실행하기 위해 사용합니다.<br /> ‘Job’은 작업의 완료를 위해, Pod를 1개이상 생성할 수 있습니다. 이때, <strong>‘작업의 완료’기준은, 성공적으로 종료된(successfully terminate) Pod의 갯수</strong>입니다.<br /> 이를 정리하면, ‘Jobs’는 <strong>지정한 개수의 완료된 Pod을 보장해주는 컨트롤러</strong> 입니다.<br /> 반복적이거나 장기 실행 서비스인 ‘Deployment’와 달리, 특정 작업이 한 번만 또는 정해진 횟수만큼 실행되어야 할 때 사용합니다.</p><h3 id="jobs-spec-예시"><span class="me-2">Jobs Spec 예시</span><a href="#jobs-spec-예시" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-yaml highlighter-rouge"><div class="code-header"> <span data-label-text="YAML"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">batch/v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Job</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">example-job</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">completions</span><span class="pi">:</span> <span class="m">3</span>           <span class="c1"># 총 3개 Pod가 성공 종료되어야 Job이 완료됩니다.</span>
  <span class="na">parallelism</span><span class="pi">:</span> <span class="m">2</span>           <span class="c1"># 동시에 최대 2개의 Pod을 실행합니다.</span>
  <span class="na">backoffLimit</span><span class="pi">:</span> <span class="m">4</span>          <span class="c1"># 실패 시, 최대 4회 재시도합니다.</span>
  <span class="na">template</span><span class="pi">:</span>
    <span class="na">spec</span><span class="pi">:</span>
      <span class="na">restartPolicy</span><span class="pi">:</span> <span class="s">OnFailure</span>
      <span class="na">containers</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">task</span>
        <span class="na">image</span><span class="pi">:</span> <span class="s">busybox</span>
        <span class="na">args</span><span class="pi">:</span> <span class="pi">[</span><span class="s2">"</span><span class="s">sh"</span><span class="pi">,</span> <span class="s2">"</span><span class="s">-c"</span><span class="pi">,</span> <span class="s2">"</span><span class="s">echo</span><span class="nv"> </span><span class="s">Hello;</span><span class="nv"> </span><span class="s">exit</span><span class="nv"> </span><span class="s">0"</span><span class="pi">]</span>
</pre></table></code></div></div><h3 id="응용하기"><span class="me-2">응용하기</span><a href="#응용하기" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><p><a href="https://kubernetes.io/blog/2021/04/19/introducing-indexed-jobs/">Indexed Jobs</a> (.spec.completionMode: “Indexed”)<br /> 각 Pod에 JOB_COMPLETION_INDEX 환경 변수를 주어, 인덱스별 작업(partition으로 )을 분리하여 처리할 수 있습니다.</p><li><p><a href="https://kubernetes.io/docs/tasks/job/coarse-parallel-processing-work-queue/">Work Queue 패턴</a><br /> 메시지 큐(RabbitMQ, Kafka)와 연동해, parallelism 을 높여 대량 데이터를 분산 처리합니다.</p><li><p><a href="https://kubernetes.io/docs/concepts/workloads/controllers/ttlafterfinished/">TTL(Time-to-Live) Controller</a><br /> Job 완료 후 일정 시간(.spec.ttlSecondsAfterFinished)이 지나면 자동 삭제되게 할 수 있습니다.</p></ul><h3 id="사용-사례-2"><span class="me-2">사용 사례</span><a href="#사용-사례-2" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>데이터 마이그레이션: 데이터를 일괄로 로드하거나 변환할때 사용합니다.<li>백업/정리 스크립트: 주기적인 백업작업이나 로그 아카이빙 작업에 사용합니다.<li>머신러닝 학습: 단일 배치(1회 실행) 훈련 작업용으로 사용합니다.<li>크론작업 대체: CronJob과 조합해 주기적 Batch 실행할 때 사용합니다.</ul><h2 id="references"><span class="me-2">References</span><a href="#references" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><dl><dt>Pods | kubernetes.io<dd><a href="https://kubernetes.io/docs/concepts/workloads/pods/">Pods</a><dt>Workload Management | kubernetes.io<dd><a href="https://kubernetes.io/docs/concepts/workloads/controllers/">Workload Management</a><dt>Deployments | kubernetes.io<dd><a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/">Deployments</a><dt>ReplicaSet | kubernetes.io<dd><a href="https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/">ReplicaSet</a><dt>StatefulSet | kubernetes.io<dd><a href="https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/">StatefulSets</a><dt>Headless Service | kubernetes.io<dd><a href="https://kubernetes.io/docs/concepts/services-networking/service/#headless-services">Service</a><dt>DaemonSet | kubernetes.io<dd><a href="https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/">DaemonSet</a><dt>Linux namespaces | en.wikipedia.org<dd><a href="https://en.wikipedia.org/wiki/Linux_namespaces">Linux namespaces</a><dt>The 7 most used Linux namespaces | redhat.com<dd><a href="https://www.redhat.com/en/blog/7-linux-namespaces">The 7 most used Linux namespaces</a><dt>Linux cgroups(Control Groups) | docs.redhat.com<dd><a href="https://docs.redhat.com/en/documentation/red_hat_enterprise_linux/6/html/resource_management_guide/ch01">Chapter1.Introduction to Control Groups (Cgroups) | Resource Management Guide | Red Hat Enterprise Linux | 6 | Red Hat Documentation</a><dt>A Linux sysadmin’s introduction to cgroups | redhat.com<dd><a href="https://www.redhat.com/en/blog/cgroups-part-one">A Linux sysadmin’s introduction to cgroups</a><dt>4 Linux technologies fundamental to containers | opensource.com<dd><a href="https://opensource.com/article/21/8/container-linux-technology">4 Linux technologies fundamental to containers</a><dt>Evolution of Docker from Linux Containers | baeldung.com<dd><a href="https://www.baeldung.com/linux/docker-containers-evolution">Evolution of Docker from Linux Containers | Baeldung on Linux</a><dt>Building a Linux container by hand using namespaces | redhat.com<dd><a href="https://www.redhat.com/en/blog/building-container-namespaces">Building a Linux container by hand using namespaces</a><dt>Indexed Jobs | kubernetes.io<dd><a href="https://kubernetes.io/blog/2021/04/19/introducing-indexed-jobs/">Introducing Indexed Jobs</a><dt>Work Queue pattern with Jobs | kubernetes.io<dd><a href="https://kubernetes.io/docs/tasks/job/coarse-parallel-processing-work-queue/">Coarse Parallel Processing Using a Work Queue</a><dd><a href="https://kubernetes.io/docs/tasks/job/fine-parallel-processing-work-queue/">Fine Parallel Processing Using a Work Queue</a></dl></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw me-1"></i> <a href="/categories/devops/">DevOps</a>, <a href="/categories/kubernetes/">kubernetes</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw me-1"></i> <a href="/tags/aws/" class="post-tag no-text-decoration" >aws</a> <a href="/tags/kubernetes/" class="post-tag no-text-decoration" >kubernetes</a> <a href="/tags/cncf/" class="post-tag no-text-decoration" >cncf</a> <a href="/tags/k8s/" class="post-tag no-text-decoration" >k8s</a></div><div class=" post-tail-bottom d-flex justify-content-between align-items-center mt-5 pb-2 " ><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper d-flex align-items-center"> <span class="share-label text-muted">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Workloads%20%7C%20Kubernetes%20Deep%20Dive%20-%204%20-%20KanghoonYi(Pour)&url=https%3A%2F%2Fblog.devpour.net%2Fposts%2Fk8s-workloads%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Twitter" aria-label="Twitter"> <i class="fa-fw fa-brands fa-square-x-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Workloads%20%7C%20Kubernetes%20Deep%20Dive%20-%204%20-%20KanghoonYi(Pour)&u=https%3A%2F%2Fblog.devpour.net%2Fposts%2Fk8s-workloads%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Facebook" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https%3A%2F%2Fblog.devpour.net%2Fposts%2Fk8s-workloads%2F&text=Workloads%20%7C%20Kubernetes%20Deep%20Dive%20-%204%20-%20KanghoonYi(Pour)" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Telegram" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <button id="copy-link" aria-label="Copy link" class="btn small" data-bs-toggle="tooltip" data-bs-placement="top" title="Copy link" data-title-succeed="Link copied successfully!" > <i class="fa-fw fas fa-link pe-none fs-6"></i> </button> </span></div></div></div></article></main><aside aria-label="Panel" id="panel-wrapper" class="col-xl-3 ps-2 mb-5 text-muted"><div class="access"><section id="access-lastmod"><h2 class="panel-heading">Recently Updated</h2><ul class="content list-unstyled ps-0 pb-1 ms-1 mt-2"><li class="text-truncate lh-lg"> <a href="/posts/k8s-gpu-1/">kubernetes 환경에서 GPU 서빙 | GPU인식</a><li class="text-truncate lh-lg"> <a href="/posts/Redis/">Redis | Key Technologies - System Design Interview</a><li class="text-truncate lh-lg"> <a href="/posts/Consistent-Hashing/">Consistent Hashing | Core Concepts - System Design Interview</a><li class="text-truncate lh-lg"> <a href="/posts/k8s-introduction/">Kubernetes(Orchestration) 개론</a><li class="text-truncate lh-lg"> <a href="/posts/CAP-Theorem/">CAP Theorem(정리) | Core Concepts - System Design Interview</a></ul></section><section><h2 class="panel-heading">Trending Tags</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/programming/">programming</a> <a class="post-tag btn btn-outline-primary" href="/tags/aws/">aws</a> <a class="post-tag btn btn-outline-primary" href="/tags/leetcode/">leetcode</a> <a class="post-tag btn btn-outline-primary" href="/tags/rust/">rust</a> <a class="post-tag btn btn-outline-primary" href="/tags/computer-science/">Computer Science</a> <a class="post-tag btn btn-outline-primary" href="/tags/cncf/">cncf</a> <a class="post-tag btn btn-outline-primary" href="/tags/k8s/">k8s</a> <a class="post-tag btn btn-outline-primary" href="/tags/kubernetes/">kubernetes</a> <a class="post-tag btn btn-outline-primary" href="/tags/algorithm/">algorithm</a> <a class="post-tag btn btn-outline-primary" href="/tags/architecture/">Architecture</a></div></section></div><section id="toc-wrapper" class="d-none ps-0 pe-4"><h2 class="panel-heading ps-3 mb-2">Contents</h2><nav id="toc"></nav></section></aside></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 px-md-4"><aside id="related-posts" aria-labelledby="related-label"><h3 class="mb-4" id="related-label">Further Reading</h3><nav class="row row-cols-1 row-cols-md-2 row-cols-xl-3 g-4 mb-4"><article class="col"> <a href="/posts/k8s-introduction/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1750777740" data-df="ll" > Jun 25, 2025 </time><h4 class="pt-0 my-2">Kubernetes(Orchestration) 개론</h4><div class="text-muted"><p>오늘날, IT서비스를 구성할때, Kubernetes와 같은 Orchestration 환경을 기본으로 시작하게 됩니다. 여기서는, 이런 배경을 알아보고자 합니다. Kubernetes의 성장 배경 Kubernetes가 오늘날 처럼 인프라 운영의 핵심으로 자리 잡기 까지, 여러 배경이 있습니다. 더 빨라진 비지니스 변화 → 잦은 배포가 발생합니다....</p></div></div></a></article><article class="col"> <a href="/posts/k8s-data-plane/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1751632500" data-df="ll" > Jul 4, 2025 </time><h4 class="pt-0 my-2">Components - Data Plane(Node) | Kubernetes Deep Dive - 3</h4><div class="text-muted"><p>이번에는 Kubernetes에서 사용자의 Application이 돌아가는 ‘Data Plane(Node)’에서, Kubernetes 시스템을 위해 돌아가는 컴포넌트(Components)들을 알아보고자 합니다. Node와 Node의 컴포넌트들 Node에 대해서 컴포넌트들에 대해 이해하기에 앞서, Kubernetes에서 Node의 의미를 짚고 가고...</p></div></div></a></article><article class="col"> <a href="/posts/k8s-control-plane/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1751282040" data-df="ll" > Jun 30, 2025 </time><h4 class="pt-0 my-2">Components - Control Plane | Kubernetes Deep Dive - 2</h4><div class="text-muted"><p>Kubernetes에서 ‘Control Plane’은 Cluster를 운영하는 Core혹은 ‘뇌’의 역할을 합니다. Cluster를 다루기 위한 API요청을 검증하고, 상태를 저장하고, 요청을 실행시키고, Cluster를 유지하는 역할을 합니다. 여기서는 ‘Control Plane’이 어떤 Component를 통해 이런 역할을 수행하는지 알아봅니다. ...</p></div></div></a></article></nav></aside><nav class="post-navigation d-flex justify-content-between" aria-label="Post Navigation"> <a href="/posts/Understanding-https-certificates/" class="btn btn-outline-primary" aria-label="Older" ><p>HTTPS 이해하기</p></a> <a href="/posts/networking-essentials/" class="btn btn-outline-primary" aria-label="Newer" ><p>Networking Essentials | Core Concepts - System Design Interview</p></a></nav><script src="https://utteranc.es/client.js" repo="KanghoonYi/kanghoonyi.github.io" issue-term="pathname" crossorigin="anonymous" async ></script> <script type="text/javascript"> (function () { const origin = 'https://utteranc.es'; const lightTheme = 'github-light'; const darkTheme = 'github-dark'; let initTheme = lightTheme; const html = document.documentElement; if ( (html.hasAttribute('data-mode') && html.getAttribute('data-mode') === 'dark') || (!html.hasAttribute('data-mode') && window.matchMedia('(prefers-color-scheme: dark)').matches) ) { initTheme = darkTheme; } addEventListener('message', (event) => { let theme;if (event.origin === origin) {theme = initTheme; } else if (event.source === window && event.data && event.data.direction === ModeToggle.ID) {const mode = event.data.message; theme = mode === ModeToggle.DARK_MODE ? darkTheme : lightTheme; } else { return; } const message = { type: 'set-theme', theme: theme }; const utterances = document.getElementsByClassName('utterances-frame')[0].contentWindow; utterances.postMessage(message, origin); }); })(); </script><footer aria-label="Site Info" class=" d-flex flex-column justify-content-center text-muted flex-lg-row justify-content-lg-between align-items-lg-center pb-lg-3 " ><p>© <time>2026</time> <a href="https://github.com/KanghoonYi">KanghoonYi</a>. <span data-bs-toggle="tooltip" data-bs-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author." >Some rights reserved.</span></p><p>Using the <a data-bs-toggle="tooltip" data-bs-placement="top" title="v7.1.1" href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener" >Chirpy</a> theme for <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a>.</p></footer></div></div><div id="search-result-wrapper" class="d-flex justify-content-center d-none"><div class="col-11 content"><div id="search-hints"><section><h2 class="panel-heading">Trending Tags</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/programming/">programming</a> <a class="post-tag btn btn-outline-primary" href="/tags/aws/">aws</a> <a class="post-tag btn btn-outline-primary" href="/tags/leetcode/">leetcode</a> <a class="post-tag btn btn-outline-primary" href="/tags/rust/">rust</a> <a class="post-tag btn btn-outline-primary" href="/tags/computer-science/">Computer Science</a> <a class="post-tag btn btn-outline-primary" href="/tags/cncf/">cncf</a> <a class="post-tag btn btn-outline-primary" href="/tags/k8s/">k8s</a> <a class="post-tag btn btn-outline-primary" href="/tags/kubernetes/">kubernetes</a> <a class="post-tag btn btn-outline-primary" href="/tags/algorithm/">algorithm</a> <a class="post-tag btn btn-outline-primary" href="/tags/architecture/">Architecture</a></div></section></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><aside aria-label="Scroll to Top"> <button id="back-to-top" type="button" class="btn btn-lg btn-box-shadow"> <i class="fas fa-angle-up"></i> </button></aside></div><div id="mask"></div><script src="https://cdn.jsdelivr.net/combine/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js,npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.umd.min.js,npm/glightbox@3.3.0/dist/js/glightbox.min.js,npm/clipboard@2.0.11/dist/clipboard.min.js,npm/dayjs@1.11.13/dayjs.min.js,npm/dayjs@1.11.13/locale/en.js,npm/dayjs@1.11.13/plugin/relativeTime.js,npm/dayjs@1.11.13/plugin/localizedFormat.js,npm/tocbot@4.29.0/dist/tocbot.min.js"></script> <script src="/assets/js/dist/post.min.js"></script> <script>SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<article class="px-1 px-sm-2 px-lg-4 px-xl-0"><header><h2><a href="{url}">{title}</a></h2><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div></header><p>{snippet}</p></article>', noResultsText: '<p class="mt-5">Oops! No results found.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="me-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
