<!doctype html><html lang="ko" data-mode="light"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" ><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="CAP Theorem(정리) Core Concepts - System Design Interview" /><meta name="author" content="KanghoonYi(pour)" /><meta property="og:locale" content="ko" /><meta name="description" content="CAP Theorem 소개" /><meta property="og:description" content="CAP Theorem 소개" /><link rel="canonical" href="https://blog.devpour.net/posts/CAP-Theorem/" /><meta property="og:url" content="https://blog.devpour.net/posts/CAP-Theorem/" /><meta property="og:site_name" content="KanghoonYi(Pour)" /><meta property="og:image" content="https://blog.devpour.net/assets/img/for-post/CAP%20Theorem/cap-cover.jpg" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2025-07-25T00:04:00+09:00" /><meta name="twitter:card" content="summary_large_image" /><meta property="twitter:image" content="https://blog.devpour.net/assets/img/for-post/CAP%20Theorem/cap-cover.jpg" /><meta property="twitter:title" content="CAP Theorem(정리) Core Concepts - System Design Interview" /><meta name="google-site-verification" content="rsx_-5MJzSR_3NNCqHNe9IxnKJxlD8Eid8_wN8e9c1I" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"KanghoonYi(pour)","url":"https://www.linkedin.com/in/pour/"},"dateModified":"2025-07-25T22:26:04+09:00","datePublished":"2025-07-25T00:04:00+09:00","description":"CAP Theorem 소개","headline":"CAP Theorem(정리) Core Concepts - System Design Interview","image":"https://blog.devpour.net/assets/img/for-post/CAP%20Theorem/cap-cover.jpg","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.devpour.net/posts/CAP-Theorem/"},"url":"https://blog.devpour.net/posts/CAP-Theorem/"}</script><title>CAP Theorem(정리) | Core Concepts - System Design Interview | KanghoonYi(Pour)</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="KanghoonYi(Pour)"><meta name="application-name" content="KanghoonYi(Pour)"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="/assets/css/jekyll-theme-chirpy.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.6.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.29.0/dist/tocbot.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/glightbox@3.3.0/dist/css/glightbox.min.css"><body><aside aria-label="Sidebar" id="sidebar" class="d-flex flex-column align-items-end"><header class="profile-wrapper"> <a href="/" id="avatar" class="rounded-circle"><img src="/assets/img/pour_profile_img.png" width="112" height="112" alt="avatar" onerror="this.style.display='none'"></a><h1 class="site-title"> <a href="/">KanghoonYi(Pour)</a></h1><p class="site-subtitle fst-italic mb-0">안녕하세요~ Software Engineer pour입니다 This is Pour.</p></header><nav class="flex-column flex-grow-1 w-100 ps-0"><ul class="nav"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle"></i> <span>ABOUT</span> </a></ul></nav><div class="sidebar-bottom d-flex flex-wrap align-items-center w-100"> <a href="https://github.com/KanghoonYi" aria-label="github" target="_blank" rel="noopener noreferrer" > <i class="fab fa-github"></i> </a> <a href="https://twitter.com/" aria-label="twitter" target="_blank" rel="noopener noreferrer" > <i class="fa-brands fa-x-twitter"></i> </a> <a href="javascript:location.href = 'mailto:' + ['rkdgnsdls','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></aside><div id="main-wrapper" class="d-flex justify-content-center"><div class="container d-flex flex-column px-xxl-5"><header id="topbar-wrapper" aria-label="Top Bar"><div id="topbar" class="d-flex align-items-center justify-content-between px-lg-3 h-100" ><nav id="breadcrumb" aria-label="Breadcrumb"> <span> <a href="/">Home</a> </span> <span>CAP Theorem(정리) | Core Concepts - System Design Interview</span></nav><button type="button" id="sidebar-trigger" class="btn btn-link"> <i class="fas fa-bars fa-fw"></i> </button><div id="topbar-title"> Post</div><button type="button" id="search-trigger" class="btn btn-link"> <i class="fas fa-search fa-fw"></i> </button> <search id="search" class="align-items-center ms-3 ms-lg-0"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..." > </search> <button type="button" class="btn btn-link text-decoration-none" id="search-cancel">Cancel</button></div></header><div class="row flex-grow-1"><main aria-label="Main Content" class="col-12 col-lg-11 col-xl-9 px-md-4"><article class="px-1"><header><h1 data-toc-skip>CAP Theorem(정리) | Core Concepts - System Design Interview</h1><div class="post-meta text-muted"> <span> Posted <time data-ts="1753369440" data-df="ll" data-bs-toggle="tooltip" data-bs-placement="bottom" > Jul 25, 2025 </time> </span> <span> Updated <time data-ts="1753449964" data-df="ll" data-bs-toggle="tooltip" data-bs-placement="bottom" > Jul 25, 2025 </time> </span><div class="mt-3 mb-3"> <a href="/assets/img/for-post/CAP%20Theorem/cap-cover.jpg" class="popup img-link preview-img shimmer"><img src="/assets/img/for-post/CAP%20Theorem/cap-cover.jpg" alt="Preview Image" width="1200" height="630" loading="lazy"></a></div><div class="d-flex justify-content-between"> <span> By <em> <a href="https://www.linkedin.com/in/pour/">KanghoonYi(pour)</a> </em> </span><div> <span class="readtime" data-bs-toggle="tooltip" data-bs-placement="bottom" title="3570 words" > <em>19 min</em> read</span></div></div></div></header><div class="content"><h2 id="cap-theorem-소개"><span class="me-2">CAP Theorem 소개</span><a href="#cap-theorem-소개" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>CAP는 각각 Consistency, Availability, Partition Tolerance를 의미합니다.</p><dl><dt>이 ‘CAP Theorem’은<dd>‘Distributed System(분산처리 시스템)’의 <strong>3가지 핵심 속성에서, 이중 딱 2개만 취할 수 있다</strong>는 theorem(정리, 일정한 조건하에 참이라는 것이 증명됨)입니다.<dd>즉, <strong>3가지 속성사이의 Trade-off 관계</strong>를 설명하는 이론입니다.</dl><p><a href="/assets/img/for-post/CAP%20Theorem/960px-CAP_Theorem_Venn_Diagram.png" class="popup img-link w-50 shimmer"><img src="/assets/img/for-post/CAP%20Theorem/960px-CAP_Theorem_Venn_Diagram.png" alt="CAP theorem Euler diagram" loading="lazy"></a> <em>CAP theorem Euler diagram | <a href="https://en.wikipedia.org/wiki/CAP_theorem">en.wikipedia.org</a></em></p><p>각각의 속성은 다음과 같습니다.</p><ul><li><strong>Consistency(일관성)</strong><br /> 모든 노드가 ‘같은 시점에 동일한 데이터를 갖고 있다는것’을 보장하는것을 말합니다.<br /> 분산환경에서, 클라이언트가 어떤 노드에 요청하든 항상 동일한 응답을 받을 수 있습니다.<blockquote class="prompt-info"><p>여기서의 Consistency는 DB의 ACID에 있는 Consistency와는 다른 맥락을 갖고 있습니다.<br /> ACID의 Consistency의 경우, 트랜잭션 전후, 데이터에 대한 ‘무결성 제약조건’을 말합니다.<br /> CAP의 Consistency<strong>:</strong> “우리 가게 모든 지점에서 같은 가격표를 붙이자”<br /> ACID의 Consistency<strong>:</strong> “가격표는 항상 숫자이고, 재고보다 많은 수량은 팔 수 없다”</p></blockquote><li><p><strong>Availability(가용성</strong>)<br /> 모든 요청에 대해 ‘항상 응답이 오며, 실패하지 않는것’을 말합니다.<br /> 응답이 늦어지거나 오류 없이 처리되는걸 의미합니다.</p><li><strong>Partition Tolerance(분할 허용)</strong><br /> 네트워크가 분할되어 일부 노드 간 통신이 불가능해져도, 시스템은 계속 동작해야 하는것을 말합니다.</ul><p><br /></p><h3 id="cap조합과-적용-예시"><span class="me-2">CAP조합과 적용 예시</span><a href="#cap조합과-적용-예시" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="table-wrapper"><table><thead><tr><th><strong>조합</strong><th><strong>설명</strong><th><strong>대표 시스템 예시</strong><tbody><tr><td><strong>CP (일관성 + 분할 허용)</strong><td>네트워크 분할 시, 일부 요청은 차단되더라도 일관성을 유지합니다.<td>HBase, MongoDB (옵션에 따라), Redis Sentinel<tr><td><strong>AP (가용성 + 분할 허용)</strong><td>네트워크 분할 시에도 응답을 주지만, 일관성은 잠시 깨질 수 있습니다.<td>Cassandra, Couchbase, DynamoDB<tr><td><strong>CA (일관성 + 가용성)</strong><td>네트워크가 항상 정상적이라는 가정에서 가능합니다. (현실적으로는 어려움)<td>단일 노드 시스템 (e.g. RDBMS에서 분산 미적용 시)</table></div><h3 id="현대-분산환경에서-partition-tolerance는-필수"><span class="me-2">현대 분산환경에서, Partition Tolerance는 필수.</span><a href="#현대-분산환경에서-partition-tolerance는-필수" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>현대 분산 시스템은 네트워크 지연, 패킷 손실, 장애 등으로 인해 <strong>Partition(분할)이 언제든 발생할 수 있으므로</strong>, P를 포기할 수 없습니다.<br /> 따라서, <strong>CAP 이론의 실질적인 선택은 C와 A 중 어떤 것을 포기할 것인가</strong>에 대한 문제입니다.<br /> Network Partition(네트워크 분할)이 발생했을때, ‘Consistency와 Availability중 어떤걸 선택하는냐’의 문제라고 정리할 수 있습니다.</p><p><br /></p><h2 id="cap-theorem-시나리오-예시"><span class="me-2">CAP Theorem 시나리오 예시</span><a href="#cap-theorem-시나리오-예시" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="시나리오상의-idle-시스템-상황"><span class="me-2">시나리오상의 Idle 시스템 상황</span><a href="#시나리오상의-idle-시스템-상황" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>우리가, USA와 유럽 Region에 각각 서버를 운영하고 있다고 가정합니다.<br /> 만약 유저가 자신의 프로필 정보(Public으로 노출되는)를 변경한다면, 다음과 같은 Flow가 만들어질 수 있습니다.</p><ol><li>UserA는 USA에 서버에 있는 프로필 정보를 update합니다.<li>USA에서 변경된 Profile이 유럽으로 복제(전파)됩니다.<li>UserB가 유럽서버에 대해, UserA의 정보를 조회합니다.</ol><p><a href="/assets/img/for-post/CAP%20Theorem/cap-scenario-1.png" class="popup img-link shimmer"><img src="/assets/img/for-post/CAP%20Theorem/cap-scenario-1.png" alt="시나리오상 Idle상황" loading="lazy"></a> <em>시나리오상 Idle상황</em></p><p><br /></p><h3 id="문제-발생"><span class="me-2">문제 발생</span><a href="#문제-발생" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><a href="/assets/img/for-post/CAP%20Theorem/cap-scenario-2.png" class="popup img-link shimmer"><img src="/assets/img/for-post/CAP%20Theorem/cap-scenario-2.png" alt="Region간 Network가 끊긴 상황" loading="lazy"></a> <em>Region간 Network가 끊긴 상황</em></p><p>이런 Flow에서, USA와 유럽서버간 Network연결이 끊긴다면, 우리는 2가지 옵션중 선택해야 합니다.</p><ul><li><p>Option A (Consistency 우선 옵션)<br /> Error을 Return합니다. 우리는 최신정보가 반환되지 못하면 에러로 판단합니다.(Consistency를 선택하는 경우)</p><li><p>Option B (Availability 우선 옵션)<br /> 최신데이터가 아니어도, 데이터를 반환합니다.(Availability를 선택하는 경우)</p></ul><h3 id="시나리오-결과-정리"><span class="me-2">시나리오 결과 정리</span><a href="#시나리오-결과-정리" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>이렇게, C(Consistency)와 A(Availability)중에 반드시 하나를 선택해야 하는 상황이 만들어집니다.<br /> ‘시스템의 방향’과, ‘제공하고자 하는 서비스의 형태’에 따라 적합한 전략을 취해야 합니다.</p><p><br /></p><h2 id="cap-theorem과-시스템-디자인-인터뷰"><span class="me-2">CAP Theorem과 시스템 디자인 인터뷰</span><a href="#cap-theorem과-시스템-디자인-인터뷰" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>‘CAP Theorem’를 다루는건, 시스템 디자인 인터뷰에서 첫번째로 해야하는것 중 하나입니다. <br /> 시스템 디자인 인터뷰는, 두가지 핵심적인 요구사항을 정리하면서 시작합니다.</p><ol><li>functional requirements(Feature)를 정리합니다.(반드시 달성해야 하는것들)<li>non-functional requirements를 정의합니다.(system의 quality와 관련된것들)</ol><p>이때, ‘non-functional requirements’를 고려할때, CAP theorem이 ‘시작점’ 역할을 할 수 있습니다.</p><blockquote class="prompt-info"><p>이때, 스스로에게 다음의 질문을 하면 좋습니다.<br /> “이 시스템에서, Consistency와 Availability중에 어떤걸 우선시 해야 할까?”</p></blockquote><h3 id="consistency를-우선시-한다면"><span class="me-2">Consistency를 우선시 한다면..</span><a href="#consistency를-우선시-한다면" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>다음을 포함시켜, 시스템을 디자인하는게 좋습니다.</p><ul><li>Distributed Transactions(분산 트랜잭션)<br /> 여러개의 Data Source간에 강하게 Sync되도록 하려면, ‘<a href="https://en.wikipedia.org/wiki/Two-phase_commit_protocol">two-phase commit protocol</a>‘을 사용해야 합니다.<blockquote class="prompt-info"><p><strong>Two-phase commit protocol(2PC, 2단계 커밋 프로토콜) :</strong><br /> 분산 시스템에서, 여러 노드가 하나의 트랜잭션에 참여할 때, “모두 성공하거나, 모두 실패”해야 합니다. 이를 위해 2PC컨셉을 적용하여, <strong>트랜잭션을 두 단계로 나누어 처리하는것</strong>을 말합니다.</p></blockquote><p>이는 시스템의 복잡도를 높이지만, 모든 Node들에 걸친 Consistency를 보장합니다.<br /> 이 경우, 유저들이 높은 Latency를 경험할 수 있습니다.(여러 Node에 대한 consistency를 위해 시간이 오래걸려서)</p><li><p>Single-Node Solutions<br /> 하나의 DB Instance를 사용하여, 장애가 전파되는 문제를 해결할 수 있습니다.<br /> 이 경우, Scalability(확장성)을 제한하게 되지만, ‘Single source of Truth’가 되어 Consistency를 쉽게 확보할 수 있습니다.</p><li>Technology Choices는 다음과 같이..<ul><li>PostgreSQL, MySQL과 같은 전통적인 RDBMS<li>Goole Spanner<li>Strong consistency mode를 기반으로한 DynamoDB</ul></ul><h3 id="availability를-우선시-한다면"><span class="me-2">Availability를 우선시 한다면…</span><a href="#availability를-우선시-한다면" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>다음을 포함시켜, 시스템을 디자인하는게 좋습니다.</p><ul><li><p>Multiple Replicas<br /> 여러 복제본을 만들어서, Replication환경을 만듭니다.(몇몇 Replica가 최신화 되지 않을 수 있는 환경을 허용)<br /> 이는 Read에 대한 퍼포먼스와 가용성(Availability)에 대한 큰 개선을 제공해줍니다.</p><li><p>Change Data Capture(CDC)<br /> Primary DB의 데이터가 바뀐다면, 이를 비동기적으로 Replica나 Cache혹은 다른 시스템에게 전달합니다.<br /> 이를 통해 업데이트가 시스템에 반영되는 동안 기본 시스템을 계속 사용할 수 있습니다.</p><li><p>Technology Choices는 다음과 같이…</p><ul><li>Cassandra<li>여러 AZ에 걸친 Cluster형 DynamoDB<li>Redis Cluster</ul></ul><blockquote class="prompt-info"><p>현대의 DB들은 ‘Consistency’와 ‘Availability’에 대한 옵션 모두 제공한다고 합니다.<br /> (Configuration을 통해, 둘중 하나를 선택할 수 있다는 뜻)</p></blockquote><p><br /></p><h2 id="consistency-level"><span class="me-2">Consistency Level</span><a href="#consistency-level" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>CAP에서 Consistency는 ‘Strong Consistency’만 의미하는것은 아닙니다.<br /> Consistency에는 여러 Spectrum이 있으며, 이를 이해하는것은 시스템 디자인을 할때에 큰 도움을 줍니다.</p><h3 id="strong-consistency-강한-일관성"><span class="me-2">Strong Consistency (강한 일관성)</span><a href="#strong-consistency-강한-일관성" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>데이터 쓰기(write) 직후에, 모든 읽기(read)에 그 값이 반영되어야 합니다.<br /> 항상 최신값을 읽을 수 있지만, Consistency Model중에 가장 비용(컴퓨팅 리소스 관점)이 비쌉니다.<br /> 주로 ‘은행 계좌의 잔액’에 사용됩니다.</p><p>예시 DB</p><ul><li>Spanner (Google): TrueTime을 기반으로 strong consistency 보장합니다.<li>etcd, ZooKeeper: 리더를 통해 순차적으로 처리합니다.<li>MongoDB (readConcern: “linearizable”): 선택적으로 제공 <br /></ul><h3 id="causal-consistency-인과-일관성"><span class="me-2">Causal Consistency (인과 일관성)</span><a href="#causal-consistency-인과-일관성" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>관련된 Event들이 <strong>모든 유저들에게 동일하게, 동일한 순서로 반영</strong>되는것을 말합니다.<br /> <strong>서로 의존성이 있는 Action들</strong>의 논리적 순서를 보장합니다.<br /> 예를 들면, Post에 Comment를 단다면, Post가 먼저 존재해야합니다. ‘Causal Consistency’는 이 <strong>순서를 보장</strong>해 줍니다.</p><p>예시 DB:</p><ul><li>Cassandra (with client-side tracking)<li>Azure Cosmos DB (선택 가능) <br /></ul><h3 id="sequential-consistency-순차-일관성"><span class="me-2">Sequential Consistency (순차 일관성)</span><a href="#sequential-consistency-순차-일관성" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><blockquote><p>Sequential consistency is a consistency model used in the domain of concurrent computing (e.g. in distributed shared memory, distributed transactions, etc.). - from <a href="https://en.wikipedia.org/wiki/Sequential_consistency">en.wikipedia.org</a></p></blockquote><p><strong>모든 연산이 일관된 순서로 적용</strong>됩니다.</p><blockquote class="prompt-info"><p>위의 ‘Causal Consistency’와 유사해 보이지만,<br /> ‘Causal Consistency’가 Action간의 의존성이 있는경우에만 그 순서를 보장한다면,<br /> ‘Sequential Consistency’은 의존성과 상관없이 모든 Action들의 순서에 대한 일관성을 보장합니다.</p></blockquote><p>대표적으로 ‘concurrent computing’에 쓰입니다.<br /> 각 사용자가 보는 ‘연산 순서’는 동일하지만, 보는 시점에 따라 최신 값이 아닐 수도 있습니다.</p><p>예시 DB:</p><ul><li>일부 메지 큐 시스템, 일부 분산 캐시</ul><h4 id="causal-consistency와-sequential-consistency-비교"><span class="me-2">‘Causal Consistency’와 ‘Sequential Consistency’ 비교</span><a href="#causal-consistency와-sequential-consistency-비교" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><div class="table-wrapper"><table><thead><tr><th><strong>항목</strong><th><strong>Sequential Consistency</strong><th><strong>Causal Consistency</strong><tbody><tr><td><strong>순서 기준</strong><td>모든 연산을 <strong>하나의 글로벌 순서</strong>로 정렬합니다.<td>인과관계(causal relationship)만 보장합니다.<tr><td><strong>전체 순서 필요 여부</strong><td>모든 연산 순서를 동일하게 유지합니다.<td>인과관계가 있는 연산만 순서 보장합니다.<tr><td><strong>병렬 연산 간 순서</strong><td>순서를 <strong>강제로 정합니다.</strong><td><strong>자유롭게 재배열 가능</strong> (인과관계 없으면)<tr><td><strong>성능</strong><td>더 느릴 수 있습니다.<td>더 빠르고 병렬성이 높습니다.</table></div><h3 id="read-your-own-writesryw-consistency"><span class="me-2">Read-your-own-writes(RYW) Consistency</span><a href="#read-your-own-writesryw-consistency" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>‘내가 쓴(write) 데이터’는 내가 읽을 때 항상(‘즉시’ 포함) 보이는 일관성을 말합니다. ‘다른 유저들은 Older version을 read할 수 있음’을 허용합니다.<br /> 주로 소셜미디어에서 사용합니다.</p><p>예시 DB:</p><ul><li>MongoDB (with session): 같은 세션 내에서 RYW 보장합니다.<li>Firebase: 클라이언트 기반 동기화에서 자주 사용합니다. <br /></ul><h3 id="eventual-consistency-최종-일관성"><span class="me-2">Eventual Consistency (최종 일관성)</span><a href="#eventual-consistency-최종-일관성" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><strong>시간이 지나면 언젠가</strong> 모든 노드가 일관된 상태에 도달하는 형태의 일관성입니다. ‘<strong>일시적으로</strong> 일관성이 깨지는것’을 허용합니다.<br /> <strong>가장 허용적인(느슨한) Consistency</strong>입니다.<br /> DNS사용 되며, 대부분의 Distributed Database에서의 Default 설정입니다.</p><p>예시 DB:</p><ul><li>DynamoDB, Cassandra, Riak<li>S3, DNS: 변경 직후에 전파가 늦어질 수 있음</ul><p><a href="/assets/img/for-post/CAP%20Theorem/image.png" class="popup img-link shimmer"><img src="/assets/img/for-post/CAP%20Theorem/image.png" alt="Eventual Consistency Pattern들" loading="lazy"></a> <em>Eventual Consistency Pattern들 | from <a href="https://bytebytego.com/guides/top-eventual-consistency-patterns-you-must-know/">bytebytego.com</a></em></p><h4 id="event-based-eventual-consistency"><span class="me-2">Event-based Eventual Consistency</span><a href="#event-based-eventual-consistency" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>한 서비스(Service A)가 Event를 실행하면, 다른 서비스가 그 이벤트를 받아서 자기 자신의 시스템에 반영합니다. <br /></p><h4 id="background-sync-eventual-consistency"><span class="me-2">Background Sync Eventual Consistency</span><a href="#background-sync-eventual-consistency" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>여기서는 별도의 Background Job(Cron같은)이 Database Node간에 데이터를 일치시켜, Consistency를 만들어 냅니다.<br /> 스케쥴되어서 실행되기 때문에, 훨씬 느린 Consistency를 제공합니다. <br /></p><h4 id="saga-based-eventual-consistency"><span class="me-2">Saga-based Eventual Consistency</span><a href="#saga-based-eventual-consistency" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><dl><dt>‘Saga-based Eventual Consistency’는<dd>분산 트랜잭션을 처리하는 현대적인 방식으로, 특히 마이크로서비스 아키텍처에서 많이 사용됩니다.<dd>2PC의 한계(복잡성, 블로킹)를 극복하고, <strong>일관성보다 가용성과 확장성을 우선할 때 사용</strong>합니다.<dd>트랜잭션을 <strong>여러 개의 작은 지역 트랜잭션(local transaction)으로 쪼개고</strong>, 각 단계가 실패하면 보상 작업(compensation, 흔히 rollback과정이라고 불리는)을 수행하여 이전 상태로 되돌리는 방식입니다.</dl><blockquote class="prompt-info"><p>Saga Pattern은 <strong>느슨한 결합을 추구</strong>합니다.<br /> 이를 통해 서비스 간 의존성을 최소화하고, 서로 독립적으로 개발·배포·운영될 수 있도록 만드는 구조가 만들어집니다.</p></blockquote><blockquote class="prompt-info"><p>‘Event-based Eventual Consistency’유사하지만, ‘Event-based Eventual Consistency’는 단위가 Event인 반면,<br /> ‘Saga-based Eventual Consistency’는 ‘Transaction’단위로 작동합니다.</p></blockquote><div class="table-wrapper"><table><thead><tr><th><strong>항목</strong><th><strong>Saga-based Eventual Consistency</strong><th><strong>Event-based Eventual Consistency</strong><tbody><tr><td>핵심 개념<td>트랜잭션 단위로 보상/실패 흐름을 정의<td>이벤트를 기반으로 비동기적 상태 동기화<tr><td>구조<td>보상 트랜잭션 정의 필수<td>보상 없음 (대부분 리드모델 갱신)<tr><td>사용 목적<td>분산 <strong>비즈니스 트랜잭션 처리</strong><td>시스템 간 <strong>데이터 복제/동기화</strong><tr><td>대표 시나리오<td>결제 실패 시 환불, 롤백 등<td>주문이 생성되면 배송 시스템이 동기화</table></div><h4 id="cqrscommand-query-responsibility-segregation-based-eventual-consistency"><span class="me-2">CQRS(Command Query Responsibility Segregation)-based Eventual Consistency</span><a href="#cqrscommand-query-responsibility-segregation-based-eventual-consistency" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>읽기(Read, Query)와 쓰기(Write, Command) 작업에 대한 책임(Responsibility)을 각각의 DB로 분리하는 ‘Eventual Consistency’방식입니다.<br /> <br /></p><p>보통 아래와 같은 상황에서 사용됩니다.</p><ul><li>읽기와 쓰기 성능 요구가 <strong>비대칭</strong>일 때.<li>조회 요구사항이 <strong>복잡</strong>할 때.<li><strong>확장성과 응답속도</strong>가 중요한 시스템일때.<li>일관성보다 <strong>가용성과 유연성</strong>이 중요한 시스템일때.</ul><p><br /></p><h2 id="references"><span class="me-2">References</span><a href="#references" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><dl><dt>CAP Theorem | hellointerview.com<dd><a href="https://www.hellointerview.com/learn/system-design/deep-dives/cap-theorem">Hello Interview | System Design in a Hurry</a><dt>Spanner, TrueTime &amp; The CAP Theorem | static.googleusercontent.com<dd><a href="https://static.googleusercontent.com/media/research.google.com/ko//pubs/archive/45855.pdf">static.googleusercontent.com</a><dt>Towards robust distributed systems (abstract) | dl.acm.org<dd><a href="https://dl.acm.org/doi/10.1145/343477.343502">Towards robust distributed systems (abstract) | Proceedings of the nineteenth annual ACM symposium on Principles of distributed computing</a><dt>Top Eventual Consistency Patterns You Must Know | bytebytego.com<dd><a href="https://bytebytego.com/guides/top-eventual-consistency-patterns-you-must-know/">ByteByteGo | Top Eventual Consistency Patterns You Must Know</a><dt>CAP, PACELC, ACID, BASE - Essential Concepts for an Architect’s Toolkit | blog.bytebytego.com<dd><a href="https://blog.bytebytego.com/p/cap-pacelc-acid-base-essential-concepts">CAP, PACELC, ACID, BASE - Essential Concepts for an Architect’s Toolkit</a><dt>Two-phase commit protocol | en.wikipedia.org<dd><a href="https://en.wikipedia.org/wiki/Two-phase_commit_protocol">Two-phase commit protocol</a><dt>Engineering Trade-offs: Eventual Consistency in Practice | blog.bytebytego.com<dd><a href="https://blog.bytebytego.com/p/a-guide-to-eventual-consistency-in">Engineering Trade-offs: Eventual Consistency in Practice</a></dl></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw me-1"></i> <a href="/categories/system-design-interview/">System Design Interview</a>, <a href="/categories/core-concepts/">Core Concepts</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw me-1"></i> <a href="/tags/system-design/" class="post-tag no-text-decoration" >System Design</a> <a href="/tags/interview/" class="post-tag no-text-decoration" >interview</a> <a href="/tags/computer-science/" class="post-tag no-text-decoration" >Computer Science</a> <a href="/tags/cap-theorem/" class="post-tag no-text-decoration" >CAP Theorem</a> <a href="/tags/saga-pattern/" class="post-tag no-text-decoration" >SAGA Pattern</a></div><div class=" post-tail-bottom d-flex justify-content-between align-items-center mt-5 pb-2 " ><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper d-flex align-items-center"> <span class="share-label text-muted">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=CAP%20Theorem(%EC%A0%95%EB%A6%AC)%20%7C%20Core%20Concepts%20-%20System%20Design%20Interview%20-%20KanghoonYi(Pour)&url=https%3A%2F%2Fblog.devpour.net%2Fposts%2FCAP-Theorem%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Twitter" aria-label="Twitter"> <i class="fa-fw fa-brands fa-square-x-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=CAP%20Theorem(%EC%A0%95%EB%A6%AC)%20%7C%20Core%20Concepts%20-%20System%20Design%20Interview%20-%20KanghoonYi(Pour)&u=https%3A%2F%2Fblog.devpour.net%2Fposts%2FCAP-Theorem%2F" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Facebook" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https%3A%2F%2Fblog.devpour.net%2Fposts%2FCAP-Theorem%2F&text=CAP%20Theorem(%EC%A0%95%EB%A6%AC)%20%7C%20Core%20Concepts%20-%20System%20Design%20Interview%20-%20KanghoonYi(Pour)" target="_blank" rel="noopener" data-bs-toggle="tooltip" data-bs-placement="top" title="Telegram" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <button id="copy-link" aria-label="Copy link" class="btn small" data-bs-toggle="tooltip" data-bs-placement="top" title="Copy link" data-title-succeed="Link copied successfully!" > <i class="fa-fw fas fa-link pe-none fs-6"></i> </button> </span></div></div></div></article></main><aside aria-label="Panel" id="panel-wrapper" class="col-xl-3 ps-2 mb-5 text-muted"><div class="access"><section id="access-lastmod"><h2 class="panel-heading">Recently Updated</h2><ul class="content list-unstyled ps-0 pb-1 ms-1 mt-2"><li class="text-truncate lh-lg"> <a href="/posts/Redis/">Redis | Key Technologies - System Design Interview</a><li class="text-truncate lh-lg"> <a href="/posts/Consistent-Hashing/">Consistent Hashing | Core Concepts - System Design Interview</a><li class="text-truncate lh-lg"> <a href="/posts/k8s-introduction/">Kubernetes(Orchestration) 개론</a><li class="text-truncate lh-lg"> <a href="/posts/CAP-Theorem/">CAP Theorem(정리) | Core Concepts - System Design Interview</a><li class="text-truncate lh-lg"> <a href="/posts/What-is-CloudNativePG/">What is CloudNativePG? | CloudNative</a></ul></section><section><h2 class="panel-heading">Trending Tags</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/programming/">programming</a> <a class="post-tag btn btn-outline-primary" href="/tags/aws/">aws</a> <a class="post-tag btn btn-outline-primary" href="/tags/leetcode/">leetcode</a> <a class="post-tag btn btn-outline-primary" href="/tags/rust/">rust</a> <a class="post-tag btn btn-outline-primary" href="/tags/computer-science/">Computer Science</a> <a class="post-tag btn btn-outline-primary" href="/tags/cncf/">cncf</a> <a class="post-tag btn btn-outline-primary" href="/tags/k8s/">k8s</a> <a class="post-tag btn btn-outline-primary" href="/tags/kubernetes/">kubernetes</a> <a class="post-tag btn btn-outline-primary" href="/tags/algorithm/">algorithm</a> <a class="post-tag btn btn-outline-primary" href="/tags/architecture/">Architecture</a></div></section></div><section id="toc-wrapper" class="d-none ps-0 pe-4"><h2 class="panel-heading ps-3 mb-2">Contents</h2><nav id="toc"></nav></section></aside></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 px-md-4"><aside id="related-posts" aria-labelledby="related-label"><h3 class="mb-4" id="related-label">Further Reading</h3><nav class="row row-cols-1 row-cols-md-2 row-cols-xl-3 g-4 mb-4"><article class="col"> <a href="/posts/Consistent-Hashing/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1753809540" data-df="ll" > Jul 30, 2025 </time><h4 class="pt-0 my-2">Consistent Hashing | Core Concepts - System Design Interview</h4><div class="text-muted"><p>‘Consistent Hashing’은 분산 시스템(Distributed System)의 Cluster에서, 데이터를 분산 저장할때 사용하는 기초적인 알고리즘 입니다. 예시로 보는 Consistent Hashing의 필요성 ‘Ticketing System을 구성한다고 해봅시다. Simple System과 Sharding이 적용된 System...</p></div></div></a></article><article class="col"> <a href="/posts/networking-essentials/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1752733200" data-df="ll" > Jul 17, 2025 </time><h4 class="pt-0 my-2">Networking Essentials | Core Concepts - System Design Interview</h4><div class="text-muted"><p>시스템 디자인(System Design)에 있어, 네트워킹(Netwoking)은 고려해야하는 필수적인 부분중 하나입니다. 이 Post에선, 네트워킹에서도 가장 중요한 부분만 정리하려고 합니다. 네트워킹 기초(Networking 101) OSI(Open Systems Interconnection) Model 7 Layers OSI Model 7 L...</p></div></div></a></article><article class="col"> <a href="/posts/Redis/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1754301420" data-df="ll" > Aug 4, 2025 </time><h4 class="pt-0 my-2">Redis | Key Technologies - System Design Interview</h4><div class="text-muted"><p>Redis 소개 Redis is the world’s fastest in-memory database. - from redis.io Redis는 C로 작성된, 오픈소스 in-memory key-value 저장소 입니다.(데이터를 Disk가 아닌 RAM에 저장하여 사용합니다.) 빠른 속도와 다양한 자료구조(Data structur...</p></div></div></a></article></nav></aside><nav class="post-navigation d-flex justify-content-between" aria-label="Post Navigation"> <a href="/posts/What-is-Kafka/" class="btn btn-outline-primary" aria-label="Older" ><p>What is Kafka? | CloudNative</p></a> <a href="/posts/Consistent-Hashing/" class="btn btn-outline-primary" aria-label="Newer" ><p>Consistent Hashing | Core Concepts - System Design Interview</p></a></nav><script src="https://utteranc.es/client.js" repo="KanghoonYi/kanghoonyi.github.io" issue-term="pathname" crossorigin="anonymous" async ></script> <script type="text/javascript"> (function () { const origin = 'https://utteranc.es'; const lightTheme = 'github-light'; const darkTheme = 'github-dark'; let initTheme = lightTheme; const html = document.documentElement; if ( (html.hasAttribute('data-mode') && html.getAttribute('data-mode') === 'dark') || (!html.hasAttribute('data-mode') && window.matchMedia('(prefers-color-scheme: dark)').matches) ) { initTheme = darkTheme; } addEventListener('message', (event) => { let theme;if (event.origin === origin) {theme = initTheme; } else if (event.source === window && event.data && event.data.direction === ModeToggle.ID) {const mode = event.data.message; theme = mode === ModeToggle.DARK_MODE ? darkTheme : lightTheme; } else { return; } const message = { type: 'set-theme', theme: theme }; const utterances = document.getElementsByClassName('utterances-frame')[0].contentWindow; utterances.postMessage(message, origin); }); })(); </script><footer aria-label="Site Info" class=" d-flex flex-column justify-content-center text-muted flex-lg-row justify-content-lg-between align-items-lg-center pb-lg-3 " ><p>© <time>2025</time> <a href="https://github.com/KanghoonYi">KanghoonYi</a>. <span data-bs-toggle="tooltip" data-bs-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author." >Some rights reserved.</span></p><p>Using the <a data-bs-toggle="tooltip" data-bs-placement="top" title="v7.1.1" href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener" >Chirpy</a> theme for <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a>.</p></footer></div></div><div id="search-result-wrapper" class="d-flex justify-content-center d-none"><div class="col-11 content"><div id="search-hints"><section><h2 class="panel-heading">Trending Tags</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/programming/">programming</a> <a class="post-tag btn btn-outline-primary" href="/tags/aws/">aws</a> <a class="post-tag btn btn-outline-primary" href="/tags/leetcode/">leetcode</a> <a class="post-tag btn btn-outline-primary" href="/tags/rust/">rust</a> <a class="post-tag btn btn-outline-primary" href="/tags/computer-science/">Computer Science</a> <a class="post-tag btn btn-outline-primary" href="/tags/cncf/">cncf</a> <a class="post-tag btn btn-outline-primary" href="/tags/k8s/">k8s</a> <a class="post-tag btn btn-outline-primary" href="/tags/kubernetes/">kubernetes</a> <a class="post-tag btn btn-outline-primary" href="/tags/algorithm/">algorithm</a> <a class="post-tag btn btn-outline-primary" href="/tags/architecture/">Architecture</a></div></section></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><aside aria-label="Scroll to Top"> <button id="back-to-top" type="button" class="btn btn-lg btn-box-shadow"> <i class="fas fa-angle-up"></i> </button></aside></div><div id="mask"></div><script src="https://cdn.jsdelivr.net/combine/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js,npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.umd.min.js,npm/glightbox@3.3.0/dist/js/glightbox.min.js,npm/clipboard@2.0.11/dist/clipboard.min.js,npm/dayjs@1.11.13/dayjs.min.js,npm/dayjs@1.11.13/locale/en.js,npm/dayjs@1.11.13/plugin/relativeTime.js,npm/dayjs@1.11.13/plugin/localizedFormat.js,npm/tocbot@4.29.0/dist/tocbot.min.js"></script> <script src="/assets/js/dist/post.min.js"></script> <script>SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<article class="px-1 px-sm-2 px-lg-4 px-xl-0"><header><h2><a href="{url}">{title}</a></h2><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div></header><p>{snippet}</p></article>', noResultsText: '<p class="mt-5">Oops! No results found.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="me-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
